#ifdef USE_PRAGMA_IDENT_SRC
#pragma ident "@(#)verifier.cpp	1.83 03/12/23 16:44:24 JVM"
#endif
/*
 * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
 * SUN PROPRIETARY/CONFIDENTIAL.  Use is subject to license terms.
 */

# include "incls/_precompiled.incl"
# include "incls/_verifier.cpp.incl"

// Access to external entry for VerifyClassCodes - old byte code verifier

extern "C" {
  typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint);
  typedef jboolean (*verify_byte_codes_fn_new_t)(JNIEnv *, jclass, char *, jint, jint);
}

static void* volatile _verify_byte_codes_fn = NULL;

static volatile bool _is_new_verify_byte_codes_fn = true;

static void* verify_byte_codes_fn() {
  if (_verify_byte_codes_fn == NULL) {
    void *lib_handle = os::native_java_library();
    void *func = hpi::dll_lookup(lib_handle, "VerifyClassCodesForMajorVersion");
    OrderAccess::release_store_ptr(&_verify_byte_codes_fn, func);
    if (func == NULL) {
      OrderAccess::release_store(&_is_new_verify_byte_codes_fn, false);
      func = hpi::dll_lookup(lib_handle, "VerifyClassCodes");
      OrderAccess::release_store_ptr(&_verify_byte_codes_fn, func);
    }
  }
  return (void*)_verify_byte_codes_fn;
}


// Error messages

extern void verify_error(const char* msg, methodHandle m, u2 offset, TRAPS) {
  ResourceMark rm(THREAD);
  Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_VerifyError(),
                     msg, m->name_and_sig_as_C_string(), offset);
}

void class_format_error(const char* msg, u2 target, methodHandle m, TRAPS) {
  ResourceMark rm(THREAD);
  Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_ClassFormatError(),
                     msg, target, m->name_and_sig_as_C_string());
}

// Methods in Verifier

bool Verifier::should_verify_for(oop class_loader) {
  return class_loader == NULL ? BytecodeVerificationLocal : BytecodeVerificationRemote;
}

bool Verifier::relax_verify_for(oop loader) {
  bool trusted = java_lang_ClassLoader::is_trusted_loader(loader);
  bool need_verify = (BytecodeVerificationLocal && BytecodeVerificationRemote) ||               // verifyAll
                     (!BytecodeVerificationLocal && BytecodeVerificationRemote && !trusted);    // verifyRemote
  return !need_verify;
}

void Verifier::verify_byte_codes(instanceKlassHandle klass, TRAPS) {
  if (!should_verify_for(klass->class_loader())) return;

  {
    No_Safepoint_Verifier nosafepoint;

    // return if the class is a bootstraping class
    symbolOop name = klass->name();  
    // We need to skip the following three for bootstraping
    if (name == vmSymbols::java_lang_Object() ||
        name == vmSymbols::java_lang_Class()  ||
        name == vmSymbols::java_lang_String() ||
        name == vmSymbols::java_lang_Throwable()) {
      return;
    }

    // Can not verify the bytecodes for shared classes because they have
    // already been rewritten to contain constant pool cache indices,
    // which the verifier can't understand
    if (klass()->is_shared()) {
      return;
    }
  
    // As of the fix for 4486457 we disable verification for all of the
    // dynamically-generated bytecodes associated with the 1.4
    // reflection implementation, not just those associated with
    // sun/reflect/SerializationConstructorAccessor.
    // NOTE: this is called too early in the bootstrapping process to be
    // guarded by Universe::is_gte_jdk14x_version()/UseNewReflection.
    klassOop refl_magic_klass =
      SystemDictionary::reflect_magic_klass();
    if (refl_magic_klass != NULL) {
      if (klass->is_subtype_of(refl_magic_klass)) {
        if (!VerifyReflectionBytecodes) {
          return;
        }
      }
    }
  }

  if (!UseSplitVerifier ||
      klass->major_version() < STACKMAP_ATTRIBUTE_MAJOR_VERSION) {
    JavaThread *thread = JavaThread::current();
    JNIEnv *env = thread->jni_environment();
  
    void* verify_func = verify_byte_codes_fn();

    if (verify_func == NULL) {
      THROW_MSG(vmSymbols::java_lang_VerifyError(), "Could not link verifier");
    }

    ResourceMark rm;
    if (TraceClassInitialization) {
      tty->print_cr("Start class verification for: %s", klass->external_name());
    }
    if (ClassVerifier::_verify_verbose) {
      tty->print_cr("Verifying class %s with old format", klass->external_name());
    }
  
    char message[256];
    message[0] = 0;

    jclass cls = (jclass) JNIHandles::make_local(env, klass->java_mirror());
    jboolean result;

    {
      HandleMark hm(thread);
      ThreadToNativeFromVM ttn(thread);
      // ThreadToNativeFromVM takes care of changing thread_state, so safepoint code knows that
      // we have left the VM

      if (_is_new_verify_byte_codes_fn) {
        verify_byte_codes_fn_new_t func =
          CAST_TO_FN_PTR(verify_byte_codes_fn_new_t, verify_func);
        result = (*func)(env, cls, message, sizeof(message),
                         klass->major_version());
      } else {
        verify_byte_codes_fn_t func =
          CAST_TO_FN_PTR(verify_byte_codes_fn_t, verify_func);
        result = (*func)(env, cls, message, sizeof(message));
      }
    }
 
    if (TraceClassInitialization) {
      tty->print_cr("Verification result is %d for %s", result, klass->external_name());
      tty->print_cr(" exception pending %d ", thread->pending_exception());
    }

    if (!thread->pending_exception()) {
      // These numbers are chosen so that VerifyClassCodes interface doesn't need
      // to be changed (still return jboolean (unsigned char)), and result is
      // 1 when verification is passed. 
      // 1: good (JNI_TRUE in old jdk)
      if (result == 1) return;
      // 0: verify error (JNI_FALSE in old jdk)
      if (result == 0) {
        THROW_MSG(vmSymbols::java_lang_VerifyError(), message);
      } 
      // 2: out of memory
      if (result == 2) {
        THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), message);
      }
      // 3: class format error
      if (result == 3) {
        THROW_MSG(vmSymbols::java_lang_ClassFormatError(), message);
      }
      // Undocumented result value
      ShouldNotReachHere();
    } 
  } else {    
    ResourceMark rm;

    // The HandleMark needs to be at the class level since
    // the entries in _local_class_type_table should be alive till
    // the end of the verification of the class. So DON'T put
    // a HandleMark in, e.g. verify_method.
    HandleMark hm;

    if (TraceClassInitialization) {
      tty->print_cr("Start class verification for: %s", klass->external_name());
    }
    if (ClassVerifier::_verify_verbose) {
      tty->print_cr("Verifying class %s with new format", klass->external_name());
    }

    ClassVerifier verifier(klass, CHECK);
    verifier.verify_class(THREAD);

    if (HAS_PENDING_EXCEPTION) {      
      Handle pending_exception = Handle(THREAD, PENDING_EXCEPTION);
      CLEAR_PENDING_EXCEPTION;

      if (TraceClassInitialization) {
        tty->print("Verification for %s has", klass->external_name());
        tty->print_cr(" exception pending %d ", pending_exception());
      }
      if (pending_exception.not_null()) THROW_OOP(pending_exception());
    }

    if (TraceClassInitialization) {
      tty->print_cr("End class verification for: %s", klass->external_name());
    }
  }
}

// Methods in ClassTypeHashtable

ClassTypeHashtable::ClassTypeHashtable(int hash_table_size, ClassVerifier* v) : 
                              _table_size(hash_table_size), _verifier(v) {
  _table = NEW_C_HEAP_ARRAY(ClassTypeBucket*, _table_size);
  for (int i = 0; i < _table_size; i++) {
    _table[i] = NULL;
  }
}

ClassTypeHashtable::~ClassTypeHashtable() {
  for (int i = 0; i < _table_size; i++) {
    ClassTypeBucket* current = _table[i];
    ClassTypeBucket* next;
    while (current != NULL) {
      next = current->_next;
      current->_next = NULL;
      delete current->_class_type;
      delete current;
      current = next;
    }      
  }
  FREE_C_HEAP_ARRAY(ClassTypeBucket*, _table);
  _table = NULL;
  _table_size = 0;
  _verifier = NULL;
}

ObjType* ClassTypeHashtable::get_object_type(symbolHandle name,
                                             instanceKlassHandle klass,
                                             bool loadable, TRAPS) {
  unsigned int key = hash_fun(name());
  ClassTypeBucket* p = _table[key];
  while (p != NULL) {
    if (p->_class_type->is_object()) {
      ObjType* t = (ObjType*)p->_class_type;
      if (t->same_name(name())) {
        if (t->klass() == NULL) {
          assert(p->_loadable == true, "only loadable types can have null class");
          klassOop loadable_class = _verifier->load_class(name, CHECK_0);
          t->set_klass(instanceKlassHandle(THREAD, loadable_class));
        } 
        if (t->klass() == klass()) {
          if (loadable && !p->_loadable) {
            p->_loadable = true;
            return t;
          }
        }
      }
    }
    p = p->_next;
  }
  ObjType* t = new ObjType(name, klass, _verifier);
  p = new ClassTypeBucket(t);
  ClassTypeBucket* head = _table[key];
  _table[key] = p;
  p->_loadable = loadable;
  p->_next = head;
  return t;
}

RefType* ClassTypeHashtable::get_class_type_from_name(symbolHandle name, TRAPS) {
  unsigned int key = hash_fun(name());
  ClassTypeBucket* p = _table[key];
  bool forced_load = false;
  while (p != NULL) {
    RefType* t = p->_class_type;
    if (t->is_array()) {
      // If the array type has already been put in the table, return it.
      if (((ArrType*)t)->same_signature(name())) {
        return t;
      }
    } else if (t->is_object()) {
      if (((ObjType*)t)->same_name(name())) {
        if (p->_loadable) {
          return t;
        }
        forced_load = true;
      }
    } 
    p = p->_next;
  }
  if (forced_load) {
    klassOop loaded_class = _verifier->load_class(name(), CHECK_0);
    instanceKlassHandle loaded_class_h(THREAD, loaded_class);
    return get_object_type(name, loaded_class_h, true, CHECK_0);
  }
  RefType* type;
  if (name->byte_at(0) == '[') {
    type = new ArrType(name, _verifier, CHECK_0);
  } else {
    type = new ObjType(name, instanceKlassHandle(), _verifier);
  }
  p = new ClassTypeBucket(type);
  ClassTypeBucket* head = _table[key];
  _table[key] = p;
  p->_loadable = true;
  p->_next = head;
  return type;
}

unsigned int ClassTypeHashtable::hash_fun(symbolOop name) {
  ResourceMark rm;
  unsigned int raw_hash = 0;
  char *s = name->as_C_string();
  while( *s != '\0') {
    raw_hash = *s++ + 37 * raw_hash;
  }
  return raw_hash % _table_size;
}


// Methods in ClassVerifier

bool ClassVerifier::_verify_verbose = false;

ClassVerifier::ClassVerifier(instanceKlassHandle klass, TRAPS) : _klass(klass) {
  _local_class_type_table = new ClassTypeHashtable(klass->constants()->size(), this);
  _object_class_type = 
    (ObjType*)_local_class_type_table->get_class_type_from_name(vmSymbols::java_lang_Object(), CHECK); 
  _string_class_type = 
    (ObjType*)_local_class_type_table->get_class_type_from_name(vmSymbols::java_lang_String(), CHECK); 
  _throwable_class_type = 
    (ObjType*)_local_class_type_table->get_class_type_from_name(vmSymbols::java_lang_Throwable(), CHECK);

  instanceKlassHandle ikh(THREAD, klass->as_klassOop());
  _current_class_type = _local_class_type_table->get_object_type(klass->name(), 
                                                                 ikh, 
                                                                 true, 
                                                                 CHECK);
  instanceKlassHandle super(THREAD, klass->super());
  symbolHandle super_name(THREAD, super->name());
  if (super_name() == vmSymbols::java_lang_Object()) {
    _super_class_type = _object_class_type;
  } else if (super_name() == vmSymbols::java_lang_Throwable()) {
    _super_class_type = _throwable_class_type;
  } else if (super_name() == vmSymbols::java_lang_String()) {
    _super_class_type = _string_class_type;
  } else {
    _super_class_type = _local_class_type_table->get_object_type(super_name, super, false, CHECK);
  }
}

ClassVerifier::~ClassVerifier() {
  delete _local_class_type_table;
}

void ClassVerifier::verify_class(TRAPS) {
  objArrayHandle methods = _klass->methods();
  int num_methods = methods->length();

  for (int index = 0; index < num_methods; index++) {
    methodHandle m (THREAD, (methodOop)methods->obj_at(index));
    if (m->is_native() || m->is_abstract()) {
      // If m is native or abstract, skip it.
      // It is checked in class file parser that methods do not override a final method.
      continue;
    }
    verify_method(m, CHECK);
  }
}

void ClassVerifier::verify_method(methodHandle m, TRAPS) {
  ResourceMark rm(THREAD);
  _method = m;   // initialize _method
  if (_verify_verbose) {
    tty->print_cr("Verifying method %s", m->name_and_sig_as_C_string());
  }

  u2 max_stack = m->max_stack();
  u2 max_locals = m->max_locals();
  constantPoolHandle cp (THREAD, m->constants());
      
  // Initial stack map frame: offset is 0, stack is initially empty.
  StackMapFrame current_frame(max_locals, max_stack, this);
  // Set initial locals
  VerificationType* return_type = current_frame.set_locals_from_arg(m, _current_class_type, CHECK);

  u2 stackmap_index = 0; // index to the stackmap array
  StackMapReader reader(this);
  StackMapTable stackmap_table(reader, max_locals, max_stack, CHECK);

  if (_verify_verbose) {
    stackmap_table.print();
  }

  // Scan the byte code and map each instruction's start offset to a number. 
  u4 code_length = m->code_size();
  RawBytecodeStream bcs(m);

  // Since code_length is limited to 16 bits, int* is good enough to hold code_data.
  // When code_length is increased to 32 bits, we need to use long*.
  int* code_data = generate_code_data(bcs.bcp(), code_length, CHECK);

  // Look through each item on the exception table. Each of the fields must refer
  // to a legal instruction.
  verify_exception_handler_table(code_length, code_data, CHECK);

  // Look through each entry on the local variable table and make sure 
  // its range of code array offsets is valid. (4169817)
  if (m->has_localvariable_table()) {
    verify_local_variable_table(code_length, code_data, CHECK);
  }

  // Scan the byte code linearly from the start to the end
  bool no_control_flow = false; // Set to true when there is no direct control
                                // flow from current instruction to the next
                                // instruction in sequence
  Bytecodes::Code opcode;
  while( (opcode = bcs.raw_next()) >= 0) {
    u2 bci = bcs.bci();

    // Set current frame's offset to bci
    current_frame.set_offset(bci);

    // Check that stackmaps are ordered according to offset, and every offset 
    // in stackmap table point to the beginning to an instruction.
    // Match current_frame to stackmap_table entry with the same offset if exists.
    stackmap_index = verify_stackmap_table(stackmap_index, bci, &current_frame, &stackmap_table, 
                                           no_control_flow, CHECK);

    bool this_uninit = false;  // Set to true when invokespecial <init> initialized 'this'
    
    // Merge with the next instruction 
    no_control_flow = verify_instruction(&bcs, &this_uninit, code_length, code_data, return_type, 
                                         &current_frame, &stackmap_table, cp, CHECK);

    // Look for possible jump target in exception handlers and see if it matches current_frame
    verify_exception_handler_targets(bci, this_uninit, &current_frame, &stackmap_table, CHECK);
  } // end while

  // Make sure that control flow does not fall through end of the method
  if (!no_control_flow) {
    verify_error("Control flow falls through code end in method %s",
                 m, code_length, CHECK);
  }
  m->delete_stackmap();  // stackmap tables in methodOop is ready for GC
}

int* ClassVerifier::generate_code_data(address bcp, u4 code_length, TRAPS) {
  int* code_data = NEW_RESOURCE_ARRAY(int, code_length);
  jlong offset, next_offset;  // use jlong to make sure they don't overflow
                              // an int since a table/lookupswitch can return
                              // a big instruction length
  u4 index;
  for (offset = 0, index = 0; offset < code_length; index++) {
    address current_bcp = bcp + offset;
    if(Bytecodes::is_active_breakpoint_at(current_bcp)) {
      verify_error("Invalid bytecode found in method %s at offset %d", 
                   _method, offset, CHECK_0);      
    }
    if (!Bytecodes::is_defined(*current_bcp) || !Bytecodes::is_java_code((Bytecodes::Code)*current_bcp)) {
      verify_error("Undefined or non java bytecode found in method %s at offset %d", 
                   _method, offset, CHECK_0);            
    }
    int length = Bytecodes::length_at(current_bcp);
    if (length <= 0) {
      verify_error("Illegal instruction in method %s at offset %d", 
                   _method, offset, CHECK_0);
    }
    next_offset = offset + length;
    if (next_offset > code_length) {
      verify_error("Method code ends in the middle of an instruction in method %s at offset %d", 
                   _method, offset, CHECK_0);               
    }
    code_data[offset] = index;
    while (++offset < next_offset) {
      code_data[offset] = -1; // illegal location
    }
  }

  return code_data;
}

void ClassVerifier::verify_exception_handler_table(u4 code_length, int* code_data, TRAPS) {
  typeArrayHandle exhandlers (THREAD, _method->exception_table());
  constantPoolHandle cp (THREAD, _method->constants());
  
  if (exhandlers() != NULL) {
    for(int i = 0; i < exhandlers->length();) {
      u2 start_pc = exhandlers->int_at(i++);
      u2 end_pc = exhandlers->int_at(i++);
      u2 handler_pc = exhandlers->int_at(i++);
      if (!is_legal_target(start_pc, code_length, code_data)) {
        class_format_error("Illegal exception table start_pc %d in method %s",
                           start_pc, _method, CHECK);
      }
      if (end_pc != code_length) {   // special case: end_pc == code_length
        if (!is_legal_target(end_pc, code_length, code_data)) {
        class_format_error("Illegal exception table end_pc %d in method %s", 
                           end_pc, _method, CHECK);
        }
      }
      if (!is_legal_target(handler_pc, code_length, code_data)) {
        class_format_error("Illegal exception table handler_pc %d in method %s", 
                           handler_pc, _method, CHECK);
      }
      int catch_type_index = exhandlers->int_at(i++);
      if (catch_type_index != 0) {
        // verify_cp_class_type(catch_type_index, cp, CHECK); // checked in format checker
        RefType* catch_type = cp_index_to_type(catch_type_index, cp, CHECK);
        bool is_subclass = _throwable_class_type->is_assignable_from(catch_type, CHECK);
        if (!is_subclass) {
          // 4286534: should throw VerifyError according to recent spec change
          verify_error("Catch type is not a subclass of Throwable in method %s handler %d",
                       _method, handler_pc, CHECK);
        }
      } 
    }
  }
}

void ClassVerifier::verify_local_variable_table(u4 code_length, int* code_data, TRAPS) {
  int localvariable_table_length = _method()->localvariable_table_length();
  if (localvariable_table_length > 0) {
    LocalVariableTableElement* table = _method()->localvariable_table_start();
    for (int i = 0; i < localvariable_table_length; i++) {
      u2 start_bci = table[i].start_bci;
      u2 length = table[i].length;
      if(!is_legal_target(start_bci, code_length, code_data)) {
        class_format_error("Illegal local variable table start_pc %d in method %s",
                           start_bci, _method, CHECK);
      }
      if ((u4)(start_bci + length) != code_length) {
        if (!is_legal_target(start_bci, code_length, code_data)) {
          class_format_error("Illegal local variable table length %d in method %s",
                             length, _method, CHECK);
        }
      }
    }
  }
}

u2 ClassVerifier::verify_stackmap_table(u2 stackmap_index, u2 bci,
                                        StackMapFrame* current_frame, 
                                        StackMapTable* stackmap_table,
                                        bool no_control_flow, TRAPS) {
  if (stackmap_index < stackmap_table->get_frame_count()) {
    u2 this_offset = stackmap_table->get_offset(stackmap_index);
    if (no_control_flow && this_offset > bci) {
      verify_error("Expecting a stack map frame in method %s at offset %d",
                   _method, bci, CHECK_0);
    }
    if (this_offset == bci) {
      // See if current stack map can be assigned to the frame in table.
      // current_frame is the stackmap frame got from the last instruction.
      // If matched, current_frame will be updated by this method.
      bool match = stackmap_table->match_stackmap(current_frame,
                                                  this_offset, stackmap_index,
                                                  !no_control_flow, true,
                                                  CHECK_0);
      if (!match) {
        // report type error
        verify_error("Instruction type does not match stack map in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      stackmap_index++;
    } else if (this_offset < bci) {
      // current_offset should have met this_offset.
      class_format_error("Bad stack map offset %d in method %s",
                         this_offset, _method, CHECK_0);
    }
  } else if (no_control_flow) {
    verify_error("Expecting a stack map frame in method %s at offset %d",
                 _method, bci, CHECK_0);    
  }
  return stackmap_index;
}

void ClassVerifier::verify_exception_handler_targets(u2 bci, bool this_uninit, StackMapFrame* current_frame, 
                                                     StackMapTable* stackmap_table, TRAPS) {
  constantPoolHandle cp (THREAD, _method->constants());
  typeArrayHandle exhandlers (THREAD, _method->exception_table());
  if (exhandlers() != NULL) {
    for(int i = 0; i < exhandlers->length();) {
      u2 start_pc = exhandlers->int_at(i++);
      u2 end_pc = exhandlers->int_at(i++);
      u2 handler_pc = exhandlers->int_at(i++);
      int catch_type_index = exhandlers->int_at(i++);
      if(bci >= start_pc && bci < end_pc) {
        u1 flags = current_frame->flags(); 
        if (this_uninit) {  flags |= FLAG_THIS_UNINIT; }
        StackMapFrame* new_frame = current_frame->frame_in_exception_handler(flags);
        if (catch_type_index != 0) {
          // We know that this index refers to a subclass of Throwable
          RefType* catch_type = cp_index_to_type(catch_type_index, cp, CHECK);
          new_frame->push_stack(catch_type, CHECK);
        } else {
          new_frame->push_stack(_throwable_class_type, CHECK);
        }
        bool match = stackmap_table->match_stackmap(new_frame, handler_pc,
                                                    true, false, CHECK);
        delete new_frame;
        if (!match) {
          ResourceMark rm(THREAD);
          Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_VerifyError(),
                  "Stack map at offset %d does not match the one at exception handler %d in method %s", 
                  bci, handler_pc, _method->name_and_sig_as_C_string(), CHECK);
        }
      }
    }
  } 
}

void ClassVerifier::verify_constant_pool_type(int index, constantPoolHandle cp, unsigned int types, TRAPS) {
  int nconstants = cp->length();
  if ((index <= 0) || (index >= nconstants)) {
    ResourceMark rm(THREAD);
    Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_VerifyError(),
                       "Illegal constant pool index %d in class %s", 
                        index, instanceKlass::cast(cp->pool_holder())->external_name(), CHECK);
  }
  unsigned int tag = cp->tag_at(index).value();
  if ((types & (1 << tag)) == 0) {
    ResourceMark rm(THREAD);
    Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_VerifyError(),
                       "Illegal type at constant pool entry %d in class %s", 
                        index, instanceKlass::cast(cp->pool_holder())->external_name(), CHECK);    
  }
}

void ClassVerifier::verify_cp_class_type(int index, constantPoolHandle cp, TRAPS) {
  int nconstants = cp->length();
  if ((index <= 0) || (index >= nconstants)) {
    ResourceMark rm(THREAD);
    Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_VerifyError(),
                       "Illegal constant pool index %d in class %s", 
                        index, instanceKlass::cast(cp->pool_holder())->external_name(), CHECK);
  }
  constantTag tag = cp->tag_at(index);
  if (!tag.is_klass() && !tag.is_unresolved_klass()) {
    ResourceMark rm(THREAD);
    Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_VerifyError(),
                       "Illegal type at constant pool entry %d in class %s", 
                        index, instanceKlass::cast(cp->pool_holder())->external_name(), CHECK);            
  }
}    

void ClassVerifier::check_legal_target(u2 target, u4 code_length, int* code_data, u2 bci, TRAPS) {
  if (!is_legal_target(target, code_length, code_data)) {
    ResourceMark rm(THREAD);
    Exceptions::fthrow(THREAD_AND_LOCATION, 
                       vmSymbols::java_lang_VerifyError(),
                       "Illegal branch target %d in method %s at offset %d",  
                       target, _method->name_and_sig_as_C_string(), bci, CHECK);                
  }
}

// Returns true if no control flow falls through next instruction.
bool ClassVerifier::verify_instruction(RawBytecodeStream* bcs, bool* this_uninit, u4 code_length,
                                       int* code_data, VerificationType* return_type, 
                                       StackMapFrame* current_frame, StackMapTable* stackmap_table, 
                                       constantPoolHandle cp, TRAPS) {
  u2 index;
  u2 target;
  VerificationType *type, *type2;
  ArrType* atype;

  u2 bci = bcs->bci();
  Bytecodes::Code opcode = bcs->code();

  if (_verify_verbose) {
    current_frame->print();
    tty->print_cr("offset = %d,  opcode = %s", bci, Bytecodes::name(opcode));
  }

  // Make sure wide instruction is in correct format
  if (bcs->is_wide()) {
    if (opcode != Bytecodes::_iinc   && opcode != Bytecodes::_iload  &&
        opcode != Bytecodes::_aload  && opcode != Bytecodes::_lload  &&
        opcode != Bytecodes::_istore && opcode != Bytecodes::_astore &&
        opcode != Bytecodes::_lstore && opcode != Bytecodes::_fload  &&
        opcode != Bytecodes::_dload  && opcode != Bytecodes::_fstore &&
        opcode != Bytecodes::_dstore) {
      verify_error("Bad wide instruction in method %s at offset %d",
                   _method, bci, CHECK_0);
    }
  }

  switch( opcode ) {
    case Bytecodes::_nop : 
      return false;
    case Bytecodes::_aconst_null :
      current_frame->push_stack(VerificationType::_null_type, CHECK_0);
      return false;
    case Bytecodes::_iconst_m1 :
    case Bytecodes::_iconst_0 :
    case Bytecodes::_iconst_1 :
    case Bytecodes::_iconst_2 :
    case Bytecodes::_iconst_3 :
    case Bytecodes::_iconst_4 :
    case Bytecodes::_iconst_5 :
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_lconst_0 :
    case Bytecodes::_lconst_1 :
      current_frame->push_stack(VerificationType::_long_type, CHECK_0);
      current_frame->push_stack(VerificationType::_long2_type, CHECK_0);
      return false;
    case Bytecodes::_fconst_0 :
    case Bytecodes::_fconst_1 :
    case Bytecodes::_fconst_2 :
      current_frame->push_stack(VerificationType::_float_type, CHECK_0);
      return false;
    case Bytecodes::_dconst_0 :
    case Bytecodes::_dconst_1 :
      current_frame->push_stack(VerificationType::_double_type, CHECK_0);
      current_frame->push_stack(VerificationType::_double2_type, CHECK_0);
      return false;
    case Bytecodes::_sipush :
    case Bytecodes::_bipush :
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_ldc : 
      verify_ldc(opcode, bcs->get_index(), current_frame, cp, bci, CHECK_0);
      return false;
    case Bytecodes::_ldc_w :
    case Bytecodes::_ldc2_w :
      verify_ldc(opcode, bcs->get_index_big(), current_frame, cp, bci, CHECK_0);
      return false;
    case Bytecodes::_iload :
      verify_iload(bcs->get_index(), current_frame, CHECK_0);
      return false;
    case Bytecodes::_iload_0 :
    case Bytecodes::_iload_1 :
    case Bytecodes::_iload_2 :
    case Bytecodes::_iload_3 :
      index = opcode - Bytecodes::_iload_0;
      verify_iload(index, current_frame, CHECK_0);
      return false;
    case Bytecodes::_lload :
      verify_lload(bcs->get_index(), current_frame, CHECK_0);
      return false;
    case Bytecodes::_lload_0 :
    case Bytecodes::_lload_1 :
    case Bytecodes::_lload_2 :
    case Bytecodes::_lload_3 :
      index = opcode - Bytecodes::_lload_0;
      verify_lload(index, current_frame, CHECK_0);
      return false;
    case Bytecodes::_fload :
      verify_fload(bcs->get_index(), current_frame, CHECK_0);
      return false;
    case Bytecodes::_fload_0 :
    case Bytecodes::_fload_1 :
    case Bytecodes::_fload_2 :
    case Bytecodes::_fload_3 :
      index = opcode - Bytecodes::_fload_0;
      verify_fload(index, current_frame, CHECK_0);
      return false;
    case Bytecodes::_dload :
      verify_dload(bcs->get_index(), current_frame, CHECK_0);
      return false;
    case Bytecodes::_dload_0 :
    case Bytecodes::_dload_1 :
    case Bytecodes::_dload_2 :
    case Bytecodes::_dload_3 :
      index = opcode - Bytecodes::_dload_0;
      verify_dload(index, current_frame, CHECK_0);
      return false;
    case Bytecodes::_aload :
      verify_aload(bcs->get_index(), current_frame, CHECK_0);
      return false;
    case Bytecodes::_aload_0 :
    case Bytecodes::_aload_1 :
    case Bytecodes::_aload_2 :
    case Bytecodes::_aload_3 :
      index = opcode - Bytecodes::_aload_0;
      verify_aload(index, current_frame, CHECK_0);
      return false;
    case Bytecodes::_iaload :
      type = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_int_array()) {
        verify_error("Bad type on operand stack in iaload in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_baload :
      type = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_bool_array() && !atype->is_byte_array()) {
        verify_error("Bad type on operand stack in baload in method %s at offset %d",
                     _method, bci, CHECK_0);            
      }
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_caload :
      type = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_char_array()) {
        verify_error("Bad type on operand stack in caload in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_saload :
      type = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_short_array()) {
        verify_error("Bad type on operand stack in saload in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_laload :
      type = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_long_array()) {
        verify_error("Bad type on operand stack in laload in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      current_frame->push_stack(VerificationType::_long_type, CHECK_0);
      current_frame->push_stack(VerificationType::_long2_type, CHECK_0);
      return false;
    case Bytecodes::_faload :
      type = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_float_array()) {
        verify_error("Bad type on operand stack in faload in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      current_frame->push_stack(VerificationType::_float_type, CHECK_0);
      return false;
    case Bytecodes::_daload :
      type = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_double_array()) {
        verify_error("Bad type on operand stack in daload in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      current_frame->push_stack(VerificationType::_double_type, CHECK_0);
      current_frame->push_stack(VerificationType::_double2_type, CHECK_0);
      return false;
    case Bytecodes::_aaload : {
      type = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_reference_array()) {
        verify_error("Bad type on operand stack in aaload in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      if (atype->is_null()) {
        current_frame->push_stack(VerificationType::_null_type, CHECK_0);
      } else {
        VerificationType* component = atype->get_component(CHECK_0);
        current_frame->push_stack(component, CHECK_0);
      }
      return false; 
    }
    case Bytecodes::_istore :
      verify_istore(bcs->get_index(), current_frame, CHECK_0);
      return false;
    case Bytecodes::_istore_0 :
    case Bytecodes::_istore_1 :
    case Bytecodes::_istore_2 :
    case Bytecodes::_istore_3 :
      index = opcode - Bytecodes::_istore_0;
      verify_istore(index, current_frame, CHECK_0);
      return false;
    case Bytecodes::_lstore :
      verify_lstore(bcs->get_index(), current_frame, CHECK_0);
      return false;
    case Bytecodes::_lstore_0 :
    case Bytecodes::_lstore_1 :
    case Bytecodes::_lstore_2 :
    case Bytecodes::_lstore_3 :
      index = opcode - Bytecodes::_lstore_0;
      verify_lstore(index, current_frame, CHECK_0);
      return false;
    case Bytecodes::_fstore :
      verify_fstore(bcs->get_index(), current_frame, CHECK_0);
      return false;
    case Bytecodes::_fstore_0 :
    case Bytecodes::_fstore_1 :
    case Bytecodes::_fstore_2 :
    case Bytecodes::_fstore_3 :
      index = opcode - Bytecodes::_fstore_0;
      verify_fstore(index, current_frame, CHECK_0);        
      return false;
    case Bytecodes::_dstore :
      verify_dstore(bcs->get_index(), current_frame, CHECK_0);
      return false;
    case Bytecodes::_dstore_0 :
    case Bytecodes::_dstore_1 :
    case Bytecodes::_dstore_2 :
    case Bytecodes::_dstore_3 :
      index = opcode - Bytecodes::_dstore_0;
      verify_dstore(index, current_frame, CHECK_0);        
      return false;
    case Bytecodes::_astore :
      verify_astore(bcs->get_index(), current_frame, CHECK_0);
      return false;
    case Bytecodes::_astore_0 :
    case Bytecodes::_astore_1 :
    case Bytecodes::_astore_2 :
    case Bytecodes::_astore_3 :
      index = opcode - Bytecodes::_astore_0;
      verify_astore(index, current_frame, CHECK_0);
      return false;
    case Bytecodes::_iastore :
      type = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      type2 = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_int_array()) {
        verify_error("Bad type on operand stack in iastore in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      return false;
    case Bytecodes::_bastore :
      type = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      type2 = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_bool_array() && !atype->is_byte_array()) {
        verify_error("Bad type on operand stack in bastore in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      return false;
    case Bytecodes::_castore :
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_char_array()) {
        verify_error("Bad type on operand stack in castore in class %s method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      return false;
    case Bytecodes::_sastore :
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_short_array()) {
        verify_error("Bad type on operand stack in sastore in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      return false;
    case Bytecodes::_lastore :
      current_frame->pop_stack(VerificationType::_long2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_long_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_long_array()) {
        verify_error("Bad type on operand stack in lastore in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      return false;
    case Bytecodes::_fastore :
      current_frame->pop_stack(VerificationType::_float_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_float_array()) {
        verify_error("Bad type on operand stack in fastore in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      return false;
    case Bytecodes::_dastore :
      current_frame->pop_stack(VerificationType::_double2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_double_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_double_array()) {
        verify_error("Bad type on operand stack in dastore in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      return false;
    case Bytecodes::_aastore : 
    {
      type = current_frame->pop_stack(RefType::_reference_type, CHECK_0);
      type2 = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      atype = (ArrType*)current_frame->pop_stack(RefType::_array_type, CHECK_0);
      if (!atype->is_reference_array()) {
        verify_error("Bad type on operand stack in aastore in method %s at offset %d",
                      _method, bci, CHECK_0);
      }
      // 4938384: relaxed constraint in JVMS 3nd edition.
      return false;
    }
    case Bytecodes::_pop :
      current_frame->pop_stack(VerificationType::_category1_type, CHECK_0);
      return false;
    case Bytecodes::_pop2 :
      type = current_frame->pop_stack(CHECK_0);  
      if (type->is_category1()) {
        current_frame->pop_stack(VerificationType::_category1_type, CHECK_0);
      } else if (type->is_category2_2nd()) {
        current_frame->pop_stack(VerificationType::_category2_type, CHECK_0);
      } else {
        verify_error("Bad type on operand stack in pop2 in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      return false;
    case Bytecodes::_dup : 
      type = current_frame->pop_stack(VerificationType::_category1_type, CHECK_0);
      current_frame->push_stack(type, CHECK_0);
      current_frame->push_stack(type, CHECK_0);
      return false;
    case Bytecodes::_dup_x1 :
      type = current_frame->pop_stack(VerificationType::_category1_type, CHECK_0);
      type2 = current_frame->pop_stack(VerificationType::_category1_type, CHECK_0);
      current_frame->push_stack(type, CHECK_0);
      current_frame->push_stack(type2, CHECK_0);
      current_frame->push_stack(type, CHECK_0);
      return false;
    case Bytecodes::_dup_x2 : 
    {
      VerificationType* type3;
      type = current_frame->pop_stack(VerificationType::_category1_type, CHECK_0);
      type2 = current_frame->pop_stack(CHECK_0);
      if (type2->is_category1()) {
        type3 = current_frame->pop_stack(VerificationType::_category1_type, CHECK_0);
      } else if (type2->is_category2_2nd()) {
        type3 = current_frame->pop_stack(VerificationType::_category2_type, CHECK_0);
      } else {
        verify_error("Bad type on operand stack in dup_x2 in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      current_frame->push_stack(type, CHECK_0);
      current_frame->push_stack(type3, CHECK_0);
      current_frame->push_stack(type2, CHECK_0);
      current_frame->push_stack(type, CHECK_0);
      return false;
    }
    case Bytecodes::_dup2 :
      type = current_frame->pop_stack(CHECK_0);
      if (type->is_category1()) {
        type2 = current_frame->pop_stack(VerificationType::_category1_type, CHECK_0);
      } else if (type->is_category2_2nd()) {
        type2 = current_frame->pop_stack(VerificationType::_category2_type, CHECK_0);
      } else {
        verify_error("Bad type on operand stack in dup2 in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      current_frame->push_stack(type2, CHECK_0);
      current_frame->push_stack(type, CHECK_0);
      current_frame->push_stack(type2, CHECK_0);
      current_frame->push_stack(type, CHECK_0);
      return false;
    case Bytecodes::_dup2_x1 :
    {
      VerificationType* type3;
      type = current_frame->pop_stack(CHECK_0);
      if (type->is_category1()) {
        type2 = current_frame->pop_stack(VerificationType::_category1_type, CHECK_0);
      } else if(type->is_category2_2nd()) {
        type2 = current_frame->pop_stack(VerificationType::_category2_type, CHECK_0);
      } else {
        verify_error("Bad type on operand stack in dup2_x1 in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      type3 = current_frame->pop_stack(VerificationType::_category1_type, CHECK_0);
      current_frame->push_stack(type2, CHECK_0);
      current_frame->push_stack(type, CHECK_0);
      current_frame->push_stack(type3, CHECK_0);
      current_frame->push_stack(type2, CHECK_0);
      current_frame->push_stack(type, CHECK_0);
      return false;
    }
    case Bytecodes::_dup2_x2 :
    {
      VerificationType *type3, *type4;
      type = current_frame->pop_stack(CHECK_0);
      if (type->is_category1()) {
        type2 = current_frame->pop_stack(VerificationType::_category1_type, CHECK_0);
      } else if (type->is_category2_2nd()) {
        type2 = current_frame->pop_stack(VerificationType::_category2_type, CHECK_0);
      } else {
        verify_error("Bad type on operand stack in dup2_x2 in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      type3 = current_frame->pop_stack(CHECK_0);
      if (type3->is_category1()) {
        type4 = current_frame->pop_stack(VerificationType::_category1_type, CHECK_0);
      } else if (type3->is_category2_2nd()) {
        type4 = current_frame->pop_stack(VerificationType::_category2_type, CHECK_0);
      } else {
        verify_error("Bad type on operand stack in dup2_x2 in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      current_frame->push_stack(type2, CHECK_0);
      current_frame->push_stack(type, CHECK_0);
      current_frame->push_stack(type4, CHECK_0);
      current_frame->push_stack(type3, CHECK_0);
      current_frame->push_stack(type2, CHECK_0);
      current_frame->push_stack(type, CHECK_0);
      return false;
    }
    case Bytecodes::_swap :
      type = current_frame->pop_stack(VerificationType::_category1_type, CHECK_0);
      type2 = current_frame->pop_stack(VerificationType::_category1_type, CHECK_0);
      current_frame->push_stack(type, CHECK_0);
      current_frame->push_stack(type2, CHECK_0);
      return false;
    case Bytecodes::_iadd :
    case Bytecodes::_isub :
    case Bytecodes::_imul :
    case Bytecodes::_idiv :
    case Bytecodes::_irem :
    case Bytecodes::_ishl :
    case Bytecodes::_ishr :
    case Bytecodes::_iushr :
    case Bytecodes::_ior :
    case Bytecodes::_ixor :
    case Bytecodes::_iand :
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      // fall through 
    case Bytecodes::_ineg :
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_ladd :
    case Bytecodes::_lsub :
    case Bytecodes::_lmul :
    case Bytecodes::_ldiv :
    case Bytecodes::_lrem :
    case Bytecodes::_land :
    case Bytecodes::_lor :
    case Bytecodes::_lxor :
      current_frame->pop_stack(VerificationType::_long2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_long_type, CHECK_0);
      // fall through 
    case Bytecodes::_lneg :
      current_frame->pop_stack(VerificationType::_long2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_long_type, CHECK_0);
      current_frame->push_stack(VerificationType::_long_type, CHECK_0);
      current_frame->push_stack(VerificationType::_long2_type, CHECK_0);
      return false;
    case Bytecodes::_lshl :
    case Bytecodes::_lshr :
    case Bytecodes::_lushr :
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_long2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_long_type, CHECK_0);
      current_frame->push_stack(VerificationType::_long_type, CHECK_0);
      current_frame->push_stack(VerificationType::_long2_type, CHECK_0);
      return false;
    case Bytecodes::_fadd :
    case Bytecodes::_fsub :
    case Bytecodes::_fmul :
    case Bytecodes::_fdiv :
    case Bytecodes::_frem :
      current_frame->pop_stack(VerificationType::_float_type, CHECK_0);
      // fall through 
    case Bytecodes::_fneg :
      current_frame->pop_stack(VerificationType::_float_type, CHECK_0);
      current_frame->push_stack(VerificationType::_float_type, CHECK_0);
      return false;
    case Bytecodes::_dadd :
    case Bytecodes::_dsub :
    case Bytecodes::_dmul :
    case Bytecodes::_ddiv :
    case Bytecodes::_drem :
      current_frame->pop_stack(VerificationType::_double2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_double_type, CHECK_0);
      // fall through 
    case Bytecodes::_dneg :
      current_frame->pop_stack(VerificationType::_double2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_double_type, CHECK_0);
      current_frame->push_stack(VerificationType::_double_type, CHECK_0);
      current_frame->push_stack(VerificationType::_double2_type, CHECK_0);
      return false;
    case Bytecodes::_iinc : 
      verify_iinc(bcs->get_index(), current_frame, CHECK_0);
      return false;
    case Bytecodes::_i2l :
      type = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      current_frame->push_stack(VerificationType::_long_type, CHECK_0);
      current_frame->push_stack(VerificationType::_long2_type, CHECK_0);
      return false;
   case Bytecodes::_l2i :
      current_frame->pop_stack(VerificationType::_long2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_long_type, CHECK_0);
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_i2f :
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      current_frame->push_stack(VerificationType::_float_type, CHECK_0);
      return false;
    case Bytecodes::_i2d :
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      current_frame->push_stack(VerificationType::_double_type, CHECK_0);
      current_frame->push_stack(VerificationType::_double2_type, CHECK_0);
      return false;
    case Bytecodes::_l2f :
      current_frame->pop_stack(VerificationType::_long2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_long_type, CHECK_0);
      current_frame->push_stack(VerificationType::_float_type, CHECK_0);
      return false;
    case Bytecodes::_l2d :
      current_frame->pop_stack(VerificationType::_long2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_long_type, CHECK_0);
      current_frame->push_stack(VerificationType::_double_type, CHECK_0);
      current_frame->push_stack(VerificationType::_double2_type, CHECK_0);
      return false;
    case Bytecodes::_f2i :
      current_frame->pop_stack(VerificationType::_float_type, CHECK_0);
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_f2l :
      current_frame->pop_stack(VerificationType::_float_type, CHECK_0);
      current_frame->push_stack(VerificationType::_long_type, CHECK_0);
      current_frame->push_stack(VerificationType::_long2_type, CHECK_0);
      return false;
    case Bytecodes::_f2d :
      current_frame->pop_stack(VerificationType::_float_type, CHECK_0);
      current_frame->push_stack(VerificationType::_double_type, CHECK_0);
      current_frame->push_stack(VerificationType::_double2_type, CHECK_0);
      return false;
    case Bytecodes::_d2i :
      current_frame->pop_stack(VerificationType::_double2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_double_type, CHECK_0);
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_d2l :
      current_frame->pop_stack(VerificationType::_double2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_double_type, CHECK_0);
      current_frame->push_stack(VerificationType::_long_type, CHECK_0);
      current_frame->push_stack(VerificationType::_long2_type, CHECK_0);
      return false;
    case Bytecodes::_d2f :
      current_frame->pop_stack(VerificationType::_double2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_double_type, CHECK_0);
      current_frame->push_stack(VerificationType::_float_type, CHECK_0);
      return false;
    case Bytecodes::_i2b :
    case Bytecodes::_i2c :
    case Bytecodes::_i2s :
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_lcmp :
      current_frame->pop_stack(VerificationType::_long2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_long_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_long2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_long_type, CHECK_0);
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_fcmpl :
    case Bytecodes::_fcmpg :
      current_frame->pop_stack(VerificationType::_float_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_float_type, CHECK_0);
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_dcmpl :
    case Bytecodes::_dcmpg :
      current_frame->pop_stack(VerificationType::_double2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_double_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_double2_type, CHECK_0);
      current_frame->pop_stack(VerificationType::_double_type, CHECK_0);
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_if_icmpeq:
    case Bytecodes::_if_icmpne:
    case Bytecodes::_if_icmplt:
    case Bytecodes::_if_icmpge:
    case Bytecodes::_if_icmpgt:
    case Bytecodes::_if_icmple:
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      // fall through 
    case Bytecodes::_ifeq:
    case Bytecodes::_ifne:
    case Bytecodes::_iflt:
    case Bytecodes::_ifge:
    case Bytecodes::_ifgt:
    case Bytecodes::_ifle:
      current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      target = bcs->dest();
      check_legal_target(target, code_length, code_data, bci, CHECK_0);
      stackmap_table->check_jump_target(current_frame, target, CHECK_0);
      return false;
    case Bytecodes::_if_acmpeq :
    case Bytecodes::_if_acmpne :
      current_frame->pop_stack(RefType::_reference_type, CHECK_0);
      // fall through 
    case Bytecodes::_ifnull :
    case Bytecodes::_ifnonnull :
      current_frame->pop_stack(RefType::_reference_type, CHECK_0);
      target = bcs->dest();
      check_legal_target(target, code_length, code_data, bci, CHECK_0);
      stackmap_table->check_jump_target(current_frame, target, CHECK_0);
      return false;
    case Bytecodes::_goto :
      target = bcs->dest();
      check_legal_target(target, code_length, code_data, bci, CHECK_0);
      stackmap_table->check_jump_target(current_frame, target, CHECK_0);
      return true;
    case Bytecodes::_goto_w :
      target = bcs->dest_w();
      check_legal_target(target, code_length, code_data, bci, CHECK_0);
      stackmap_table->check_jump_target(current_frame, target, CHECK_0);
      return true;
    case Bytecodes::_tableswitch :
    case Bytecodes::_lookupswitch : 
      verify_switch(bcs, code_length, code_data, current_frame, stackmap_table, CHECK_0);
      return true;
    case Bytecodes::_ireturn :
      type = current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      verify_return_value(return_type, type, bci, CHECK_0);
      return true;
    case Bytecodes::_lreturn :
      type2 = current_frame->pop_stack(VerificationType::_long2_type, CHECK_0);
      type = current_frame->pop_stack(VerificationType::_long_type, CHECK_0);
      verify_return_value(return_type, type, bci, CHECK_0);
      return true;
    case Bytecodes::_freturn :
      type = current_frame->pop_stack(VerificationType::_float_type, CHECK_0);
      verify_return_value(return_type, type, bci, CHECK_0);
      return true;
    case Bytecodes::_dreturn :
      type2 = current_frame->pop_stack(VerificationType::_double2_type,  CHECK_0);
      type = current_frame->pop_stack(VerificationType::_double_type, CHECK_0);
      verify_return_value(return_type, type, bci, CHECK_0);
      return true;
    case Bytecodes::_areturn :
      type = current_frame->pop_stack(RefType::_reference_type, CHECK_0);
      verify_return_value(return_type, type, bci, CHECK_0);
      return true;
    case Bytecodes::_return :
      if (return_type != NULL) {
        verify_error("Method expects no return value in method %s at offset %d",
                     _method, bci, CHECK_0);
      }
      // Make sure "this" has been initialized if current method is an <init>
      if (_method->name() == vmSymbols::object_initializer_name() && current_frame->flag_this_uninit()) {
        verify_error("Constructor %s must call super() or this() before return at offset %d",
                     _method, bci, CHECK_0);
      }
      return true;
    case Bytecodes::_getstatic :
    case Bytecodes::_putstatic :
    case Bytecodes::_getfield :
    case Bytecodes::_putfield :
      verify_field_instructions(bcs, current_frame, cp, CHECK_0);
      return false;
    case Bytecodes::_invokevirtual :
    case Bytecodes::_invokespecial :
    case Bytecodes::_invokestatic :
    case Bytecodes::_invokeinterface :
      verify_invoke_instructions(bcs, code_length, current_frame, this_uninit, return_type, 
                                 cp, CHECK_0);
      return false;
    case Bytecodes::_new : 
      {
        index = bcs->get_index_big();
        verify_cp_class_type(index, cp, CHECK_0);
        RefType* new_class_type = cp_index_to_type(index, cp, CHECK_0);
        if (!new_class_type->is_object()) {
          verify_error("Illegal new instruction in method %s at offset %d",
                       _method, bci, CHECK_0);
        }
        type = new UninitializedType(bci);
        current_frame->push_stack(type, CHECK_0);
        return false;
      }
    case Bytecodes::_newarray :
      type = get_newarray_type(bcs->get_index(), bci, CHECK_0);
      current_frame->pop_stack(VerificationType::_integer_type,  CHECK_0);
      current_frame->push_stack(type, CHECK_0);
      return false;
    case Bytecodes::_anewarray : {
      verify_anewarray(bcs->get_index_big(), cp, current_frame, CHECK_0);
      return false;
    }
    case Bytecodes::_arraylength :
      current_frame->pop_stack(RefType::_array_type, CHECK_0);
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    case Bytecodes::_checkcast : {
      index = bcs->get_index_big();
      verify_cp_class_type(index, cp, CHECK_0);
      current_frame->pop_stack(RefType::_reference_type, CHECK_0);
      RefType* klass_type = cp_index_to_type(index, cp, CHECK_0);
      current_frame->push_stack(klass_type, CHECK_0);
      return false;
    }
    case Bytecodes::_instanceof : {
      index = bcs->get_index_big();
      verify_cp_class_type(index, cp, CHECK_0);
      current_frame->pop_stack(RefType::_reference_type, CHECK_0);
      current_frame->push_stack(VerificationType::_integer_type, CHECK_0);
      return false;
    }
    case Bytecodes::_monitorenter :
    case Bytecodes::_monitorexit :
      current_frame->pop_stack(RefType::_reference_type, CHECK_0);
      return false;
    case Bytecodes::_multianewarray : {
      index = bcs->get_index_big();
      u2 dim = *(bcs->bcp()+3);
      verify_cp_class_type(index, cp, CHECK_0);
      RefType* new_array_type = cp_index_to_type(index, cp, CHECK_0);
      if (!new_array_type->is_array()) {
        verify_error("Illegal constant pool index in multianewarray instruction in method %s at offset %d",
                     _method, bci, CHECK_0); 
      }
      if (dim < 1 || ((ArrType*)new_array_type)->dimensions() < dim) {
        verify_error("Illegal dimension in multianewarray instruction in method %s at offset %d",
                     _method, bci, CHECK_0); 
      }
      for (int i = 0; i < dim; i++) {
        current_frame->pop_stack(VerificationType::_integer_type, CHECK_0);
      }
      current_frame->push_stack(new_array_type, CHECK_0);
      return false;
    }
    case Bytecodes::_athrow :
      current_frame->pop_stack(_throwable_class_type, CHECK_0);
      return true;
    default:
      // We only need to check the valid bytecodes in class file. 
      // And jsr and ret are not in the new class file format in JDK1.5.
      verify_error("Bad instruction in method %s at offset %d",
                   _method, bci, CHECK_0);
      return false;
  }  // end switch
}


klassOop ClassVerifier::load_cp_class(int index, constantPoolHandle cp, TRAPS) {
  RefType *t = cp_index_to_type(index, cp, CHECK_0);
  klassOop klass;
  if (t->is_object()) {
    klass = ((ObjType*)t)->klass();
    if (klass == NULL) {
      klass = cp->klass_at(index, CHECK_0);
      ((ObjType*)t)->set_klass(instanceKlassHandle(THREAD, klass));
    }
  } else {
    klass = cp->klass_at(index, CHECK_0);
  }
  return klass;    
}

klassOop ClassVerifier::load_class(symbolHandle name, TRAPS) {
  // Get current loader and protection domain first.
  klassOop current_klass = _current_class_type->klass();
  oop loader = instanceKlass::cast(current_klass)->class_loader();
  oop protection_domain = Klass::cast(current_klass)->protection_domain();

  return SystemDictionary::resolve_or_fail(name,
                                           Handle(THREAD, loader), 
                                           Handle(THREAD, protection_domain), 
                                           true, CHECK_0);
}

bool ClassVerifier::is_protected_access(instanceKlassHandle this_class,
                                        klassOop target_class, 
                                        symbolOop field_name,
                                        symbolOop field_sig,
                                        bool is_method) {
  No_Safepoint_Verifier nosafepoint;

  // If target class isn't a super class of this class, we don't worry about this case
  if (!this_class->is_subclass_of(target_class)) {
    return false;
  }
  // Check if the specified method or field is protected
  instanceKlass* target_instance = instanceKlass::cast(target_class);
  fieldDescriptor fd;
  if (is_method) {
    methodOop m = target_instance->uncached_lookup_method(field_name, field_sig);
    if (m != NULL && m->is_protected()) {
      if (!this_class->is_same_class_package(m->method_holder())) {
        return true;
      }
    }
  } else {
    klassOop member_klass = target_instance->find_field(field_name, field_sig, &fd);
    if(member_klass != NULL && fd.is_protected()) {
      if (!this_class->is_same_class_package(member_klass)) {
        return true;
      }
    }
  }
  return false;
}

void ClassVerifier::verify_ldc(int opcode, u2 index, StackMapFrame *current_frame, 
                               constantPoolHandle cp, u2 bci, TRAPS) {
  constantTag tag = cp->tag_at(index); 
  unsigned int types;
  if (opcode == Bytecodes::_ldc || opcode == Bytecodes::_ldc_w) {
    if (!tag.is_unresolved_string() && !tag.is_unresolved_klass()) {
      types = (1 << JVM_CONSTANT_Integer) | (1 << JVM_CONSTANT_Float) 
            | (1 << JVM_CONSTANT_String)  | (1 << JVM_CONSTANT_Class);
      verify_constant_pool_type(index, cp, types, CHECK);
    }
  } else {
    assert(opcode == Bytecodes::_ldc2_w, "must be ldc2_w");
    types = (1 << JVM_CONSTANT_Double) | (1 << JVM_CONSTANT_Long);
    verify_constant_pool_type(index, cp, types, CHECK);
  }
  if (tag.is_string() || tag.is_unresolved_string()) {
    current_frame->push_stack(_string_class_type, CHECK);
  } else if (tag.is_klass() || tag.is_unresolved_klass()) {
    RefType* class_type =
          _local_class_type_table->get_class_type_from_name(vmSymbols::java_lang_Class(), CHECK);
    current_frame->push_stack(class_type, CHECK);
  } else if (tag.is_int()) {
    current_frame->push_stack(VerificationType::_integer_type, CHECK);
  } else if (tag.is_float()) {
    current_frame->push_stack(VerificationType::_float_type, CHECK);
  } else if (tag.is_double()) {
    current_frame->push_stack(VerificationType::_double_type, CHECK);
    current_frame->push_stack(VerificationType::_double2_type, CHECK);
  } else if (tag.is_long()) {
    current_frame->push_stack(VerificationType::_long_type, CHECK);
    current_frame->push_stack(VerificationType::_long2_type, CHECK);
  } else {
    verify_error("Invalid index in ldc in method %s offset %d",
                  _method, bci, CHECK);
  }
}

void ClassVerifier::verify_switch(RawBytecodeStream* bcs, u4 code_length, int* code_data, 
                                  StackMapFrame* current_frame, 
                                  StackMapTable* stackmap_table, TRAPS) {
  u2 bci = bcs->bci();
  address bcp = bcs->bcp();
  address aligned_bcp = (address) round_to((intptr_t)(bcp + 1), jintSize);
        
  // 4639449 & 4647081: padding bytes must be 0
  u2 padding_offset = 1;
  while ((bcp + padding_offset) < aligned_bcp) {
    if(*(bcp + padding_offset) != 0) {
      verify_error("Nonzero padding byte in lookswitch or tableswitch in method %s at offset %d",
                    _method, bci, CHECK);
    }
    padding_offset++;
  }
  int default_offset = (int) Bytes::get_Java_u4(aligned_bcp);
  int keys, delta;
  current_frame->pop_stack(VerificationType::_integer_type, CHECK);
  if (bcs->code() == Bytecodes::_tableswitch) {
    jint low = (jint)Bytes::get_Java_u4(aligned_bcp + jintSize);
    jint high = (jint)Bytes::get_Java_u4(aligned_bcp + 2*jintSize);
    if (low > high) {
      verify_error("low must be less than or equal to high in tableswitch "
                   "in method %s at offset %d", _method, bci, CHECK);
    }
    keys = high - low + 1;  // an int must be enough to hold keys since
                            // otherwise generate_code_data will already
                            // have caught an illegal instruction length
    delta = 1;
  } else { 
    keys = (int)Bytes::get_Java_u4(aligned_bcp + jintSize);
    delta = 2;
    // Make sure that the lookupswitch items are sorted 
    for (int i = 0; i < (keys - 1); i++) {
      long this_key = Bytes::get_Java_u4(aligned_bcp + (2+2*i)*jintSize);
      long next_key = Bytes::get_Java_u4(aligned_bcp + (2+2*i+2)*jintSize);
      if (this_key >= next_key) { 
        verify_error("Bad lookupswitch instruction in method %s at offset %d",
                     _method, bci, CHECK);
      }
    }
  }
  u2 target = bci + default_offset;
  check_legal_target(target, code_length, code_data, bci, CHECK);
  stackmap_table->check_jump_target(current_frame, target, CHECK);
  for (int i = 0; i < keys; i++) {
    target = bci + Bytes::get_Java_u4(aligned_bcp+(3+i*delta)*jintSize);
    check_legal_target(target, code_length, code_data, bci, CHECK);
    stackmap_table->check_jump_target(current_frame, target, CHECK);
  }
}

void ClassVerifier::verify_field_instructions(RawBytecodeStream* bcs, 
                                              StackMapFrame* current_frame, 
                                              constantPoolHandle cp, 
                                              TRAPS) {
  u2 index = bcs->get_index_big();
  verify_constant_pool_type(index, cp, 1 << JVM_CONSTANT_Fieldref, CHECK);

  // Get referenced class type
  RefType* ref_class_type = cp_ref_index_to_type(index, cp, CHECK);
  if (!ref_class_type->is_object()) {
    ResourceMark rm(THREAD);
    Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_VerifyError(),
                       "Expecting reference to class in class %s at constant pool index %d",
                        _klass->external_name(), index, CHECK);
  }
  ObjType* target_class_type = (ObjType*)ref_class_type;

  // Get field name and signature
  symbolHandle field_name = symbolHandle(THREAD, cp->name_ref_at(index));
  symbolHandle field_sig = symbolHandle(THREAD, cp->signature_ref_at(index));

  VerificationType* field_type[2];
  SignatureStream sig_stream(field_sig, false);
  VerificationType* stack_object_type;
  int n = VerificationType::change_sig_to_verificationType(&sig_stream, field_type, this, CHECK);
  u2 bci = bcs->bci();
  bool is_assignable;
  switch (bcs->code()) {
    case Bytecodes::_getstatic: {
      for (int i = 0; i < n; i++) {
        current_frame->push_stack(field_type[i], CHECK);
      }
      break;
    }
    case Bytecodes::_putstatic: {
      for (int i = n - 1; i >= 0; i--) {
        current_frame->pop_stack(field_type[i], CHECK);
      }
      break;
    }
    case Bytecodes::_getfield: {
      stack_object_type = current_frame->pop_stack(target_class_type, CHECK);
      for (int i = 0; i < n; i++) {
        current_frame->push_stack(field_type[i], CHECK);
      }
      goto check_protected;
    }
    case Bytecodes::_putfield: {
      for (int i = n - 1; i >= 0; i--) {
        current_frame->pop_stack(field_type[i], CHECK);
      }
      stack_object_type = current_frame->pop_stack(CHECK);
  
      // The JVMS 2nd edition allows field initialization before the superclass initializer,
      // if the field is defined within the current class.
      fieldDescriptor fd;
      if (stack_object_type == VerificationType::_uninitialized_this && 
          _klass->find_local_field(field_name(), field_sig(), &fd)) {
        stack_object_type = _current_class_type;
      }
      is_assignable = target_class_type->is_assignable_from(stack_object_type, CHECK);
      if (!is_assignable) {
        verify_error("Bad type on operand stack in putfield in method %s at offset %d",
                     _method, bci, CHECK);
      }
    }
    check_protected: {
      klassOop ref_klass_oop = load_cp_ref_class(index, cp, CHECK);
      if (is_protected_access(_klass, ref_klass_oop, field_name(), field_sig(), false)) {
        // It's protected access, check if stack object is assignable to current class.
        is_assignable = _current_class_type->is_assignable_from(stack_object_type, CHECK);
        if (!is_assignable) {
          verify_error("Bad access to protected data in getfield in method %s at offset %d",
                        _method, bci, CHECK);
        }
      }
      break;
    }       
    default: ShouldNotReachHere();
  }
}

void ClassVerifier::verify_invoke_init(RawBytecodeStream* bcs, RefType* ref_class_type, StackMapFrame* current_frame, 
                                       u4 code_length, bool *this_uninit, constantPoolHandle cp, TRAPS) {
  u2 bci = bcs->bci();
  VerificationType* type = current_frame->pop_stack(RefType::_reference_type, CHECK);
  if (type == UninitializedType::_uninitialized_this) {
    // The method must be an <init> method of either this class, or one of its superclasses
    if (!ref_class_type->equals(_current_class_type) && !ref_class_type->equals(_super_class_type)) { 
      // see if it's in a super class
      instanceKlassHandle super_klass_h = instanceKlassHandle(THREAD,
          instanceKlass::cast(_super_class_type->klass())->super());
      while (super_klass_h.not_null()) {
        symbolHandle super_name(THREAD, super_klass_h->name());
        ObjType* super_type;
        if (super_name == vmSymbols::java_lang_Object()) {
          super_type = _object_class_type;
        } else {
          super_type = _local_class_type_table->get_object_type(super_name, super_klass_h, false, CHECK);
        }
        if (ref_class_type->equals(super_type)) {
          break;
        }
        super_klass_h = instanceKlassHandle(THREAD, super_klass_h->super());
      }
      if (super_klass_h.is_null()) {
        verify_error("Bad <init> method call in method %s at offset %d",
                      _method, bci, CHECK); 
      }
    }
    current_frame->initialize_object((UninitializedType*)type, _current_class_type);
    *this_uninit = true;
  } else if (type->tag() == ITEM_Uninitialized) {
    u2 new_offset = ((UninitializedType*)type)->offset();
    address new_bcp = bcs->bcp() - bci + new_offset;
    if (new_offset > (code_length - 3) || (*new_bcp) != Bytecodes::_new) {
      verify_error("Expecting new instruction in method %s at offset %d",
                    _method, new_offset, CHECK); 
    }
    u2 new_class_index = Bytes::get_Java_u2(new_bcp + 1);
    verify_cp_class_type(new_class_index, cp, CHECK);
 
    // The method must be an <init> method of the indicated class
    RefType* new_class_type = cp_index_to_type(new_class_index, cp, CHECK);
    if (!new_class_type->equals(ref_class_type)) {
      verify_error("Call to wrong <init> method in method %s at offset %d",
                    _method, bci, CHECK); 
    }
    current_frame->initialize_object((UninitializedType*)type, (ObjType*)new_class_type);
  } else {
    verify_error("Bad operand type when invoking <init> in method %s at offset %d",
                  _method, bci, CHECK); 
  }
}

void ClassVerifier::verify_invoke_instructions(RawBytecodeStream* bcs, u4 code_length, 
                                               StackMapFrame* current_frame, bool *this_uninit,
                                               VerificationType* return_type, constantPoolHandle cp, 
                                               TRAPS) {
  // Make sure the constant pool item is the right type
  u2 index = bcs->get_index_big();
  Bytecodes::Code opcode = bcs->code();
  unsigned int types = (opcode == Bytecodes::_invokeinterface
                                ? 1 << JVM_CONSTANT_InterfaceMethodref
                                : 1 << JVM_CONSTANT_Methodref);
  verify_constant_pool_type(index, cp, types, CHECK);

  // Get referenced class type
  RefType* ref_class_type = cp_ref_index_to_type(index, cp, CHECK);

  // Get method name and signature
  symbolHandle method_name(THREAD, cp->name_ref_at(index));
  symbolHandle method_sig(THREAD, cp->signature_ref_at(index));

  // Long and double occupies two slots here.
  ArgumentSizeComputer size_it(method_sig);
  int nargs = size_it.size();
  ResourceMark rm(THREAD);
  SignatureStream sig_stream(method_sig);
  VerificationType** sig_types = NEW_RESOURCE_ARRAY(VerificationType*, nargs);
  int sig_i = 0;
  while (!sig_stream.at_return_type()) {
    sig_i += VerificationType::change_sig_to_verificationType(&sig_stream, &sig_types[sig_i], this, CHECK);
    sig_stream.next();
  }
  assert(nargs == sig_i, "Argument sizes do not match");

  // Check instruction operands
  u2 bci = bcs->bci();
  if (opcode == Bytecodes::_invokeinterface) {
    address bcp = bcs->bcp();
    // 4905268: count operand in invokeinterface should be nargs+1, not nargs.
    // JSR202 spec: The count operand of an invokeinterface instruction is valid if it is
    // the difference between the size of the operand stack before and after the instruction
    // executes.
    if (*(bcp+3) != (nargs+1)) {
      verify_error("Inconsistent args count operand in invokeinterface in method %s at offset %d",
                   _method, bci, CHECK); 
    }
    if (*(bcp+4) != 0) {
      verify_error("Fourth operand byte of invokeinterface must be zero in method %s at offset %d",
                  _method, bci, CHECK); 
    }
  }
   
  if (method_name->byte_at(0) == '<') {
    // Make sure <init> can only be invoked by invokespecial
    if (opcode != Bytecodes::_invokespecial || method_name() != vmSymbols::object_initializer_name()) {
      verify_error("Illegal call to internal method in method %s offset %d",
                   _method, bci, CHECK);
    }
  } else if (opcode == Bytecodes::_invokespecial 
             && !ref_class_type->equals(_current_class_type)
             && !ref_class_type->equals(_super_class_type)) {
    // must be a method in current class or a super class
    if (_klass->uncached_lookup_method(method_name(), method_sig()) == NULL) {
      verify_error("Bad invokespecial instruction in method %s at offset %d",
                   _method, bci, CHECK);                   
    }
  }
  // Match method descriptor with operand stack           
  for (int i = nargs - 1; i >= 0; i--) {  // Run backwards
    current_frame->pop_stack(sig_types[i], CHECK);
  }
  // Check objectref on operand stack
  if (opcode != Bytecodes::_invokestatic) {
    if (method_name() == vmSymbols::object_initializer_name()) {  // <init> method
      verify_invoke_init(bcs, ref_class_type, current_frame, code_length, this_uninit, 
                         cp, CHECK);
    } else {   // other methods
      // Ensures that target class is assignable to method class. 
      if (opcode == Bytecodes::_invokespecial) { 
        current_frame->pop_stack(_current_class_type, CHECK);
      } else if(opcode == Bytecodes::_invokevirtual) {
        VerificationType* stack_object_type = current_frame->pop_stack(ref_class_type, CHECK);
        klassOop ref_class = load_cp_ref_class(index, cp, CHECK);
        if (is_protected_access(_klass, ref_class, method_name(), method_sig(), true)) {
          // It's protected access, check if stack object is assignable to current class.
          bool is_assignable = _current_class_type->is_assignable_from(stack_object_type, CHECK);
          if (!is_assignable) {
            if (ref_class_type->equals(_object_class_type) 
              && stack_object_type->is_array()
              && method_name() == vmSymbols::clone_name()) {
              // Special case: arrays pretend to implement public Object clone().
            } else {
              verify_error("Bad access to protected data in invokevirtual in method %s at offset %d",               
                           _method, bci, CHECK);
            }
          }
        }            
      } else { 
        assert(opcode == Bytecodes::_invokeinterface, "Unexpected opcode encountered");
        current_frame->pop_stack(ref_class_type, CHECK);
      }
    }
  }
  // Push the result type.
  if (sig_stream.type() != T_VOID) {
    if (method_name() == vmSymbols::object_initializer_name()) {
      // <init> method must have a void return type
      verify_error("Return type must be void in <init> method in method %s offset %d",
                    _method, bci, CHECK);                
    }      
    VerificationType* return_type[2];
    int n = VerificationType::change_sig_to_verificationType(&sig_stream, return_type, this, CHECK);
    for (int i = 0; i < n; i++) {
      current_frame->push_stack(return_type[i], CHECK); // push types backwards
    }
  }
}

VerificationType* ClassVerifier::get_newarray_type(u2 index, u2 bci, TRAPS) {
  int length = 2;
  ResourceMark rm(THREAD);
  char* arr_sig_str = NEW_RESOURCE_ARRAY(char, length);
  arr_sig_str[0] = '[';
  switch (index) {
    case T_BOOLEAN: {
      arr_sig_str[1] = 'Z';
      symbolHandle arr_sig = oopFactory::new_symbol_handle(arr_sig_str, length, CHECK_0);
      return _local_class_type_table->get_class_type_from_name(arr_sig, CHECK_0);
    }
    case T_CHAR: {
      arr_sig_str[1] = 'C';
      symbolHandle arr_sig = oopFactory::new_symbol_handle(arr_sig_str, length, CHECK_0);
      return _local_class_type_table->get_class_type_from_name(arr_sig, CHECK_0);
    }
    case T_FLOAT: {
      arr_sig_str[1] = 'F';
      symbolHandle arr_sig = oopFactory::new_symbol_handle(arr_sig_str, length, CHECK_0);
      return _local_class_type_table->get_class_type_from_name(arr_sig, CHECK_0);
    }
    case T_DOUBLE: {
      arr_sig_str[1] = 'D';
      symbolHandle arr_sig = oopFactory::new_symbol_handle(arr_sig_str, length, CHECK_0);
      return _local_class_type_table->get_class_type_from_name(arr_sig, CHECK_0);
    }
    case T_BYTE: {
      arr_sig_str[1] = 'B';
      symbolHandle arr_sig = oopFactory::new_symbol_handle(arr_sig_str, length, CHECK_0);
      return _local_class_type_table->get_class_type_from_name(arr_sig, CHECK_0);
    }
    case T_SHORT: {
      arr_sig_str[1] = 'S';
      symbolHandle arr_sig = oopFactory::new_symbol_handle(arr_sig_str, length, CHECK_0);
      return _local_class_type_table->get_class_type_from_name(arr_sig, CHECK_0);
    }
    case T_INT: {
      arr_sig_str[1] = 'I';
      symbolHandle arr_sig = oopFactory::new_symbol_handle(arr_sig_str, length, CHECK_0);
      return _local_class_type_table->get_class_type_from_name(arr_sig, CHECK_0);
    }
    case T_LONG: {
      arr_sig_str[1] = 'J';
      symbolHandle arr_sig = oopFactory::new_symbol_handle(arr_sig_str, length, CHECK_0);
      return _local_class_type_table->get_class_type_from_name(arr_sig, CHECK_0);
    }
    default:
      verify_error("Illegal newarray instruction in method %s at offset %d",
                   _method, bci, CHECK_0);
      ShouldNotReachHere();
      return NULL;
  }
}

void ClassVerifier::verify_anewarray(u2 index, constantPoolHandle cp, 
                                StackMapFrame* current_frame, TRAPS) {
  verify_cp_class_type(index, cp, CHECK);
  current_frame->pop_stack(VerificationType::_integer_type, CHECK);

  RefType* component_type = cp_index_to_type(index, cp, CHECK);
  ResourceMark rm(THREAD);
  int length;
  char* arr_sig_str;
  if (component_type->is_array()) {     // it's an array
    const char* component_name = ((ArrType*)component_type)->signature()->as_utf8();
    // add one dimension to component
    length = (int)strlen(component_name) + 1;
    arr_sig_str = NEW_RESOURCE_ARRAY(char, length);
    arr_sig_str[0] = '[';
    strncpy(&arr_sig_str[1], component_name, length - 1);
  } else {         // it's an object or interface
    const char* component_name = ((ObjType*)component_type)->name()->as_utf8();
    // add one dimension to component with 'L' prepended and ';' postpended.
    length = (int)strlen(component_name) + 3;
    arr_sig_str = NEW_RESOURCE_ARRAY(char, length);
    arr_sig_str[0] = '[';
    arr_sig_str[1] = 'L';
    strncpy(&arr_sig_str[2], component_name, length - 2); 
    arr_sig_str[length - 1] = ';';
  }
  symbolHandle arr_sig = oopFactory::new_symbol_handle(arr_sig_str, length, CHECK);
  RefType* new_array_type = _local_class_type_table->get_class_type_from_name(arr_sig, CHECK);
  current_frame->push_stack(new_array_type, CHECK);
}

void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
  current_frame->get_local(index, VerificationType::_integer_type, CHECK);
  current_frame->push_stack(VerificationType::_integer_type, CHECK);  
}

void ClassVerifier::verify_lload(u2 index, StackMapFrame* current_frame, TRAPS) {
  current_frame->get_local(index, VerificationType::_long_type, CHECK);
  current_frame->get_local(index + 1, VerificationType::_long2_type, CHECK);
  current_frame->push_stack(VerificationType::_long_type, CHECK);
  current_frame->push_stack(VerificationType::_long2_type, CHECK);
}

void ClassVerifier::verify_fload(u2 index, StackMapFrame* current_frame, TRAPS) {
  current_frame->get_local(index, VerificationType::_float_type, CHECK);
  current_frame->push_stack(VerificationType::_float_type, CHECK);  
}

void ClassVerifier::verify_dload(u2 index, StackMapFrame* current_frame, TRAPS) {
  current_frame->get_local(index, VerificationType::_double_type, CHECK);
  current_frame->get_local(index + 1, VerificationType::_double2_type, CHECK);
  current_frame->push_stack(VerificationType::_double_type, CHECK);
  current_frame->push_stack(VerificationType::_double2_type, CHECK);
}

void ClassVerifier::verify_aload(u2 index, StackMapFrame* current_frame, TRAPS) {
  VerificationType* type = current_frame->get_local(index, VerificationType::_reference_type, 
                                                    CHECK);
  current_frame->push_stack(type, CHECK);
}

void ClassVerifier::verify_istore(u2 index, StackMapFrame* current_frame, TRAPS) {
  current_frame->pop_stack(VerificationType::_integer_type, CHECK);
  current_frame->set_local(index, VerificationType::_integer_type, CHECK);
}

void ClassVerifier::verify_lstore(u2 index, StackMapFrame* current_frame, TRAPS) {
  current_frame->pop_stack(VerificationType::_long2_type, CHECK);
  current_frame->pop_stack(VerificationType::_long_type, CHECK);
  current_frame->set_local(index, VerificationType::_long_type, CHECK);
  current_frame->set_local(index + 1, VerificationType::_long2_type, CHECK);
}

void ClassVerifier::verify_fstore(u2 index, StackMapFrame* current_frame, TRAPS) {
  current_frame->pop_stack(VerificationType::_float_type, CHECK);
  current_frame->set_local(index, VerificationType::_float_type, CHECK);
}

void ClassVerifier::verify_dstore(u2 index, StackMapFrame* current_frame, TRAPS) {
  current_frame->pop_stack(VerificationType::_double2_type, CHECK);
  current_frame->pop_stack(VerificationType::_double_type, CHECK);
  current_frame->set_local(index, VerificationType::_double_type, CHECK);
  current_frame->set_local(index + 1, VerificationType::_double2_type, CHECK);
}

void ClassVerifier::verify_astore(u2 index, StackMapFrame* current_frame, TRAPS) {
  VerificationType* type = current_frame->pop_stack(RefType::_reference_type, CHECK);
  current_frame->set_local(index, type, CHECK);
}

void ClassVerifier::verify_iinc(u2 index, StackMapFrame* current_frame, TRAPS) {
  VerificationType* type = current_frame->get_local(index, VerificationType::_integer_type, CHECK);
  current_frame->set_local(index, type, CHECK);
}

void ClassVerifier::verify_return_value(VerificationType* return_type, VerificationType* type, u2 bci, TRAPS) {
  if (return_type == NULL) {
    verify_error("Method expects a return value in method %s at offset %d",
                  _method, bci, CHECK);
  }
  bool match = return_type->is_assignable_from(type, CHECK);
  if (!match) {
    verify_error("Bad return type in method %s at offset %d",
                 _method, bci, CHECK);
  }
}
 
