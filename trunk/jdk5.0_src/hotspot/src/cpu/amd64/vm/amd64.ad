// @(#)amd64.ad	1.21 04/07/29 16:35:58 JVM
//
// Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
// SUN PROPRIETARY/CONFIDENTIAL.  Use is subject to license terms.
//

// AMD64 Architecture Description File

//----------REGISTER DEFINITION BLOCK------------------------------------------
// This information is used by the matcher and the register allocator to
// describe individual registers and classes of registers within the target
// archtecture.

register %{
//----------Architecture Description Register Definitions----------------------
// General Registers
// "reg_def"  name ( register save type, C convention save type, 
//                   ideal register type, encoding );
// Register Save Types:
// 
// NS  = No-Save:       The register allocator assumes that these registers
//                      can be used without saving upon entry to the method, &
//                      that they do not need to be saved at call sites.
// 
// SOC = Save-On-Call:  The register allocator assumes that these registers
//                      can be used without saving upon entry to the method,
//                      but that they must be saved at call sites.
// 
// SOE = Save-On-Entry: The register allocator assumes that these registers
//                      must be saved before using them upon entry to the
//                      method, but they do not need to be saved at call
//                      sites.
// 
// AS  = Always-Save:   The register allocator assumes that these registers
//                      must be saved before using them upon entry to the
//                      method, & that they must be saved at call sites.
//
// Ideal Register Type is used to determine how to save & restore a 
// register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
// spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
// 
// The encoding number is the actual bit-pattern placed into the opcodes.

// General Registers
// R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
// used as byte registers)

// Previously set RBX, RSI, and RDI as save-on-entry for java code
// Turn off SOE in java-code due to frequent use of uncommon-traps.
// Now that allocator is better, turn on RSI and RDI as SOE registers.
// Leave RBP as save-on-entry to ensure that it is saved in I2CAdapter.

reg_def RAX  (SOC, SOC, Op_RegI,  0);
reg_def RAX_H(SOC, SOC, Op_RegI,  0);

reg_def RCX  (SOC, SOC, Op_RegI,  1);
reg_def RCX_H(SOC, SOC, Op_RegI,  1);

reg_def RDX  (SOC, SOC, Op_RegI,  2);
reg_def RDX_H(SOC, SOC, Op_RegI,  2);

reg_def RBX  (SOC, SOE, Op_RegI,  3);
reg_def RBX_H(SOC, SOE, Op_RegI,  3);

reg_def RSP  (NS,  NS,  Op_RegI,  4);
reg_def RSP_H(NS,  NS,  Op_RegI,  4);

reg_def RBP  (SOE, SOE, Op_RegI,  5);
reg_def RBP_H(SOE, SOE, Op_RegI,  5);

#ifdef _WIN64

reg_def RSI  (SOC, SOE, Op_RegI,  6);
reg_def RSI_H(SOC, SOE, Op_RegI,  6);

reg_def RDI  (SOC, SOE, Op_RegI,  7);
reg_def RDI_H(SOC, SOE, Op_RegI,  7);

#else

reg_def RSI  (SOC, SOC, Op_RegI,  6);
reg_def RSI_H(SOC, SOC, Op_RegI,  6);

reg_def RDI  (SOC, SOC, Op_RegI,  7);
reg_def RDI_H(SOC, SOC, Op_RegI,  7);

#endif

reg_def R8   (SOC, SOC, Op_RegI,  8);
reg_def R8_H (SOC, SOC, Op_RegI,  8);

reg_def R9   (SOC, SOC, Op_RegI,  9);
reg_def R9_H (SOC, SOC, Op_RegI,  9);

reg_def R10  (SOC, SOC, Op_RegI, 10);
reg_def R10_H(SOC, SOC, Op_RegI, 10);

reg_def R11  (SOC, SOC, Op_RegI, 11);
reg_def R11_H(SOC, SOC, Op_RegI, 11);

reg_def R12  (SOC, SOE, Op_RegI, 12);
reg_def R12_H(SOC, SOE, Op_RegI, 12);

reg_def R13  (SOE, SOE, Op_RegI, 13);
reg_def R13_H(SOE, SOE, Op_RegI, 13);

reg_def R14  (SOE, SOE, Op_RegI, 14);
reg_def R14_H(SOE, SOE, Op_RegI, 14);

reg_def R15  (SOC, SOE, Op_RegI, 15);
reg_def R15_H(SOC, SOE, Op_RegI, 15);


// Floating Point Registers

// XMM registers.  128-bit registers or 4 words each, labeled (a)-d.
// Word a in each register holds a Float, words ab hold a Double.  We
// currently do not use the SIMD capabilities, so registers cd are
// unused at the moment.
// XMM8-XMM15 must be encoded with REX.
// Linux ABI:   No register preserved across function calls
//              XMM0-XMM7 might hold parameters
// Windows ABI: XMM8-XMM15 preserved across function calls
//              XMM0-XMM7 might hold parameters

reg_def XMM0   (SOC, SOC, Op_RegF,  0);
reg_def XMM0_H (SOC, SOC, Op_RegF,  0);

reg_def XMM1   (SOC, SOC, Op_RegF,  1);
reg_def XMM1_H (SOC, SOC, Op_RegF,  1);

reg_def XMM2   (SOC, SOC, Op_RegF,  2);
reg_def XMM2_H (SOC, SOC, Op_RegF,  2);

reg_def XMM3   (SOC, SOC, Op_RegF,  3);
reg_def XMM3_H (SOC, SOC, Op_RegF,  3);

reg_def XMM4   (SOC, SOC, Op_RegF,  4);
reg_def XMM4_H (SOC, SOC, Op_RegF,  4);

reg_def XMM5   (SOC, SOC, Op_RegF,  5);
reg_def XMM5_H (SOC, SOC, Op_RegF,  5);

reg_def XMM6   (SOC, SOC, Op_RegF,  6);
reg_def XMM6_H (SOC, SOC, Op_RegF,  6);

reg_def XMM7   (SOC, SOC, Op_RegF,  7);
reg_def XMM7_H (SOC, SOC, Op_RegF,  7);

#ifdef _WIN64

reg_def XMM8   (SOC, SOE, Op_RegF,  8);
reg_def XMM8_H (SOC, SOE, Op_RegF,  8);

reg_def XMM9   (SOC, SOE, Op_RegF,  9);
reg_def XMM9_H (SOC, SOE, Op_RegF,  9);

reg_def XMM10  (SOC, SOE, Op_RegF, 10);
reg_def XMM10_H(SOC, SOE, Op_RegF, 10);

reg_def XMM11  (SOC, SOE, Op_RegF, 11);
reg_def XMM11_H(SOC, SOE, Op_RegF, 11);

reg_def XMM12  (SOC, SOE, Op_RegF, 12);
reg_def XMM12_H(SOC, SOE, Op_RegF, 12);

reg_def XMM13  (SOC, SOE, Op_RegF, 13);
reg_def XMM13_H(SOC, SOE, Op_RegF, 13);

reg_def XMM14  (SOC, SOE, Op_RegF, 14);
reg_def XMM14_H(SOC, SOE, Op_RegF, 14);

reg_def XMM15  (SOC, SOE, Op_RegF, 15);
reg_def XMM15_H(SOC, SOE, Op_RegF, 15);

#else

reg_def XMM8   (SOC, SOC, Op_RegF,  8);
reg_def XMM8_H (SOC, SOC, Op_RegF,  8);

reg_def XMM9   (SOC, SOC, Op_RegF,  9);
reg_def XMM9_H (SOC, SOC, Op_RegF,  9);

reg_def XMM10  (SOC, SOC, Op_RegF, 10);
reg_def XMM10_H(SOC, SOC, Op_RegF, 10);

reg_def XMM11  (SOC, SOC, Op_RegF, 11);
reg_def XMM11_H(SOC, SOC, Op_RegF, 11);

reg_def XMM12  (SOC, SOC, Op_RegF, 12);
reg_def XMM12_H(SOC, SOC, Op_RegF, 12);

reg_def XMM13  (SOC, SOC, Op_RegF, 13);
reg_def XMM13_H(SOC, SOC, Op_RegF, 13);

reg_def XMM14  (SOC, SOC, Op_RegF, 14);
reg_def XMM14_H(SOC, SOC, Op_RegF, 14);

reg_def XMM15  (SOC, SOC, Op_RegF, 15);
reg_def XMM15_H(SOC, SOC, Op_RegF, 15);

#endif // _WIN64

reg_def RFLAGS(SOC, SOC, 0, 16);

// Specify priority of register selection within phases of register 
// allocation.  Highest priority is first.  A useful heuristic is to 
// give registers a low priority when they are required by machine 
// instructions, like EAX and EDX on I486, and choose no-save registers
// before save-on-call, & save-on-call before save-on-entry.  Registers
// which participate in fixed calling sequences should come last.
// Registers which are used as pairs must fall on an even boundary.

alloc_class chunk0(R10,         R10_H,
                   R11,         R11_H,
                   R8,          R8_H,
                   R9,          R9_H,
                   R12,         R12_H,
                   RCX,         RCX_H,
                   RBX,         RBX_H,
                   RDI,         RDI_H,
                   RDX,         RDX_H,
                   RSI,         RSI_H,
                   RAX,         RAX_H,
                   RBP,         RBP_H,
                   R13,         R13_H,
                   R14,         R14_H,
                   R15,         R15_H,
                   RSP,         RSP_H);

// XXX probably use 8-15 first on Linux
alloc_class chunk1(XMM0,  XMM0_H, 
                   XMM1,  XMM1_H, 
                   XMM2,  XMM2_H, 
                   XMM3,  XMM3_H, 
                   XMM4,  XMM4_H, 
                   XMM5,  XMM5_H, 
                   XMM6,  XMM6_H, 
                   XMM7,  XMM7_H, 
                   XMM8,  XMM8_H, 
                   XMM9,  XMM9_H, 
                   XMM10, XMM10_H,
                   XMM11, XMM11_H,
                   XMM12, XMM12_H,
                   XMM13, XMM13_H,
                   XMM14, XMM14_H,
                   XMM15, XMM15_H);

alloc_class chunk2(RFLAGS);


//----------Architecture Description Register Classes--------------------------
// Several register classes are automatically defined based upon information in
// this architecture description.
// 1) reg_class inline_cache_reg           ( /* as def'd in frame section */ )
// 2) reg_class compiler_method_oop_reg    ( /* as def'd in frame section */ )
// 2) reg_class interpreter_method_oop_reg ( /* as def'd in frame section */ )
// 3) reg_class stack_slots( /* one chunk of stack-based "registers" */ )
// 

// Class for all pointer registers (including RSP)
reg_class any_reg(RAX, RAX_H,
                  RDX, RDX_H,
                  RBP, RBP_H,
                  RDI, RDI_H,
                  RSI, RSI_H,
                  RCX, RCX_H,
                  RBX, RBX_H,
                  RSP, RSP_H,
                  R8,  R8_H,
                  R9,  R9_H,
                  R10, R10_H,
                  R11, R11_H,
                  R12, R12_H,
                  R13, R13_H,
                  R14, R14_H,
                  R15, R15_H);

// Class for all pointer registers except RSP
reg_class ptr_reg(RAX, RAX_H,
                  RDX, RDX_H,
                  RBP, RBP_H,
                  RDI, RDI_H,
                  RSI, RSI_H,
                  RCX, RCX_H,
                  RBX, RBX_H,
                  R8,  R8_H,
                  R9,  R9_H,
                  R10, R10_H,
                  R11, R11_H,
                  R12, R12_H,
                  R13, R13_H,
                  R14, R14_H);

// Class for all pointer registers except RAX and RSP
reg_class ptr_no_rax_reg(RDX, RDX_H,
                         RBP, RBP_H,
                         RDI, RDI_H,
                         RSI, RSI_H,
                         RCX, RCX_H,
                         RBX, RBX_H,
                         R8,  R8_H,
                         R9,  R9_H,
                         R10, R10_H,
                         R11, R11_H,
                         R12, R12_H,
                         R13, R13_H,
                         R14, R14_H);

// Class for all pointer registers except RAX, RBX and RSP
reg_class ptr_no_rax_rbx_reg(RDX, RDX_H,
                             RBP, RBP_H,
                             RDI, RDI_H,
                             RSI, RSI_H,
                             RCX, RCX_H,
                             R8,  R8_H,
                             R9,  R9_H,
                             R10, R10_H,
                             R11, R11_H,
                             R12, R12_H,
                             R13, R13_H,
                             R14, R14_H);
 
// Singleton class for RAX pointer register
reg_class ptr_rax_reg(RAX, RAX_H);

// Singleton class for RBX pointer register
reg_class ptr_rbx_reg(RBX, RBX_H);

// Singleton class for RSI pointer register
reg_class ptr_rsi_reg(RSI, RSI_H);

// Singleton class for RDI pointer register
reg_class ptr_rdi_reg(RDI, RDI_H);

// Singleton class for RBP pointer register
reg_class ptr_rbp_reg(RBP, RBP_H);

// Singleton class for stack pointer
reg_class ptr_rsp_reg(RSP, RSP_H);

// Class for all long registers (except RSP)
reg_class long_reg(RAX, RAX_H,
                   RDX, RDX_H,
                   RBP, RBP_H,
                   RDI, RDI_H,
                   RSI, RSI_H,
                   RCX, RCX_H,
                   RBX, RBX_H,
                   R8,  R8_H,
                   R9,  R9_H,
                   R10, R10_H,
                   R11, R11_H,
                   R12, R12_H,
                   R13, R13_H,
                   R14, R14_H);

// Class for all long registers except RAX, RDX (and RSP)
reg_class long_no_rax_rdx_reg(RBP, RBP_H,
                              RDI, RDI_H,
                              RSI, RSI_H,
                              RCX, RCX_H,
                              RBX, RBX_H,
                              R8,  R8_H,
                              R9,  R9_H,
                              R10, R10_H,
                              R11, R11_H,
                              R12, R12_H,
                              R13, R13_H,
                              R14, R14_H);

// Class for all long registers except RAX (and RSP)
reg_class long_no_rax_reg(RBP, RBP_H,
                          RDX, RDX_H,
                          RDI, RDI_H,
                          RSI, RSI_H,
                          RCX, RCX_H,
                          RBX, RBX_H,
                          R8,  R8_H,
                          R9,  R9_H,
                          R10, R10_H,
                          R11, R11_H,
                          R12, R12_H,
                          R13, R13_H,
                          R14, R14_H);

// Singleton class for RAX long register
reg_class long_rax_reg(RAX, RAX_H);

// Singleton class for RDX long register
reg_class long_rdx_reg(RDX, RDX_H);

// Class for all int registers (except RSP)
reg_class int_reg(RAX,
                  RDX,
                  RBP,
                  RDI,
                  RSI,
                  RCX,
                  RBX,
                  R8,
                  R9,
                  R10,
                  R11,
                  R12,
                  R13,
                  R14);

// Class for all int registers except RCX (and RSP)
reg_class int_no_rcx_reg(RAX,
                         RDX,
                         RBP,
                         RDI,
                         RSI,
                         RBX,
                         R8,
                         R9,
                         R10,
                         R11,
                         R12,
                         R13,
                         R14);

// Class for all int registers except RAX, RDX (and RSP)
reg_class int_no_rax_rdx_reg(RBP,
                             RDI
                             RSI,
                             RCX,
                             RBX,
                             R8,
                             R9,
                             R10,
                             R11,
                             R12,
                             R13,
                             R14);

// Singleton class for RAX int register
reg_class int_rax_reg(RAX);

// Singleton class for RBX int register
reg_class int_rbx_reg(RBX);

// Singleton class for RCX int register
reg_class int_rcx_reg(RCX);

// Singleton class for RCX int register
reg_class int_rdx_reg(RDX);

// Singleton class for RCX int register
reg_class int_rdi_reg(RDI);

// Singleton class for instruction pointer
// reg_class ip_reg(RIP);

// Singleton class for condition codes
reg_class int_flags(RFLAGS);

// Class for all float registers
reg_class float_reg(XMM0,
                    XMM1,
                    XMM2,
                    XMM3,
                    XMM4,
                    XMM5,
                    XMM6,
                    XMM7,
                    XMM8,
                    XMM9,
                    XMM10,
                    XMM11,
                    XMM12,
                    XMM13,
                    XMM14,
                    XMM15);

// Class for all double registers
reg_class double_reg(XMM0,  XMM0_H,
                     XMM1,  XMM1_H,
                     XMM2,  XMM2_H,
                     XMM3,  XMM3_H,
                     XMM4,  XMM4_H,
                     XMM5,  XMM5_H,
                     XMM6,  XMM6_H,
                     XMM7,  XMM7_H,
                     XMM8,  XMM8_H,
                     XMM9,  XMM9_H,
                     XMM10, XMM10_H,
                     XMM11, XMM11_H,
                     XMM12, XMM12_H,
                     XMM13, XMM13_H,
                     XMM14, XMM14_H,
                     XMM15, XMM15_H);
%}


//----------SOURCE BLOCK-------------------------------------------------------
// This is a block of C++ code which provides values, functions, and
// definitions necessary in the rest of the architecture description
source %{
// ****************************************************************************
// temporary fix to generate new relocation info
#define   RELOC_IMM64    0
#define   RELOC_DISP32   1
// ****************************************************************************

// !!!!! Special hack to get all types of calls to specify the byte offset
//       from the start of the call to the point where the return address
//       will point.
int MachCallStaticJavaNode::ret_addr_offset()
{
  return 5; // 5 bytes from start of call to where return address points
}

int MachCallDynamicJavaNode::ret_addr_offset()
{
  return 15; // 15 bytes from start of call to where return address points
}

// In os_cpu .ad file
// int MachCallRuntimeNode::ret_addr_offset()

int MachCallCompiledJavaNode::ret_addr_offset()
{
  int disp = in_bytes(methodOopDesc::
                      from_compiled_code_entry_point_offset());
  // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
  return disp < 0x80 ? 3 : 6; // 3 or 6 bytes from start of call to
                              // where return address points
}

int MachCallInterpreterNode::ret_addr_offset()
{
  return 7; // 5 for call + 2 bytes for xor rbp,rbp
}

int MachCallNativeNode::ret_addr_offset()
{
  return MachCallRuntimeNode::ret_addr_offset();
}

// Indicate if the safepoint node needs the polling page as an input.
// Since amd64 does not have absolute addressing but RIP-relative
// addressing and the polling page is within 2G, it doesn't.
bool SafePointNode::needs_polling_address_input()
{
  return false;
}

//
// Compute padding required for nodes which need alignment
//

// The address of the call instruction needs to be 4-byte aligned to
// ensure that it does not span a cache line so that it can be patched.
int CallStaticJavaDirectNode::compute_padding(int current_offset) const
{
  current_offset += 1; // skip call opcode byte
  return round_to(current_offset, alignment_required()) - current_offset;
}

// The address of the call instruction needs to be 4-byte aligned to
// ensure that it does not span a cache line so that it can be patched.
int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
{
  current_offset += 11; // skip movq instruction + call opcode byte
  return round_to(current_offset, alignment_required()) - current_offset;
}

// The address of the call instruction needs to be 4-byte aligned to
// ensure that it does not span a cache line so that it can be patched.
int CallInterpreterDirectNode::compute_padding(int current_offset) const
{
  current_offset += 3; // skip xorl instruction + call opcode byte
  return round_to(current_offset, alignment_required()) - current_offset;
}


#ifndef PRODUCT
void MachBreakpointNode::format(PhaseRegAlloc*) const
{
  tty->print("INT3");
}
#endif

// EMIT_RM()
void emit_rm(CodeBuffer &cbuf, int f1, int f2, int f3)
{
  unsigned char c = (unsigned char) ((f1 << 6) | (f2 << 3) | f3);
  *(cbuf.code_end()) = c;
  cbuf.set_code_end(cbuf.code_end() + 1);
}

// EMIT_CC()
void emit_cc(CodeBuffer &cbuf, int f1, int f2)
{
  unsigned char c = (unsigned char) (f1 | f2);
  *(cbuf.code_end()) = c;
  cbuf.set_code_end(cbuf.code_end() + 1);
}

// EMIT_OPCODE()
void emit_opcode(CodeBuffer &cbuf, int code)
{
  *(cbuf.code_end()) = (unsigned char) code;
  cbuf.set_code_end(cbuf.code_end() + 1);
}

// EMIT_OPCODE() w/ relocation information
void emit_opcode(CodeBuffer &cbuf, 
                 int code, relocInfo::relocType reloc, int offset, int format)
{
  cbuf.relocate(cbuf.mark() + offset, reloc, format);
  emit_opcode(cbuf, code);    
}

// EMIT_D8()
void emit_d8(CodeBuffer &cbuf, int d8)
{
  *(cbuf.code_end()) = (unsigned char) d8;
  cbuf.set_code_end(cbuf.code_end() + 1);
}

// EMIT_D16()
void emit_d16(CodeBuffer &cbuf, int d16)
{
  *((short *)(cbuf.code_end())) = d16;
  cbuf.set_code_end(cbuf.code_end() + 2);
}

// EMIT_D32()
void emit_d32(CodeBuffer &cbuf, int d32)
{
  *((int *)(cbuf.code_end())) = d32;
  cbuf.set_code_end(cbuf.code_end() + 4);
}

// EMIT_D64()
void emit_d64(CodeBuffer &cbuf, int64_t d64)
{
  *((int64_t*) (cbuf.code_end())) = d64;
  cbuf.set_code_end(cbuf.code_end() + 8);
}

// emit 32 bit value and construct relocation entry from relocInfo::relocType
void emit_d32_reloc(CodeBuffer& cbuf, 
                    int d32, 
                    relocInfo::relocType reloc,
                    int format)
{
  cbuf.relocate(cbuf.mark(), reloc, format);

  *((int*) (cbuf.code_end())) = d32;
  cbuf.set_code_end(cbuf.code_end() + 4);
}

// emit 32 bit value and construct relocation entry from RelocationHolder
void emit_d32_reloc(CodeBuffer& cbuf, 
                    int d32, 
                    RelocationHolder const& rspec,
                    int format)
{
#ifdef ASSERT
  if (rspec.reloc()->type() == relocInfo::oop_type && 
      d32 != 0 && d32 != (int) Universe::non_oop_word()) {
    assert(oop(d32)->is_oop() && oop(d32)->is_perm(), "cannot embed non-perm oops in code");
  }
#endif
  cbuf.relocate(cbuf.mark(), rspec, format);

  *((int* )(cbuf.code_end())) = d32;
  cbuf.set_code_end(cbuf.code_end() + 4);
}

// emit 64 bit value and construct relocation entry from relocInfo::relocType
void emit_d64_reloc(CodeBuffer& cbuf, 
                    int64_t d64,
                    relocInfo::relocType reloc,
                    int format)
{
  cbuf.relocate(cbuf.mark(), reloc, format);

  *((int64_t*) (cbuf.code_end())) = d64;
  cbuf.set_code_end(cbuf.code_end() + 8);
}

// emit 64 bit value and construct relocation entry from RelocationHolder
void emit_d64_reloc(CodeBuffer& cbuf, 
                    int64_t d64,
                    RelocationHolder const& rspec,
                    int format)
{
#ifdef ASSERT
  if (rspec.reloc()->type() == relocInfo::oop_type && 
      d64 != 0 && d64 != (int64_t) Universe::non_oop_word()) {
    assert(oop(d64)->is_oop() && oop(d64)->is_perm(),
           "cannot embed non-perm oops in code");
  }
#endif
  cbuf.relocate(cbuf.mark(), rspec, format);

  *((int64_t*) (cbuf.code_end())) = d64;
  cbuf.set_code_end(cbuf.code_end() + 8);
}

// Access stack slot for load or store
void store_to_stackslot(CodeBuffer &cbuf, int opcode, int rm_field, int disp)
{
  emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  if (-0x80 <= disp && disp < 0x80) {
    emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
    emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
    emit_d8(cbuf, disp);     // Displacement  // R/M byte
  } else {
    emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
    emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
    emit_d32(cbuf, disp);     // Displacement // R/M byte
  }
}

   // rRegI ereg, memory mem) %{    // emit_reg_mem
void encode_RegMem(CodeBuffer &cbuf, 
                   int reg, 
                   int base, int index, int scale, int disp, bool disp_is_oop) 
{
  assert(!disp_is_oop, "cannot have disp");
  int regenc = reg & 7;
  int baseenc = base & 7;
  int indexenc = index & 7;

  // There is no index & no scale, use form without SIB byte
  if (index == 0x4 && scale == 0 && base != RSP_enc && base != R12_enc) {
    // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
    if (disp == 0 && base != RBP_enc && base != R13_enc) { 
      emit_rm(cbuf, 0x0, regenc, baseenc); // *
    } else if (-0x80 <= disp && disp < 0x80 && !disp_is_oop) {
      // If 8-bit displacement, mode 0x1
      emit_rm(cbuf, 0x1, regenc, baseenc); // *
      emit_d8(cbuf, disp);
    } else { 
      // If 32-bit displacement
      if (base == -1) { // Special flag for absolute address
        emit_rm(cbuf, 0x0, regenc, 0x5); // *
        if (disp_is_oop) {
          emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
        } else {
          emit_d32(cbuf, disp);
        }
      } else {
        // Normal base + offset
        emit_rm(cbuf, 0x2, regenc, baseenc); // *
        if (disp_is_oop) {
          emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
        } else {
          emit_d32(cbuf, disp);
        }
      }
    }
  } else { 
    // Else, encode with the SIB byte
    // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
    if (disp == 0 && base != RBP_enc && base != R13_enc) {
      // If no displacement
      emit_rm(cbuf, 0x0, regenc, 0x4); // *
      emit_rm(cbuf, scale, indexenc, baseenc);
    } else {
      if (-0x80 <= disp && disp < 0x80 && !disp_is_oop) {
        // If 8-bit displacement, mode 0x1
        emit_rm(cbuf, 0x1, regenc, 0x4); // *
        emit_rm(cbuf, scale, indexenc, baseenc);
        emit_d8(cbuf, disp);
      } else {
        // If 32-bit displacement
        if (base == 0x04 ) {
          emit_rm(cbuf, 0x2, regenc, 0x4);
          emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
        } else {
          emit_rm(cbuf, 0x2, regenc, 0x4);
          emit_rm(cbuf, scale, indexenc, baseenc); // *
        }
        if (disp_is_oop) {
          emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
        } else {
          emit_d32(cbuf, disp);
        }
      }
    }
  }
}

void encode_copy(CodeBuffer &cbuf, int dstenc, int srcenc) 
{
  if (dstenc != srcenc) {
    if (dstenc < 8) {
      if (srcenc >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
        srcenc -= 8;
      }
    } else {
      if (srcenc < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
        srcenc -= 8;
      }
      dstenc -= 8;
    }
    
    emit_opcode(cbuf, 0x8B);
    emit_rm(cbuf, 0x3, dstenc, srcenc);
  }
}


//=============================================================================
#ifndef PRODUCT
void MachPrologNode::format(PhaseRegAlloc* ra_) const
{
  Compile* C = ra_->C;

  int framesize = C->frame_slots() << LogBytesPerInt;
  framesize -= wordSize; // Remove 2 for return adr already pushed
  assert(framesize % (2 * wordSize) == wordSize, "aligned frame size");
  bool need_nop = true;

  if (VerifyStackAtCalls) {
    // Majik cookie to verify stack depth
    tty->print_cr("pushq   0xffffffffbadb100d"
                  "\t# Majik cookie for stack depth check");
    tty->print("\t"); 
    framesize -= wordSize; // Remove 2 for cookie
    need_nop = false;
  }

  // Calls to C2R adapters often do not accept exceptional returns.
  // We require that their callers must bang for them.  But be
  // careful, because some VM calls (such as call site linkage) can
  // use several kilobytes of stack.  But the stack safety zone should
  // account for that.  See bugs 4446381, 4468289, 4497237.
  if (C->need_stack_bang(framesize)) {
    tty->print_cr("# stack bang"); tty->print("\t"); 
    need_nop = false;
  }

  if (C->start()->Opcode() == Op_StartI2C) {
    tty->print("movq    rbx, rsp\t# move old rsp to temp\n\t");


    if (VerifyStackAtCalls) {
      tty->print("addq    rbx, #8\t# Adjust for majik cookie\n\t");
    }
    tty->print("andq    rsp, #-16\t# Round rsp to even\n\t"
               "pushq   rbx\t# Old rsp for EVEN alignment\n\t");

    need_nop = false;
  } else if (C->start()->Opcode() == Op_StartOSR) {
    tty->print("movq    rbx, r14\t"
               "# Move locals ptr to interpreter_arg_ptr_reg\n\t");
    need_nop = false;
  }

  if (framesize) {
    tty->print("subq    rsp, #%d\t# Create frame", framesize);
    if (framesize < 0x80 && need_nop) {
      tty->print("\n\tnop\t# nop for patch_verified_entry");
    }
  }
}
#endif

void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const
{
  Compile* C = ra_->C;

  // WARNING: Initial instruction MUST be 5 bytes or longer so that
  // NativeJump::patch_verified_entry will be able to patch out the entry
  // code safely. The fldcw is ok at 6 bytes, the push to verify stack
  // depth is ok at 5 bytes, the frame allocation can be either 3 or
  // 6 bytes. So if we don't do the fldcw or the push then we must
  // use the 6 byte frame allocation even if we have no frame. :-(
  // If method sets FPU control word do it now

  int framesize = C->frame_slots() << LogBytesPerInt;
  framesize -= wordSize; // Remove 2 for return adr already pushed
  assert(framesize % (2 * wordSize) == wordSize, "aligned frame size");
  bool need_nop = true;

  if (VerifyStackAtCalls) { 
    // Majik cookie to verify stack depth
    emit_opcode(cbuf, 0x68); // pushq (sign-extended) 0xbadb100d
    emit_d32(cbuf, 0xbadb100d);
    framesize -= wordSize; // Remove 2 for cookie
    need_nop = false;
  }

  // Calls to C2R adapters often do not accept exceptional returns.
  // We require that their callers must bang for them.  But be
  // careful, because some VM calls (such as call site linkage) can
  // use several kilobytes of stack.  But the stack safety zone should
  // account for that.  See bugs 4446381, 4468289, 4497237.
  if (C->need_stack_bang(framesize)) {
    MacroAssembler masm(&cbuf);
    masm.generate_stack_overflow_check(framesize);
    need_nop = false;
  }

  if (C->start()->Opcode() == Op_StartI2C) {
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x8B);             // MOV  reg,RSP
    emit_rm(cbuf, 0x3, RBX_enc, RSP_enc);// interpreter_arg_ptr_reg
    if (VerifyStackAtCalls) {
      emit_opcode(cbuf, Assembler::REX_W);
      emit_opcode(cbuf, 0x83); // addq rbx, #8
      emit_rm(cbuf, 0x3, 0x00, RBX_enc);
      emit_d8(cbuf, 8);
    }
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x83);             // AND RSP,-16 ; Round RSP to even
    emit_rm(cbuf, 0x3, 0x4, RSP_enc);
    emit_d8(cbuf, -16);
    emit_opcode(cbuf, 0x50 | RBX_enc);      // PUSH RBX (old RSP)
    need_nop = false;
  } else if (C->start()->Opcode() == Op_StartOSR) {
    emit_opcode(cbuf, Assembler::REX_WB);
    emit_opcode(cbuf, 0x8B);             // MOV  
    emit_rm(cbuf, 0x3, RBX_enc, R14_enc);// MOV RBX,R14 locals ptr to RBX
    need_nop = false;
  }

  if (framesize) {
    emit_opcode(cbuf, Assembler::REX_W);
    if (framesize < 0x80) {
      emit_opcode(cbuf, 0x83);   // sub  SP,#framesize
      emit_rm(cbuf, 0x3, 0x05, RSP_enc);
      emit_d8(cbuf, framesize);
      if (need_nop) { 
        emit_opcode(cbuf, 0x90); // nop
      }
    } else {
      emit_opcode(cbuf, 0x81);   // sub  SP,#framesize
      emit_rm(cbuf, 0x3, 0x05, RSP_enc); 
      emit_d32(cbuf, framesize);
    }
  }
}

uint MachPrologNode::size(PhaseRegAlloc* ra_) const
{
  return MachNode::size(ra_); // too many variables; just compute it
                              // the hard way
}

int MachPrologNode::reloc() const
{
  return 0; // a large enough number
}

//=============================================================================
#ifndef PRODUCT
void MachEpilogNode::format(PhaseRegAlloc* ra_) const
{
  Compile* C = ra_->C;
  int framesize = C->frame_slots() << LogBytesPerInt;
  framesize -= wordSize;  // Remove 2 for return adr already pushed
  assert(framesize % (2 * wordSize) == wordSize, "aligned frame size");

  if (VerifyStackAtCalls && C->start()->Opcode() == Op_StartI2C) {
    framesize -= wordSize; // Majik cookie
  }

  if (framesize) {
    tty->print("addq    rsp, %d\t# Destroy frame", framesize);
  }
  if (C->start()->Opcode() == Op_StartI2C) {
    tty->cr(); 
    tty->print("\t");
    tty->print("popq    rsp\t# Recover prior rsp");
  }

  if (do_polling() && SafepointPolling && C->is_method_compilation()) {
    tty->print_cr("testl   rax, [rip + #offset_to_poll_page]\t"
                  "# Safepoint: poll for GC");
    tty->print("\t");
  }
}
#endif

void MachEpilogNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const
{
  Compile* C = ra_->C;
  int framesize = C->frame_slots() << LogBytesPerInt;
  framesize -= wordSize; // Remove 2 for return adr already pushed
  assert(framesize % (2 * wordSize) == wordSize, "aligned frame size");

  if (VerifyStackAtCalls && C->start()->Opcode() == Op_StartI2C) {
    framesize -= wordSize; // Majik cookie
  }

  if (framesize) {
    emit_opcode(cbuf, Assembler::REX_W);
    if (framesize < 0x80) {
      emit_opcode(cbuf, 0x83); // addq rsp, #framesize
      emit_rm(cbuf, 0x3, 0x00, RSP_enc);
      emit_d8(cbuf, framesize);
    } else {
      emit_opcode(cbuf, 0x81); // addq rsp, #framesize
      emit_rm(cbuf, 0x3, 0x00, RSP_enc);
      emit_d32(cbuf, framesize);
    }
  }
  if (C->start()->Opcode() == Op_StartI2C) {
    emit_opcode(cbuf, 0x58 | RSP_enc); // popq rsp
  }

  if (do_polling() && SafepointPolling && C->is_method_compilation()) {
    // testl %rax, off(%rip) // Opcode + ModRM + Disp32 == 6 bytes
    // XXX reg_mem doesn't support RIP-relative addressing yet
    cbuf.set_mark();
    cbuf.relocate(cbuf.mark(), relocInfo::poll_return_type, 0); // XXX
    emit_opcode(cbuf, 0x85); // testl
    emit_rm(cbuf, 0x0, RAX_enc, 0x5); // 00 rax 101 == 0x5
    // cbuf.mark() is beginning of instruction
    emit_d32_reloc(cbuf, 
                   (int) ((((intptr_t) os::get_polling_page()) - 
                          ((intptr_t) cbuf.code_end())) - 4),
                   relocInfo::external_word_type, //XXX
//                    relocInfo::poll_return_type, 
                   RELOC_DISP32);
  }
}

uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
{
  Compile* C = ra_->C;
  int framesize = C->frame_slots() << LogBytesPerInt;
  framesize -= wordSize; // Remove 1 for return adr already pushed
  assert(framesize % (2 * wordSize) == wordSize, "aligned frame size");

  uint size = 0;

  if (do_polling() && SafepointPolling && C->is_method_compilation()) { 
    size += 6;
  }

  if (C->start()->Opcode() == Op_StartI2C) {
    if (VerifyStackAtCalls) {
      framesize -= wordSize; // Majik cookie
    }
    size++; // popq
  }
  if (framesize) {
    if (framesize < 0x80) {
      size += 4;
    } else if (framesize) {
      size += 7;
    }
  }

  return size;
}

int MachEpilogNode::reloc() const 
{
  return 2; // a large enough number
}

const Pipeline* MachEpilogNode::pipeline() const
{
  return MachNode::pipeline_class();
}

int MachEpilogNode::safepoint_offset() const
{
  return 0;
}

//=============================================================================

enum RC {
  rc_bad, 
  rc_int, 
  rc_float,
  rc_stack 
};

static enum RC rc_class(OptoReg::Name reg) 
{
  if (reg == OptoReg::Bad) {
    return rc_bad;
  }

  assert(reg != RFLAGS_num, "blow up if spilling flags");

  if (reg <= RSP_H_num) {
    return rc_int;
  } else if (reg <= XMM15_H_num) {
    return rc_float;
  }

  // Between float regs & stack are the flags regs
  assert(reg >= SharedInfo::stack0, "blow up if spilling flags");

  return rc_stack;
}

uint MachSpillCopyNode::implementation(CodeBuffer* cbuf, 
                                       PhaseRegAlloc* ra_, 
                                       bool do_size) const
{

  // Get registers to move 
  OptoReg::Name src_hi = ra_->get_reg_hi(in(1));
  OptoReg::Name src_lo = ra_->get_reg_lo(in(1));
  OptoReg::Name dst_hi = ra_->get_reg_hi(this);
  OptoReg::Name dst_lo = ra_->get_reg_lo(this);

  enum RC src_hi_rc = rc_class(src_hi);
  enum RC src_lo_rc = rc_class(src_lo);
  enum RC dst_hi_rc = rc_class(dst_hi);
  enum RC dst_lo_rc = rc_class(dst_lo);

  assert(src_lo != OptoReg::Bad && dst_lo != OptoReg::Bad,
         "must move at least 1 register" );

  if (src_lo == dst_lo && src_hi == dst_hi) {
    // Self copy, no move
    return 0;
  } else if (src_lo_rc == rc_stack) {
    // mem ->
    if (dst_lo_rc == rc_stack) {
      // mem -> mem
      assert(src_hi != dst_lo, "overlap");
      if ((src_lo & 1) == 0 && src_lo + 1 == src_hi &&
          (dst_lo & 1) == 0 && dst_lo + 1 == dst_hi) {
        // 64-bit
        int src_offset = ra_->reg2offset(src_lo);
        int dst_offset = ra_->reg2offset(dst_lo);
        if (cbuf) {
          emit_opcode(*cbuf, 0xFF);
          encode_RegMem(*cbuf, RSI_enc, RSP_enc, 0x4, 0, src_offset, false);

          emit_opcode(*cbuf, 0x8F);
          encode_RegMem(*cbuf, RAX_enc, RSP_enc, 0x4, 0, dst_offset, false);

#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t"
                     "popq    [rsp + #%d]", 
                     src_offset,
                     dst_offset);
#endif
        }
        return 
          3 + ((src_offset == 0) ? 0 : (src_offset < 0x80 ? 1 : 4)) +
          3 + ((dst_offset == 0) ? 0 : (dst_offset < 0x80 ? 1 : 4));
      } else {
        // 32-bit
        assert(!((src_lo & 1) == 0 && src_lo + 1 == src_hi), "no transform");
        assert(!((dst_lo & 1) == 0 && dst_lo + 1 == dst_hi), "no transform");
        // No pushl/popl, so:
        int src_offset = ra_->reg2offset(src_lo);
        int dst_offset = ra_->reg2offset(dst_lo);
        if (cbuf) {
          emit_opcode(*cbuf, Assembler::REX_W);
          emit_opcode(*cbuf, 0x89);
          emit_opcode(*cbuf, 0x44);
          emit_opcode(*cbuf, 0x24);
          emit_opcode(*cbuf, 0xF8);

          emit_opcode(*cbuf, 0x8B);
          encode_RegMem(*cbuf, 
                        RAX_enc, 
                        RSP_enc, 0x4, 0, src_offset, 
                        false);

          emit_opcode(*cbuf, 0x89);
          encode_RegMem(*cbuf, 
                        RAX_enc, 
                        RSP_enc, 0x4, 0, dst_offset, 
                        false);
          
          emit_opcode(*cbuf, Assembler::REX_W);
          emit_opcode(*cbuf, 0x8B);
          emit_opcode(*cbuf, 0x44);
          emit_opcode(*cbuf, 0x24);
          emit_opcode(*cbuf, 0xF8);

#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t"
                     "movl    rax, [rsp + #%d]\n\t"
                     "movl    [rsp + #%d], rax\n\t"
                     "movq    rax, [rsp - #8]",
                     src_offset,
                     dst_offset);
#endif
        }
        return 
          5 + // movq
          3 + ((src_offset == 0) ? 0 : (src_offset < 0x80 ? 1 : 4)) + // movl
          3 + ((dst_offset == 0) ? 0 : (dst_offset < 0x80 ? 1 : 4)) + // movl
          5; // movq
      }
    } else if (dst_lo_rc == rc_int) {
      // mem -> gpr
      if ((src_lo & 1) == 0 && src_lo + 1 == src_hi &&
          (dst_lo & 1) == 0 && dst_lo + 1 == dst_hi) {
        // 64-bit
        int offset = ra_->reg2offset(src_lo);
        if (cbuf) {
          if (Matcher::_regEncode[dst_lo] < 8) {
            emit_opcode(*cbuf, Assembler::REX_W);
          } else {
            emit_opcode(*cbuf, Assembler::REX_WR);
          }
          emit_opcode(*cbuf, 0x8B);
          encode_RegMem(*cbuf,
                        Matcher::_regEncode[dst_lo], 
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movq    %s, [rsp + #%d]\t# spill", 
                     SharedInfo::regName[dst_lo],
                     offset);
#endif
        }
        return 
          ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) + 4; // REX
      } else {
        // 32-bit
        assert(!((src_lo & 1) == 0 && src_lo + 1 == src_hi), "no transform");
        assert(!((dst_lo & 1) == 0 && dst_lo + 1 == dst_hi), "no transform");
        int offset = ra_->reg2offset(src_lo);
        if (cbuf) {
          if (Matcher::_regEncode[dst_lo] >= 8) {
            emit_opcode(*cbuf, Assembler::REX_R);
          }
          emit_opcode(*cbuf, 0x8B);
          encode_RegMem(*cbuf,
                        Matcher::_regEncode[dst_lo], 
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movl    %s, [rsp + #%d]\t# spill", 
                     SharedInfo::regName[dst_lo],
                     offset);
#endif
        }
        return 
          ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) +
          ((Matcher::_regEncode[dst_lo] < 8)
           ? 3
           : 4); // REX
      }
    } else if (dst_lo_rc == rc_float) {
      // mem-> xmm
      if ((src_lo & 1) == 0 && src_lo + 1 == src_hi &&
          (dst_lo & 1) == 0 && dst_lo + 1 == dst_hi) {
        // 64-bit
        int offset = ra_->reg2offset(src_lo);
        if (cbuf) {
          emit_opcode(*cbuf, 0x66);
          if (Matcher::_regEncode[dst_lo] >= 8) {
            emit_opcode(*cbuf, Assembler::REX_R);
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x12);
          encode_RegMem(*cbuf, 
                        Matcher::_regEncode[dst_lo], 
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movlpd  %s, [rsp + #%d]\t# spill", 
                     SharedInfo::regName[dst_lo],
                     offset);
#endif
        }
        return 
          ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) +
          ((Matcher::_regEncode[dst_lo] < 8)
           ? 5
           : 6); // REX
      } else {
        // 32-bit
        assert(!((src_lo & 1) == 0 && src_lo + 1 == src_hi), "no transform");
        assert(!((dst_lo & 1) == 0 && dst_lo + 1 == dst_hi), "no transform");
        int offset = ra_->reg2offset(src_lo);
        if (cbuf) {
          emit_opcode(*cbuf, 0xF3);
          if (Matcher::_regEncode[dst_lo] >= 8) {
            emit_opcode(*cbuf, Assembler::REX_R);
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x10);
          encode_RegMem(*cbuf, 
                        Matcher::_regEncode[dst_lo], 
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movss   %s, [rsp + #%d]\t# spill", 
                     SharedInfo::regName[dst_lo],
                     offset);
#endif
        }
        return 
          ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) +
          ((Matcher::_regEncode[dst_lo] < 8)
           ? 5
           : 6); // REX
      }
    }
  } else if (src_lo_rc == rc_int) {
    // gpr ->
    if (dst_lo_rc == rc_stack) {
      // gpr -> mem
      if ((src_lo & 1) == 0 && src_lo + 1 == src_hi &&
          (dst_lo & 1) == 0 && dst_lo + 1 == dst_hi) {
        // 64-bit
        int offset = ra_->reg2offset(dst_lo);
        if (cbuf) {
          if (Matcher::_regEncode[src_lo] < 8) {
            emit_opcode(*cbuf, Assembler::REX_W);
          } else {
            emit_opcode(*cbuf, Assembler::REX_WR);
          }
          emit_opcode(*cbuf, 0x89);
          encode_RegMem(*cbuf, 
                        Matcher::_regEncode[src_lo], 
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movq    [rsp + #%d], %s\t# spill", 
                     offset,
                     SharedInfo::regName[src_lo]);
#endif
        }
        return ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) + 4; // REX
      } else {
        // 32-bit
        assert(!((src_lo & 1) == 0 && src_lo + 1 == src_hi), "no transform");
        assert(!((dst_lo & 1) == 0 && dst_lo + 1 == dst_hi), "no transform");
        int offset = ra_->reg2offset(dst_lo);
        if (cbuf) {
          if (Matcher::_regEncode[src_lo] >= 8) {
            emit_opcode(*cbuf, Assembler::REX_R);
          }
          emit_opcode(*cbuf, 0x89);
          encode_RegMem(*cbuf, 
                        Matcher::_regEncode[src_lo], 
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movl    [rsp + #%d], %s\t# spill", 
                     offset,
                     SharedInfo::regName[src_lo]);
#endif
        }
        return 
          ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) +
          ((Matcher::_regEncode[src_lo] < 8)
           ? 3
           : 4); // REX
      }
    } else if (dst_lo_rc == rc_int) {
      // gpr -> gpr
      if ((src_lo & 1) == 0 && src_lo + 1 == src_hi &&
          (dst_lo & 1) == 0 && dst_lo + 1 == dst_hi) {
        // 64-bit
        if (cbuf) {
          if (Matcher::_regEncode[dst_lo] < 8) {
            if (Matcher::_regEncode[src_lo] < 8) {
              emit_opcode(*cbuf, Assembler::REX_W);
            } else {
              emit_opcode(*cbuf, Assembler::REX_WB);
            }
          } else {
            if (Matcher::_regEncode[src_lo] < 8) {
              emit_opcode(*cbuf, Assembler::REX_WR);
            } else {
              emit_opcode(*cbuf, Assembler::REX_WRB);
            }
          }
          emit_opcode(*cbuf, 0x8B);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[dst_lo] & 7,
                  Matcher::_regEncode[src_lo] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movq    %s, %s\t# spill",
                     SharedInfo::regName[dst_lo],
                     SharedInfo::regName[src_lo]);
#endif
        }
        return 3; // REX
      } else {
        // 32-bit
        assert(!((src_lo & 1) == 0 && src_lo + 1 == src_hi), "no transform");
        assert(!((dst_lo & 1) == 0 && dst_lo + 1 == dst_hi), "no transform");
        if (cbuf) {
          if (Matcher::_regEncode[dst_lo] < 8) {
            if (Matcher::_regEncode[src_lo] >= 8) {
              emit_opcode(*cbuf, Assembler::REX_B);
            }
          } else {
            if (Matcher::_regEncode[src_lo] < 8) {
              emit_opcode(*cbuf, Assembler::REX_R);
            } else {
              emit_opcode(*cbuf, Assembler::REX_RB);
            }
          }
          emit_opcode(*cbuf, 0x8B);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[dst_lo] & 7,
                  Matcher::_regEncode[src_lo] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movl    %s, %s\t# spill", 
                     SharedInfo::regName[dst_lo],
                     SharedInfo::regName[src_lo]);
#endif
        }
        return 
          (Matcher::_regEncode[src_lo] < 8 && Matcher::_regEncode[dst_lo] < 8)
          ? 2
          : 3; // REX
      }
    } else if (dst_lo_rc == rc_float) {
      // gpr -> xmm
      if ((src_lo & 1) == 0 && src_lo + 1 == src_hi &&
          (dst_lo & 1) == 0 && dst_lo + 1 == dst_hi) {
        // 64-bit
        if (cbuf) {
          emit_opcode(*cbuf, 0x66);
          if (Matcher::_regEncode[dst_lo] < 8) {
            if (Matcher::_regEncode[src_lo] < 8) {
              emit_opcode(*cbuf, Assembler::REX_W);
            } else {
              emit_opcode(*cbuf, Assembler::REX_WB);
            }
          } else {
            if (Matcher::_regEncode[src_lo] < 8) {
              emit_opcode(*cbuf, Assembler::REX_WR);
            } else {
              emit_opcode(*cbuf, Assembler::REX_WRB);
            }
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x6E);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[dst_lo] & 7,
                  Matcher::_regEncode[src_lo] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movdq   %s, %s\t# spill", 
                     SharedInfo::regName[dst_lo],
                     SharedInfo::regName[src_lo]);
#endif
        }
        return 5; // REX
      } else {
        // 32-bit
        assert(!((src_lo & 1) == 0 && src_lo + 1 == src_hi), "no transform");
        assert(!((dst_lo & 1) == 0 && dst_lo + 1 == dst_hi), "no transform");
        if (cbuf) {
          emit_opcode(*cbuf, 0x66);
          if (Matcher::_regEncode[dst_lo] < 8) {
            if (Matcher::_regEncode[src_lo] >= 8) {
              emit_opcode(*cbuf, Assembler::REX_B);
            }
          } else {
            if (Matcher::_regEncode[src_lo] < 8) {
              emit_opcode(*cbuf, Assembler::REX_R);
            } else {
              emit_opcode(*cbuf, Assembler::REX_RB);
            }
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x6E);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[dst_lo] & 7,
                  Matcher::_regEncode[src_lo] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movdl   %s, %s\t# spill", 
                     SharedInfo::regName[dst_lo],
                     SharedInfo::regName[src_lo]);
#endif
        }
        return 
          (Matcher::_regEncode[src_lo] < 8 && Matcher::_regEncode[dst_lo] < 8)
          ? 4
          : 5; // REX
      }
    }
  } else if (src_lo_rc == rc_float) {
    // xmm ->
    if (dst_lo_rc == rc_stack) {
      // xmm -> mem
      if ((src_lo & 1) == 0 && src_lo + 1 == src_hi &&
          (dst_lo & 1) == 0 && dst_lo + 1 == dst_hi) {
        // 64-bit
        int offset = ra_->reg2offset(dst_lo);
        if (cbuf) {
          emit_opcode(*cbuf, 0xF2);
          if (Matcher::_regEncode[src_lo] >= 8) {
              emit_opcode(*cbuf, Assembler::REX_R);
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x11);
          encode_RegMem(*cbuf, 
                        Matcher::_regEncode[src_lo], 
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movsd   [rsp + #%d], %s\t# spill", 
                     offset,
                     SharedInfo::regName[src_lo]);
#endif
        }
        return 
          ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) +
          ((Matcher::_regEncode[src_lo] < 8)
           ? 5
           : 6); // REX
      } else {
        // 32-bit
        assert(!((src_lo & 1) == 0 && src_lo + 1 == src_hi), "no transform");
        assert(!((dst_lo & 1) == 0 && dst_lo + 1 == dst_hi), "no transform");
        int offset = ra_->reg2offset(dst_lo);
        if (cbuf) {
          emit_opcode(*cbuf, 0xF3);
          if (Matcher::_regEncode[src_lo] >= 8) {
              emit_opcode(*cbuf, Assembler::REX_R);
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x11);
          encode_RegMem(*cbuf, 
                        Matcher::_regEncode[src_lo], 
                        RSP_enc, 0x4, 0, offset,
                        false);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movss   [rsp + #%d], %s\t# spill", 
                     offset,
                     SharedInfo::regName[src_lo]);
#endif
        }
        return 
          ((offset == 0) ? 0 : (offset < 0x80 ? 1 : 4)) +
          ((Matcher::_regEncode[src_lo] < 8)
           ? 5
           : 6); // REX
      }
    } else if (dst_lo_rc == rc_int) {
      // xmm -> gpr
      if ((src_lo & 1) == 0 && src_lo + 1 == src_hi &&
          (dst_lo & 1) == 0 && dst_lo + 1 == dst_hi) {
        // 64-bit
        if (cbuf) {
          emit_opcode(*cbuf, 0x66);
          if (Matcher::_regEncode[dst_lo] < 8) {
            if (Matcher::_regEncode[src_lo] < 8) {
              emit_opcode(*cbuf, Assembler::REX_W);
            } else {
              emit_opcode(*cbuf, Assembler::REX_WR); // attention!
            }
          } else {
            if (Matcher::_regEncode[src_lo] < 8) {
              emit_opcode(*cbuf, Assembler::REX_WB); // attention!
            } else {
              emit_opcode(*cbuf, Assembler::REX_WRB);
            }
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x7E);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[dst_lo] & 7,
                  Matcher::_regEncode[src_lo] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movdq   %s, %s\t# spill", 
                     SharedInfo::regName[dst_lo],
                     SharedInfo::regName[src_lo]);
#endif
        }
        return 5; // REX
      } else {
        // 32-bit
        assert(!((src_lo & 1) == 0 && src_lo + 1 == src_hi), "no transform");
        assert(!((dst_lo & 1) == 0 && dst_lo + 1 == dst_hi), "no transform");
        if (cbuf) {
          emit_opcode(*cbuf, 0x66);
          if (Matcher::_regEncode[dst_lo] < 8) {
            if (Matcher::_regEncode[src_lo] >= 8) {
              emit_opcode(*cbuf, Assembler::REX_R); // attention!
            }
          } else {
            if (Matcher::_regEncode[src_lo] < 8) {
              emit_opcode(*cbuf, Assembler::REX_B); // attention!
            } else {
              emit_opcode(*cbuf, Assembler::REX_RB);
            }
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x7E);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[dst_lo] & 7,
                  Matcher::_regEncode[src_lo] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movdl   %s, %s\t# spill", 
                     SharedInfo::regName[dst_lo],
                     SharedInfo::regName[src_lo]);
#endif
        }
        return 
          (Matcher::_regEncode[src_lo] < 8 && Matcher::_regEncode[dst_lo] < 8)
          ? 4
          : 5; // REX
      }
    } else if (dst_lo_rc == rc_float) {
      // xmm -> xmm
      if ((src_lo & 1) == 0 && src_lo + 1 == src_hi &&
          (dst_lo & 1) == 0 && dst_lo + 1 == dst_hi) {
        // 64-bit
        if (cbuf) {
          emit_opcode(*cbuf, 0xF2);
          if (Matcher::_regEncode[dst_lo] < 8) {
            if (Matcher::_regEncode[src_lo] >= 8) {
              emit_opcode(*cbuf, Assembler::REX_B);
            }
          } else {
            if (Matcher::_regEncode[src_lo] < 8) {
              emit_opcode(*cbuf, Assembler::REX_R);
            } else {
              emit_opcode(*cbuf, Assembler::REX_RB);
            }
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x10);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[dst_lo] & 7,
                  Matcher::_regEncode[src_lo] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movsd   %s, %s\t# spill", 
                     SharedInfo::regName[dst_lo],
                     SharedInfo::regName[src_lo]);
#endif
        }
        return 
          (Matcher::_regEncode[src_lo] < 8 && Matcher::_regEncode[dst_lo] < 8)
          ? 4
          : 5; // REX
      } else {
        // 32-bit
        assert(!((src_lo & 1) == 0 && src_lo + 1 == src_hi), "no transform");
        assert(!((dst_lo & 1) == 0 && dst_lo + 1 == dst_hi), "no transform");
        if (cbuf) {
          emit_opcode(*cbuf, 0xF3);
          if (Matcher::_regEncode[dst_lo] < 8) {
            if (Matcher::_regEncode[src_lo] >= 8) {
              emit_opcode(*cbuf, Assembler::REX_B);
            }
          } else {
            if (Matcher::_regEncode[src_lo] < 8) {
              emit_opcode(*cbuf, Assembler::REX_R);
            } else {
              emit_opcode(*cbuf, Assembler::REX_RB);
            }
          }
          emit_opcode(*cbuf, 0x0F);
          emit_opcode(*cbuf, 0x10);
          emit_rm(*cbuf, 0x3,
                  Matcher::_regEncode[dst_lo] & 7,
                  Matcher::_regEncode[src_lo] & 7);
#ifndef PRODUCT
        } else if (!do_size) {
          tty->print("movss   %s, %s\t# spill", 
                     SharedInfo::regName[dst_lo],
                     SharedInfo::regName[src_lo]);
#endif
        }
        return 
          (Matcher::_regEncode[src_lo] < 8 && Matcher::_regEncode[dst_lo] < 8)
          ? 4
          : 5; // REX
      }
    }
  }    

  assert(0," foo ");
  Unimplemented();

  return 0;
}

#ifndef PRODUCT
void MachSpillCopyNode::format(PhaseRegAlloc *ra_) const 
{
  implementation(NULL, ra_, false);
}
#endif

void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const 
{
  implementation(&cbuf, ra_, false);
}

uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const 
{
  return implementation(NULL, ra_, true);
}

//=============================================================================
#ifndef PRODUCT
void MachNopNode::format(PhaseRegAlloc*) const
{
  tty->print("nop     # pad for loops and calls");
}
#endif

void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc*) const 
{
  emit_opcode(cbuf, 0x90); // nop 
}

uint MachNopNode::size(PhaseRegAlloc*) const
{
  return 1;
}


//=============================================================================
#ifndef PRODUCT
void BoxLockNode::format(PhaseRegAlloc* ra_) const
{
  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
  int reg = ra_->get_reg_lo(this);
  tty->print("leaq    %s, [rsp + #%d]\t# box lock", 
             Matcher::regName[reg], offset);
}
#endif

void BoxLockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const
{
  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
  int reg = ra_->get_encode(this);
  if (offset >= 0x80) {
    emit_opcode(cbuf, reg < 8 ? Assembler::REX_W : Assembler::REX_WR);
    emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
    emit_rm(cbuf, 0x2, reg & 7, 0x04);
    emit_rm(cbuf, 0x0, 0x04, RSP_enc);
    emit_d32(cbuf, offset);
  } else {
    emit_opcode(cbuf, reg < 8 ? Assembler::REX_W : Assembler::REX_WR);
    emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
    emit_rm(cbuf, 0x1, reg & 7, 0x04);
    emit_rm(cbuf, 0x0, 0x04, RSP_enc);
    emit_d8(cbuf, offset);
  }
}

uint BoxLockNode::size(PhaseRegAlloc *ra_) const
{
  int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
  return (offset < 0x80) ? 5 : 8; // REX
}

//=============================================================================

// emit call stub, compiled java to interpreter
void emit_java_to_interp(CodeBuffer& cbuf)
{
  // Stub is fixed up when the corrrsponding call is converted from
  // calling compiled code to calling interpreted code.
  // movq rax, 0
  // jmp -5 # to self

  cbuf.start_a_stub();
  // static stub relocation stores the instruction address of the call
  cbuf.relocate(cbuf.code_end(), 
                static_stub_Relocation::spec(cbuf.mark()), RELOC_IMM64);
  // static stub relocation also tags the methodOop in the code-stream.
  cbuf.relocate(cbuf.code_end(),
                oop_Relocation::spec_for_immediate(), RELOC_IMM64);
  emit_opcode(cbuf, Assembler::REX_W);
  emit_opcode(cbuf, 0xB8 | RAX_enc); // movq rax, method
  emit_d64(cbuf, 0);                 // method is zapped till fixup time
  cbuf.set_mark();
  emit_opcode(cbuf, 0xE9);           // jmp entry
  emit_d32_reloc(cbuf, -5,
                 runtime_call_Relocation::spec(),
                 RELOC_DISP32);

  // Update current stubs pointer and restore code_end.
  cbuf.end_a_stub();
}

// size of call stub, compiled java to interpretor
uint size_java_to_interp()
{
  return 15;
}

// relocation entries for call stub, compiled java to interpretor
uint reloc_java_to_interp() 
{
  return 4; // 3 in emit_java_to_interp + 1 in Java_Static_Call
}

//=============================================================================
#ifndef PRODUCT
void MachUEPNode::format(PhaseRegAlloc* ra_) const
{
  tty->print_cr("cmpq    rax, [rcx + oopDesc::klass_offset_in_bytes() #%d]\t"
                "# Inline cache check", oopDesc::klass_offset_in_bytes());
  tty->print_cr("\tjne     OptoRuntime::handle_ic_miss_stub");
  tty->print_cr("\tnop");
  if (!OptoBreakpoint) {
    tty->print_cr("\tnop");
  }
}
#endif

void MachUEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const
{
  MacroAssembler masm(&cbuf);
#ifdef ASSERT
  uint code_size = cbuf.code_size();
#endif
  masm.cmpq(rax, Address(rcx, oopDesc::klass_offset_in_bytes()));
  masm.jcc(Assembler::notEqual, 
           OptoRuntime::handle_ic_miss_stub(), relocInfo::runtime_call_type);
  /* WARNING these NOPs are critical so that verified entry point is properly
     aligned for patching by NativeJump::patch_verified_entry() */
  masm.nop();
  if (!OptoBreakpoint) {
    // Leave space for int3
    masm.nop();
  }

  assert(cbuf.code_size() - code_size == size(ra_), 
         "checking code size of inline cache node");
}

uint MachUEPNode::size(PhaseRegAlloc* ra_) const
{
  return OptoBreakpoint ? 11 : 12;
}

uint offset_start_of_table() {
  return 0; 
}

//=============================================================================
#ifndef PRODUCT
void MachC2IEntriesNode::format(PhaseRegAlloc* ra_) const 
{
  int ic_reg  = Matcher::inline_cache_reg();
  int rec_reg = Matcher::compiler_method_oop_reg();
  int tmp_reg = RBX_num;
  const char* ic_name  = Matcher::regName[ic_reg];
  const char* rec_name = Matcher::regName[rec_reg];
  const char* tmp_name = Matcher::regName[tmp_reg];
  const char* fp_name  = "RSP";

  // Assert that we don't need REX (except REX.W)
  assert(Matcher::_regEncode[ic_reg] < 8, "no REX encoded");
  assert(Matcher::_regEncode[rec_reg] < 8, "no REX encoded");

  tty->print_cr("------ MKH Unverified Entry Point");
  int disp = oopDesc::klass_offset_in_bytes();
  if (MacroAssembler::needs_explicit_null_check(disp)) {
    Unimplemented();
    tty->print_cr("\tcmpq    %s, [%s]\t# null check", ic_name, rec_name);
  }
  // Access receiver klass: this->klass
  tty->print_cr("\tmovq    %s, [%s + oopDesc::klass_offset_in_bytes() #%d]\t"
                "# receiver klass", 
                tmp_name, rec_name, disp);
  disp = compiledICHolderOopDesc::holder_klass_offset();
  tty->print_cr("\tcmpq    %s, "
                "[%s + compiledICHolderOopDesc::holder_klass_offset() #%d]", 
                tmp_name, ic_name, disp);

  // Unpack compiledIC                 
  disp = compiledICHolderOopDesc::holder_method_offset();
  tty->print_cr("\tmovq    %s, "
                "[%s + compiledICHolderOopDesc::holder_method_offset() #%d]",
                ic_name, ic_name, disp);

  // Jump to inline cache miss fixup if check fails                 
  tty->print_cr("\tjne     OptoRuntime::handle_ic_miss_stub");

  tty->print_cr( "------ Std Verified Entry Point");
}
#endif

void MachC2IEntriesNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const
{
  int ic_reg  = Matcher::inline_cache_reg();
  int rec_reg = Matcher::compiler_method_oop_reg();
  int tmp_reg = RBX_num;
  int ic_encode  = Matcher::_regEncode[ic_reg];
  int rec_encode = Matcher::_regEncode[rec_reg];
  int tmp_encode = Matcher::_regEncode[tmp_reg];

  // Assert that we don't need REX (except REX.W)
  assert(ic_encode < 8, "no REX encoded");
  assert(rec_encode < 8, "no REX encoded");

  // !!!!!
  // Check that the registers are distinct, check ic_reg != rec_reg
  // checked in ADLC
  assert(ic_reg != rec_reg, "registers must be distinct");
  assert(ic_reg != tmp_reg, "registers must be distinct");
  // Check that these registers are caller-saved
  assert(register_save_policy[ic_reg] == 'C' || 
         register_save_policy[ic_reg] == 'A',
         "This register must be caller-saved or always-saved.");
  assert(register_save_policy[rec_reg] == 'C' || 
         register_save_policy[rec_reg] == 'A',
         "This register must be caller-saved or always-saved.");
  assert(register_save_policy[tmp_reg] == 'C' || 
         register_save_policy[tmp_reg] == 'A',
         "This register must be caller-saved or always-saved.");

  // ------ MKH Entry Point, Unverified
  // Receives the MethodKlassHolder in inline_cache_reg

  // size 13+6
  // Access "this" pointer from stack

  // Access receiver klass: this->klass
  int disp = oopDesc::klass_offset_in_bytes();
  assert(-0x80 <= disp && disp < 0x80, "klass_offset_in_bytes is small");
  emit_opcode(cbuf, Assembler::REX_W);
  emit_opcode(cbuf, 0x8B); // MOV tmp_reg,[rec_reg+klass_offset_in_bytes]
  emit_rm(cbuf, 0x01, tmp_encode, rec_encode); // R/M byte
  emit_d8(cbuf, disp); // Displacement

  // Compare this->klass, in rec_reg, with inline_cached_klass
  disp = compiledICHolderOopDesc::holder_klass_offset();
  assert(-0x80 <= disp && disp < 0x80, 
         "holder_klass_offset is small displacement");
  emit_opcode(cbuf, Assembler::REX_W);
  emit_opcode(cbuf, 0x3B);  // CMP tmp_reg,[ic_reg+holder_klass_offset]
  emit_rm(cbuf, 0x01, tmp_encode, ic_encode);  // R/M byte
  emit_d8(cbuf, disp); // Displacement

  // Access method_oop from compiledICHolder
  disp = compiledICHolderOopDesc::holder_method_offset();
  assert(-0x80 <= disp && disp < 0x80, "holder_method_offset is small");
  emit_opcode(cbuf, Assembler::REX_W);
  emit_opcode(cbuf, 0x8B); // MOV    ic_reg,[ic_reg+holder_method_offset]
  emit_rm(cbuf, 0x01, ic_encode, ic_encode ); // R/M byte
  emit_d8(cbuf, disp); // Displacement

  cbuf.set_mark();
  emit_opcode(cbuf, 0x0F); // JNE    FIXUP
  emit_opcode(cbuf, 0x85);
  // Grab address for fixup branch in unvalidated entry
  address addr = OptoRuntime::handle_ic_miss_stub();
  emit_d32_reloc(cbuf, 
                 (int) (addr - cbuf.code_end() - 4), 
                 runtime_call_Relocation::spec(), 
                 RELOC_DISP32);
  
  // ------ Std Verified Entry Point
  // Receives a method oop in inline_cache_reg  
}

uint MachC2IEntriesNode::size(PhaseRegAlloc* ra_) const
{
  return 15 + 3; // 3 REX
}

//=============================================================================

#ifndef PRODUCT
void MachC2IcheckICNode::format(PhaseRegAlloc* ra_) const
{
  // get register. Inline cache register will contain methodOop at
  // this point. compiler_method_oop_reg is used tempoarily.
  int method_oop = Matcher::inline_cache_reg();
  int temp_reg = RBX_num;

  assert(method_oop != temp_reg, "cannot be the same");
  assert(Matcher::_regEncode[method_oop] < 8, "no REX encoded");

  const char *method_oop_name  = Matcher::regName[method_oop];
  const char *temp_name = Matcher::regName[temp_reg];
  
  tty->print_cr( "------ checkIC ------");
  int disp = in_bytes(methodOopDesc::compiled_code_offset());
  tty->print_cr("\tmovq    %s, "
                "[%s + in_bytes(methodOopDesc::compiled_code_offset()) #%d]",
                temp_name, method_oop_name, disp);
  tty->print_cr("\ttestq   %s, %s\t# code exists?" , temp_name, temp_name);
  tty->print_cr("\tjne     OptoRuntime::handle_wrong_method_stub()");
}
#endif

void MachC2IcheckICNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const 
{
  int method_oop_reg = Matcher::inline_cache_reg();
  int method_oop_encode = Matcher::_regEncode[method_oop_reg];
  int temp_reg = RBX_num;
  int temp_encode = Matcher::_regEncode[temp_reg];

  assert(method_oop_encode < 8, "no REX encoded");

  // Access code field from methodOop
  int disp = in_bytes(methodOopDesc::compiled_code_offset());
  assert(-0x80 <= disp && disp < 0x80, "code offset to big");
  // MOV    temp_reg,[method_oop_reg+methodOop::compiled_code_offset_in_bytes]
  emit_opcode(cbuf, Assembler::REX_W);
  emit_opcode(cbuf, 0x8B);
  emit_rm(cbuf, 0x01, temp_encode, method_oop_encode); // R/M byte
  emit_d8(cbuf, disp); // Displacement

  // TEST temp_reg, temp_reg
  emit_opcode(cbuf, Assembler::REX_W);
  emit_opcode(cbuf, 0x85);
  emit_rm(cbuf, 0x03, temp_encode, temp_encode);

  // jne clear_ic_stub()
  cbuf.set_mark();
  emit_opcode(cbuf, 0x0F);           
  emit_opcode(cbuf, 0x85);
  // Grab address for fixup branch in unvalidated entry
  address addr = OptoRuntime::handle_wrong_method_stub();
  emit_d32_reloc(cbuf, 
                 (int) (addr - cbuf.code_end() - 4), 
                 runtime_call_Relocation::spec(),
                 RELOC_DISP32);  
}

uint MachC2IcheckICNode::size(PhaseRegAlloc* ra_) const
{
  return 11 + 2; // REX
}

//=============================================================================
// Emit exception handler code.  Stuff framesize into a register
// and call a VM stub routine.
void emit_exception_handler(CodeBuffer& cbuf) 
{
  // Lazy deopt bug 4932387. If last instruction is a call then we
  // need an area to patch where we won't overwrite the exception
  // handler. This means we need 5 bytes.
  for (int i = 0; i < NativeCall::instruction_size ; i++ ) {
    emit_opcode(cbuf, 0x90);
  }

  // Now mark the functional start of the exception handler
  cbuf.set_exception_offset(cbuf.code_size());

  cbuf.set_mark();
  emit_opcode(cbuf, 0xE9); // jmp    entry
  emit_d32_reloc(cbuf, 
                 (int) (OptoRuntime::exception_blob()->instructions_begin() - 
                        cbuf.code_end() - 4),
                 runtime_call_Relocation::spec(),
                 RELOC_DISP32);
}

uint size_exception_handler()
{
  // NativeCall instruction size is the same as NativeJump.
  // exception handler starts out as jump and can be patched to
  // a call be deoptimization. The *2 is because of the padding
  // we need to make sure that deopt patches don't accidentally
  // overwrite patched exception handler (4932387)
  return 2*NativeCall::instruction_size;
}

int Matcher::regnum_to_fpu_offset(int regnum)
{
  return regnum - 32; // The FP registers are in the second chunk
}

// JumpTable support
const bool Matcher::jumpTableSupported(void) {
  return false;
}

// This is UltraSparc specific, true just means we have fast l2f conversion
const bool Matcher::convL2FSupported(void) {
  return true;
}

// Is this branch offset short enough that a short branch can be used?
//
// NOTE: If the platform does not provide any short branch variants, then
//       this method should return false for offset 0.
bool Matcher::is_short_branch_offset(int offset) 
{
  return -0x80 <= offset && offset < 0x80;
}

// Should the Matcher clone shifts on addressing modes, expecting them
// to be subsumed into complex addressing expressions or compute them
// into registers?  True for Intel but false for most RISCs
const bool Matcher::clone_shift_expressions = true;

// Is it better to copy float constants, or load them directly from
// memory?  Intel can load a float constant from a direct address,
// requiring no extra registers.  Most RISCs will have to materialize
// an address into a register first, so they would do better to copy
// the constant from stack.
const bool Matcher::rematerialize_float_constants = true; // XXX

// If CPU can load and store mis-aligned doubles directly then no
// fixup is needed.  Else we split the double into 2 integer pieces
// and move it piece-by-piece.  Only happens when passing doubles into
// C code as the Java calling convention forces doubles to be aligned.
const bool Matcher::misaligned_doubles_ok = true;

// No-op on amd64
void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}

// Advertise here if the CPU requires explicit rounding operations to
// implement the UseStrictFP mode.
const bool Matcher::strict_fp_requires_explicit_rounding = false;

// Do floats take an entire double register or just half?
const bool Matcher::float_in_double = true;
// Do ints take an entire long register or just half?
const bool Matcher::int_in_long = true;

// What is the range of offsets for allocator spill instructions?
// Offsets larger than this will encode to a 'large' instruction and
// offsets same size or smaller will encode to a 'small' instruction.
// On Sparc the 'small' offset is from 0 to 4096; offsets larger than
// this will not have any sane encoding (there's no spare register to
// build up a large offset).  However, 4096 should be plenty large
// enough.  On Intel the 'small' offset is from 0 to 127; 'large'
// offsets are +128 on up.  The allocator will match both large and
// small versions of load/store [SP+offset] instructions, and will
// clone such instructions in fixup_spills and patch in the correct
// offset.
const int Matcher::short_spill_offset_limit = 0x80;

// Return whether or not this register is ever used as an argument.
// This function is used on startup to build the trampoline stubs in
// generateOptoStub.  Registers not mentioned will be killed by the VM
// call in the trampoline, and arguments in those registers not be
// available to the callee.
bool Matcher::can_be_arg(int reg)
{
  return 
    reg ==  RDI_num || reg ==  RDI_H_num || 
    reg ==  RSI_num || reg ==  RSI_H_num || 
    reg ==  RDX_num || reg ==  RDX_H_num ||
    reg ==  RCX_num || reg ==  RCX_H_num || 
    reg ==   R8_num || reg ==   R8_H_num || 
    reg ==   R9_num || reg ==   R9_H_num || 
    reg == XMM0_num || reg == XMM0_H_num ||
    reg == XMM1_num || reg == XMM1_H_num ||
    reg == XMM2_num || reg == XMM2_H_num ||
    reg == XMM3_num || reg == XMM3_H_num ||
    reg == XMM4_num || reg == XMM4_H_num ||
    reg == XMM5_num || reg == XMM5_H_num ||
    reg == XMM6_num || reg == XMM6_H_num ||
    reg == XMM7_num || reg == XMM7_H_num;
}

bool Matcher::is_spillable_arg(int reg)
{
  return can_be_arg(reg);
}

%}

//----------ENCODING BLOCK-----------------------------------------------------
// This block specifies the encoding classes used by the compiler to
// output byte streams.  Encoding classes are parameterized macros
// used by Machine Instruction Nodes in order to generate the bit
// encoding of the instruction.  Operands specify their base encoding
// interface with the interface keyword.  There are currently
// supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &
// COND_INTER.  REG_INTER causes an operand to generate a function
// which returns its register number when queried.  CONST_INTER causes
// an operand to generate a function which returns the value of the
// constant when queried.  MEMORY_INTER causes an operand to generate
// four functions which return the Base Register, the Index Register,
// the Scale Value, and the Offset Value of the operand when queried.
// COND_INTER causes an operand to generate six functions which return
// the encoding code (ie - encoding bits for the instruction)
// associated with each basic boolean condition for a conditional
// instruction.
//
// Instructions specify two basic values for encoding.  Again, a
// function is available to check if the constant displacement is an
// oop. They use the ins_encode keyword to specify their encoding
// classes (which must be a sequence of enc_class names, and their
// parameters, specified in the encoding block), and they use the
// opcode keyword to specify, in order, their primary, secondary, and
// tertiary opcode.  Only the opcode sections which a particular
// instruction needs for encoding need to be specified.
encode %{
  // Build emit functions for each basic byte or larger field in the
  // intel encoding scheme (opcode, rm, sib, immediate), and call them
  // from C++ code in the enc_class source block.  Emit functions will
  // live in the main source block for now.  In future, we can
  // generalize this by adding a syntax that specifies the sizes of
  // fields in an order, so that the adlc can build the emit functions
  // automagically

  // Emit primary opcode
  enc_class OpcP 
  %{
    emit_opcode(cbuf, $primary);
  %}

  // Emit secondary opcode
  enc_class OpcS 
  %{
    emit_opcode(cbuf, $secondary);
  %}

  // Emit tertiary opcode
  enc_class OpcT 
  %{
    emit_opcode(cbuf, $tertiary);
  %}

  // Emit opcode directly
  enc_class Opcode(immI d8)
  %{
    emit_opcode(cbuf, $d8$$constant);
  %}

  // Emit size prefix
  enc_class SizePrefix
  %{
    emit_opcode(cbuf, 0x66);
  %}

  enc_class reg(rRegI reg)
  %{
    emit_rm(cbuf, 0x3, 0, $reg$$reg & 7);
  %}

  enc_class reg_reg(rRegI dst, rRegI src)
  %{
    emit_rm(cbuf, 0x3, $dst$$reg & 7, $src$$reg & 7);
  %}

  enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
  %{
    emit_opcode(cbuf, $opcode$$constant);
    emit_rm(cbuf, 0x3, $dst$$reg & 7, $src$$reg & 7);
  %}

  enc_class cmpfp_fixup() 
  %{
    // jnp,s exit
    emit_opcode(cbuf, 0x7B);
    emit_d8(cbuf, 0x0A);

    // pushfq
    emit_opcode(cbuf, 0x9C);

    // andq $0xffffff2b, (%rsp)
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x81);
    emit_opcode(cbuf, 0x24);
    emit_opcode(cbuf, 0x24);
    emit_d32(cbuf, 0xffffff2b);

    // popfq
    emit_opcode(cbuf, 0x9D);

    // nop (target for branch to avoid branch to branch)
    emit_opcode(cbuf, 0x90);
  %}

  enc_class cmpfp3(rRegI dst)
  %{
    int dstenc = $dst$$reg;

    // movl $dst, -1
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0xB8 | (dstenc & 7));
    emit_d32(cbuf, -1);

    // jp,s done
    emit_opcode(cbuf, 0x7A);
    emit_d8(cbuf, dstenc < 4 ? 0x08 : 0x0A);

    // jb,s done
    emit_opcode(cbuf, 0x72);
    emit_d8(cbuf, dstenc < 4 ? 0x06 : 0x08);

    // setne $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x95);
    emit_opcode(cbuf, 0xC0 | (dstenc & 7));

    // movzbl $dst, $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_RB);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0xB6);
    emit_rm(cbuf, 0x3, dstenc & 7, dstenc & 7);
  %}

  enc_class cdql_enc(no_rax_rdx_RegI div)
  %{
    // Full implementation of Java idiv and irem; checks for
    // special case as described in JVM spec., p.243 & p.271.
    //
    //         normal case                           special case
    //
    // input : rax: dividend                         min_int
    //         reg: divisor                          -1
    //
    // output: rax: quotient  (= rax idiv reg)       min_int
    //         rdx: remainder (= rax irem reg)       0
    //
    //  Code sequnce:
    //    
    //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
    //    5:   75 07/08                jne    e <normal>
    //    7:   33 d2                   xor    %edx,%edx
    //  [div >= 8 -> offset + 1]
    //  [REX_B]
    //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
    //    c:   74 03/04                je     11 <done>
    // 000000000000000e <normal>:
    //    e:   99                      cltd   
    //  [div >= 8 -> offset + 1]
    //  [REX_B]
    //    f:   f7 f9                   idiv   $div
    // 0000000000000011 <done>:

    // cmp    $0x80000000,%eax
    emit_opcode(cbuf, 0x3d);
    emit_d8(cbuf, 0x00);      
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x80);

    // jne    e <normal>
    emit_opcode(cbuf, 0x75);
    emit_d8(cbuf, $div$$reg < 8 ? 0x07 : 0x08);

    // xor    %edx,%edx
    emit_opcode(cbuf, 0x33);
    emit_d8(cbuf, 0xD2);

    // cmp    $0xffffffffffffffff,%ecx
    if ($div$$reg >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x7, $div$$reg & 7);
    emit_d8(cbuf, 0xFF);

    // je     11 <done>
    emit_opcode(cbuf, 0x74);
    emit_d8(cbuf, $div$$reg < 8 ? 0x03 : 0x04);

    // <normal>
    // cltd   
    emit_opcode(cbuf, 0x99);

    // idivl (note: must be emitted by the user of this rule)
    // <done>
  %}

  enc_class cdqq_enc(no_rax_rdx_RegL div)
  %{
    // Full implementation of Java ldiv and lrem; checks for
    // special case as described in JVM spec., p.243 & p.271.
    //
    //         normal case                           special case
    //
    // input : rax: dividend                         min_long
    //         reg: divisor                          -1
    //
    // output: rax: quotient  (= rax idiv reg)       min_long
    //         rdx: remainder (= rax irem reg)       0
    //
    //  Code sequnce:
    //    
    //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
    //    7:   00 00 80 
    //    a:   48 39 d0                cmp    %rdx,%rax
    //    d:   75 08                   jne    17 <normal>
    //    f:   33 d2                   xor    %edx,%edx
    //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
    //   15:   74 05                   je     1c <done>
    // 0000000000000017 <normal>:
    //   17:   48 99                   cqto   
    //   19:   48 f7 f9                idiv   $div
    // 000000000000001c <done>:

    // mov    $0x8000000000000000,%rdx
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0xBA);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x00);
    emit_d8(cbuf, 0x80);

    // cmp    %rdx,%rax
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x39);
    emit_d8(cbuf, 0xD0);

    // jne    17 <normal>
    emit_opcode(cbuf, 0x75);
    emit_d8(cbuf, 0x08);

    // xor    %edx,%edx
    emit_opcode(cbuf, 0x33);
    emit_d8(cbuf, 0xD2);

    // cmp    $0xffffffffffffffff,$div
    emit_opcode(cbuf, $div$$reg < 8 ? Assembler::REX_W : Assembler::REX_WB);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x7, $div$$reg & 7);
    emit_d8(cbuf, 0xFF);

    // je     1e <done>
    emit_opcode(cbuf, 0x74);
    emit_d8(cbuf, 0x05);

    // <normal>
    // cqto   
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x99);

    // idivq (note: must be emitted by the user of this rule)
    // <done>
  %}

  // Encoding class for safepoint relocation info
  enc_class safepoint_reloc
  %{
    cbuf.relocate(cbuf.mark(), relocInfo::safepoint_type, RELOC_IMM64);
  %}

  // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
  enc_class OpcSE(immI imm) 
  %{
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= $imm$$constant && $imm$$constant < 0x80) {
      emit_opcode(cbuf, $primary | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, $primary);
    }
  %}

  enc_class OpcSErm(rRegI dst, immI imm)
  %{
    // OpcSEr/m
    int dstenc = $dst$$reg;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= $imm$$constant && $imm$$constant < 0x80) {
      emit_opcode(cbuf, $primary | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, $primary);
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, $secondary, dstenc);
  %}

  enc_class OpcSErm_wide(rRegL dst, immI imm)
  %{
    // OpcSEr/m
    int dstenc = $dst$$reg;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // Emit primary opcode and set sign-extend bit
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= $imm$$constant && $imm$$constant < 0x80) {
      emit_opcode(cbuf, $primary | 0x02);
    } else {
      // 32-bit immediate
      emit_opcode(cbuf, $primary);
    }
    // Emit r/m byte with secondary opcode, after primary opcode.
    emit_rm(cbuf, 0x3, $secondary, dstenc);
  %}

  enc_class Con8or32(immI imm)
  %{
    // Check for 8-bit immediate, and set sign extend bit in opcode
    if (-0x80 <= $imm$$constant && $imm$$constant < 0x80) {
      $$$emit8$imm$$constant;
    } else {
      // 32-bit immediate
      $$$emit32$imm$$constant;
    }
  %}

  enc_class Lbl(label labl)
  %{
    // JMP, CALL
    Label* l = $labl$$label;
    emit_d32(cbuf, l ? (l->offset() - (cbuf.code_size() + 4)) : 0);
  %}

  enc_class LblShort(label labl)
  %{ 
    // JMP, CALL
    Label* l = $labl$$label;
    emit_d8(cbuf, l ? (l->offset() - (cbuf.code_size() + 1)) : 0);
  %}

  enc_class reg_opc(rRegI div)
  %{
    // INC, DEC, IDIV, IMOD, JMP indirect, ...
    emit_rm(cbuf, 0x3, $secondary, $div$$reg & 7);
  %}

  enc_class Jcc(cmpOp cop, label labl)
  %{
    // JCC
    Label* l = $labl$$label;
    $$$emit8$primary;
    emit_cc(cbuf, $secondary, $cop$$cmpcode);
    emit_d32(cbuf, l ? (l->offset() - (cbuf.code_size() + 4)) : 0);
  %}

  enc_class JccShort (cmpOp cop, label labl)
  %{
  // JCC
    Label *l = $labl$$label;
    emit_cc(cbuf, $primary, $cop$$cmpcode);
    emit_d8(cbuf, l ? (l->offset() - (cbuf.code_size() + 1)) : 0);
  %}

  enc_class enc_cmov(cmpOp cop)
  %{
    // CMOV
    $$$emit8$primary;
    emit_cc(cbuf, $secondary, $cop$$cmpcode);
  %}

  enc_class enc_cmovf_branch(cmpOp cop, regF dst, regF src)
  %{
    // Invert sense of branch from sense of cmov
    emit_cc(cbuf, 0x70, $cop$$cmpcode ^ 1);
    emit_d8(cbuf, $dst$$reg < 8 && $src$$reg < 8 ? 4 : 5); // REX

    emit_opcode(cbuf, 0xF3);
    if ($dst$$reg < 8) {
      if ($src$$reg >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if ($src$$reg < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x10);
    emit_rm(cbuf, 0x3, $dst$$reg & 7, $src$$reg & 7);
  %}

  enc_class enc_cmovd_branch(cmpOp cop, regD dst, regD src)
  %{
    // Invert sense of branch from sense of cmov
    emit_cc(cbuf, 0x70, $cop$$cmpcode ^ 1);
    emit_d8(cbuf, $dst$$reg < 8 && $src$$reg < 8 ? 4 : 5); // REX

    emit_opcode(cbuf, 0xF2);
    if ($dst$$reg < 8) {
      if ($src$$reg >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if ($src$$reg < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x10);
    emit_rm(cbuf, 0x3, $dst$$reg & 7, $src$$reg & 7);
  %}

  enc_class enc_PartialSubtypeCheck()
  %{
    Register Rrdi = as_Register(RDI_enc); // result register
    Register Rrax = as_Register(RAX_enc); // super class
    Register Rrcx = as_Register(RCX_enc); // killed
    Register Rrsi = as_Register(RSI_enc); // sub class
    Label miss;

    MacroAssembler masm(&cbuf);
    masm.movq(Rrdi, 
              Address(Rrsi, 
                      sizeof(oopDesc) + 
                      Klass::secondary_supers_offset_in_bytes()));
    masm.movl(Rrcx, Address(Rrdi, arrayOopDesc::length_offset_in_bytes()));
    masm.addq(Rrdi, arrayOopDesc::base_offset_in_bytes(T_OBJECT));
    masm.repne_scan();
    masm.jcc(Assembler::notEqual, miss);
    masm.movq(Address(Rrsi, 
                      sizeof(oopDesc) + 
                      Klass::secondary_super_cache_offset_in_bytes()),
              Rrax);
    if ($primary) {
      masm.xorl(Rrdi, Rrdi);
    }
    masm.bind(miss);
  %}

  enc_class Java_To_Interpreter(method meth)
  %{
    // CALL Java_To_Interpreter
    // This is the instruction starting address for relocation info.
    cbuf.set_mark();
    $$$emit8$primary;
    // CALL directly to the runtime
    emit_d32_reloc(cbuf,
                   (int) ($meth$$method - ((intptr_t) cbuf.code_end()) - 4),
                   runtime_call_Relocation::spec(),
                   RELOC_DISP32);
  %}

  enc_class Java_Static_Call(method meth)
  %{
    // JAVA STATIC CALL
    // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
    // determine who we intended to call.
    cbuf.set_mark();
    $$$emit8$primary;

    if (!_method) {      
      emit_d32_reloc(cbuf,
                     (int) ($meth$$method - ((intptr_t) cbuf.code_end()) - 4),
                     runtime_call_Relocation::spec(),
                     RELOC_DISP32);
    } else if (_optimized_virtual) {
      emit_d32_reloc(cbuf,
                     (int) ($meth$$method - ((intptr_t) cbuf.code_end()) - 4),
                     opt_virtual_call_Relocation::spec(), 
                     RELOC_DISP32);
    } else {      
      emit_d32_reloc(cbuf,
                     (int) ($meth$$method - ((intptr_t) cbuf.code_end()) - 4),
                     static_call_Relocation::spec(),
                     RELOC_DISP32);
    }
    if (_method) {
      // Emit stub for static call
      emit_java_to_interp(cbuf);      
    }
  %}

  enc_class Java_Dynamic_Call(method meth)
  %{
    // JAVA DYNAMIC CALL
    // !!!!!
    // Generate  "movq rax, -1", placeholder instruction to load oop-info
    // emit_call_dynamic_prologue( cbuf );
    cbuf.set_mark();

    // movq rax, -1
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0xB8 | RAX_enc);
    emit_d64_reloc(cbuf, 
                   (int64_t) Universe::non_oop_word(),
                   oop_Relocation::spec_for_immediate(), RELOC_IMM64);
    address virtual_call_oop_addr = cbuf.mark();
    // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
    // who we intended to call.
    cbuf.set_mark();
    $$$emit8$primary;
    emit_d32_reloc(cbuf, 
                   (int) ($meth$$method - ((intptr_t) cbuf.code_end()) - 4),
                   virtual_call_Relocation::spec(virtual_call_oop_addr),
                   RELOC_DISP32);
  %}

  enc_class Java_Compiled_Call(method meth)
  %{
    // JAVA COMPILED CALL
    int disp = in_bytes(methodOopDesc::
                        from_compiled_code_entry_point_offset());

    // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
    // assert(-0x80 <= disp && disp < 0x80, "compiled_code_offset isn't small");

    // callq *disp(%rax)
    cbuf.set_mark();
    $$$emit8$primary;
    if (disp < 0x80) {
      emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
      emit_d8(cbuf, disp); // Displacement
    } else {
      emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
      emit_d32(cbuf, disp); // Displacement
    }
  %}

  enc_class reg_opc_imm(rRegI dst, immI8 shift)
  %{
    // SAL, SAR, SHR
    int dstenc = $dst$$reg;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    $$$emit8$primary;
    emit_rm(cbuf, 0x3, $secondary, dstenc);
    $$$emit8$shift$$constant;
  %}

  enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
  %{
    // SAL, SAR, SHR
    int dstenc = $dst$$reg;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    $$$emit8$primary;
    emit_rm(cbuf, 0x3, $secondary, dstenc);
    $$$emit8$shift$$constant;
  %}

  enc_class load_immI(rRegI dst, immI src)
  %{
    int dstenc = $dst$$reg;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    $$$emit32$src$$constant;
  %}

  enc_class load_immL(rRegL dst, immL src)
  %{
    int dstenc = $dst$$reg;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    emit_d64(cbuf, $src$$constant);
  %}

  enc_class load_immUL32(rRegL dst, immUL32 src)
  %{
    int dstenc = $dst$$reg;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    $$$emit32$src$$constant;
  %}

  enc_class load_immL32(rRegL dst, immL32 src)
  %{
    int dstenc = $dst$$reg;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xC7);
    emit_rm(cbuf, 0x03, 0x00, dstenc);
    $$$emit32$src$$constant;
  %}

  enc_class load_immP(rRegP dst, immP src)
  %{
    int dstenc = $dst$$reg;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    emit_opcode(cbuf, 0xB8 | dstenc);
    // This next line should be generated from ADLC
    if ($src->constant_is_oop()) {
      emit_d64_reloc(cbuf, $src$$constant, relocInfo::oop_type, RELOC_IMM64);
    } else {
      emit_d64(cbuf, $src$$constant);
    }
  %}

  enc_class load_imm_PC(rRegP dst, immI offset_to_call_return) 
  %{
    intptr_t off = MAX2(intptr_t(8), $offset_to_call_return$$method);
    // leaq off(%rip), $dst  // REX + Opcode + ModRM + Disp32 == 7 bytes
    int dstenc = $dst$$reg;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WR);
      dstenc -= 8;
    }
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_opcode(cbuf, 0x8D);
    emit_rm(cbuf, 0x0, dstenc, 0x5); // 00 reg 101
    // cbuf.mark() is beginning of instruction
    address pc = cbuf.mark() + off;
    emit_d32_reloc(cbuf, 
                   off - 7, 
                   internal_word_Relocation::spec(pc),
                   RELOC_DISP32);
  %}

  enc_class load_immF(regF dst, immF con)
  %{
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_rm(cbuf, 0x0, $dst$$reg & 7, 0x5); // 00 reg 101
    address float_address = cbuf.insert_float_constant($con$$constant);
    emit_d32_reloc(cbuf, 
                   (int) (float_address - cbuf.code_end() - 4),
                   internal_word_Relocation::spec(float_address),
                   RELOC_DISP32);
  %}

  enc_class load_immD(regD dst, immD con)
  %{
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_rm(cbuf, 0x0, $dst$$reg & 7, 0x5); // 00 reg 101
    address double_address = cbuf.insert_double_constant($con$$constant);
    emit_d32_reloc(cbuf, 
                   (int) (double_address - cbuf.code_end() - 4),
                   internal_word_Relocation::spec(double_address),
                   RELOC_DISP32);
  %}

  enc_class RetWithNops() 
  %{
    if (SafepointPolling) {
      emit_opcode(cbuf, $primary); // ret
    } else {
      // We need some extra room in the return instruction, so we can
      // patch it for the safepoint code. We need a total of 4 bytes.
      // Also, we need relocation info. so the return instructions can
      // be found easily
      // ret
      emit_opcode(cbuf, $primary, relocInfo::return_type, 1, RELOC_IMM64);
      // nop 
      emit_opcode(cbuf, 0x90);
      // nop 
      emit_opcode(cbuf, 0x90);
    }
  %}

  // Encode a reg-reg copy.  If it is useless, then empty encoding.
  enc_class enc_copy(rRegI dst, rRegI src)
  %{
    encode_copy(cbuf, $dst$$reg, $src$$reg);
  %}

  enc_class enc_copy_always(rRegI dst, rRegI src)
  %{
    int srcenc = $src$$reg;
    int dstenc = $dst$$reg;

    if (dstenc < 8) {
      if (srcenc >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
        srcenc -= 8;
      }
    } else {
      if (srcenc < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
        srcenc -= 8;
      }
      dstenc -= 8;
    }
    
    emit_opcode(cbuf, 0x8B);
    emit_rm(cbuf, 0x3, dstenc, srcenc);
  %}

  enc_class enc_copy_wide(rRegL dst, rRegL src)
  %{
    int srcenc = $src$$reg;
    int dstenc = $dst$$reg;
    
    if (dstenc != srcenc) {
      if (dstenc < 8) {
        if (srcenc < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WB);
          srcenc -= 8;
        }
      } else {
        if (srcenc < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRB);
          srcenc -= 8;
        }
        dstenc -= 8;
      }
      emit_opcode(cbuf, 0x8B);
      emit_rm(cbuf, 0x3, dstenc, srcenc);
    }
  %}

  enc_class Con32(immI src)
  %{
    // Output immediate
    $$$emit32$src$$constant;
  %}

  enc_class Con64(immL src)
  %{
    // Output immediate
    emit_d64($src$$constant);
  %}

  enc_class Con32F_as_bits(immF src)
  %{
    // Output Float immediate bits
    jfloat jf = $src$$constant;
    jint jf_as_bits = jint_cast(jf);
    emit_d32(cbuf, jf_as_bits);
  %}

  enc_class Con16(immI src)
  %{
    // Output immediate
    $$$emit16$src$$constant;
  %}

  // How is this different from Con32??? XXX
  enc_class Con_d32(immI src)
  %{
    emit_d32(cbuf,$src$$constant);
  %}

  enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
    // Output immediate memory reference
    emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
    emit_d32(cbuf, 0x00);
  %}

  enc_class lock_prefix()
  %{
    if (os::is_MP()) {
      emit_opcode(cbuf, 0xF0); // lock
    }
  %}

  enc_class REX_mem(memory mem)
  %{
    if ($mem$$base >= 8) {
      if ($mem$$index < 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      } else {
        emit_opcode(cbuf, Assembler::REX_XB);
      }
    } else {
      if ($mem$$index >= 8) {
        emit_opcode(cbuf, Assembler::REX_X);
      }
    }
  %}

  enc_class REX_mem_wide(memory mem)
  %{
    if ($mem$$base >= 8) {
      if ($mem$$index < 8) {
        emit_opcode(cbuf, Assembler::REX_WB);
      } else {
        emit_opcode(cbuf, Assembler::REX_WXB);
      }
    } else {
      if ($mem$$index < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WX);
      }
    }
  %}

  // for byte regs
  enc_class REX_breg(rRegI reg)
  %{
    if ($reg$$reg >= 4) {
      emit_opcode(cbuf, $reg$$reg < 8 ? Assembler::REX : Assembler::REX_B);
    }
  %}

  // for byte regs
  enc_class REX_reg_breg(rRegI dst, rRegI src)
  %{
    if ($dst$$reg < 8) {
      if ($src$$reg >= 4) {
        emit_opcode(cbuf, $src$$reg < 8 ? Assembler::REX : Assembler::REX_B);
      }
    } else {
      if ($src$$reg < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  %}

  // for byte regs
  enc_class REX_breg_mem(rRegI reg, memory mem)
  %{
    if ($reg$$reg < 8) {
      if ($mem$$base < 8) {
        if ($mem$$index >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        } else if ($reg$$reg >= 4) {
          emit_opcode(cbuf, Assembler::REX);
        }
      } else {
        if ($mem$$index < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if ($mem$$base < 8) {
        if ($mem$$index < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if ($mem$$index < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  %}

  enc_class REX_reg(rRegI reg)
  %{
    if ($reg$$reg >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
  %}

  enc_class REX_reg_wide(rRegI reg)
  %{
    if ($reg$$reg < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
    }
  %}

  enc_class REX_reg_reg(rRegI dst, rRegI src)
  %{
    if ($dst$$reg < 8) {
      if ($src$$reg >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if ($src$$reg < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
  %}

  enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
  %{
    if ($dst$$reg < 8) {
      if ($src$$reg < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if ($src$$reg < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
  %}

  enc_class REX_reg_mem(rRegI reg, memory mem)
  %{
    if ($reg$$reg < 8) {
      if ($mem$$base < 8) {
        if ($mem$$index >= 8) {
          emit_opcode(cbuf, Assembler::REX_X);
        }
      } else {
        if ($mem$$index < 8) {
          emit_opcode(cbuf, Assembler::REX_B);
        } else {
          emit_opcode(cbuf, Assembler::REX_XB);
        }
      }
    } else {
      if ($mem$$base < 8) {
        if ($mem$$index < 8) {
          emit_opcode(cbuf, Assembler::REX_R);
        } else {
          emit_opcode(cbuf, Assembler::REX_RX);
        }
      } else {
        if ($mem$$index < 8) {
          emit_opcode(cbuf, Assembler::REX_RB);
        } else {
          emit_opcode(cbuf, Assembler::REX_RXB);
        }
      }
    }
  %}

  enc_class REX_reg_mem_wide(rRegL reg, memory mem)
  %{
    if ($reg$$reg < 8) {
      if ($mem$$base < 8) {
        if ($mem$$index < 8) {
          emit_opcode(cbuf, Assembler::REX_W);
        } else {
          emit_opcode(cbuf, Assembler::REX_WX);
        }
      } else {
        if ($mem$$index < 8) {
          emit_opcode(cbuf, Assembler::REX_WB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WXB);
        }
      }
    } else {
      if ($mem$$base < 8) {
        if ($mem$$index < 8) {
          emit_opcode(cbuf, Assembler::REX_WR);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRX);
        }
      } else {
        if ($mem$$index < 8) {
          emit_opcode(cbuf, Assembler::REX_WRB);
        } else {
          emit_opcode(cbuf, Assembler::REX_WRXB);
        }
      }
    }
  %}

  enc_class reg_mem(rRegI ereg, memory mem) 
  %{
    // High registers handle in encode_RegMem
    int reg = $ereg$$reg;
    int base = $mem$$base;
    int index = $mem$$index;
    int scale = $mem$$scale;
    int disp = $mem$$disp;
    bool disp_is_oop = $mem->disp_is_oop();

    encode_RegMem(cbuf, reg, base, index, scale, disp, disp_is_oop);
  %}

  enc_class RM_opc_mem(immI rm_opcode, memory mem)
  %{
    int rm_byte_opcode = $rm_opcode$$constant;

    // High registers handle in encode_RegMem
    int base = $mem$$base;
    int index = $mem$$index;
    int scale = $mem$$scale;
    int displace = $mem$$disp;

    bool disp_is_oop = $mem->disp_is_oop(); // disp-as-oop when
                                            // working with static
                                            // globals
    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
                  disp_is_oop);
  %}

  enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
  %{
    int reg_encoding = $dst$$reg;
    int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
    int index        = 0x04;            // 0x04 indicates no index
    int scale        = 0x00;            // 0x00 indicates no scale
    int displace     = $src1$$constant; // 0x00 indicates no displacement
    bool disp_is_oop = false;
    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
                  disp_is_oop);
  %}

  enc_class neg_reg(rRegI dst)
  %{
    int dstenc = $dst$$reg;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    }
    // NEG $dst
    emit_opcode(cbuf, 0xF7);
    emit_rm(cbuf, 0x3, 0x03, dstenc);
  %}

  enc_class neg_reg_wide(rRegI dst)
  %{
    int dstenc = $dst$$reg;
    if (dstenc < 8) {
      emit_opcode(cbuf, Assembler::REX_W);
    } else {
      emit_opcode(cbuf, Assembler::REX_WB);
      dstenc -= 8;
    }
    // NEG $dst
    emit_opcode(cbuf, 0xF7);
    emit_rm(cbuf, 0x3, 0x03, dstenc);
  %}

  enc_class setLT_reg(rRegI dst)
  %{
    int dstenc = $dst$$reg;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    } else if (dstenc >= 4) {
      emit_opcode(cbuf, Assembler::REX);
    }
    // SETLT $dst
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x9C);
    emit_rm(cbuf, 0x3, 0x0, dstenc);
  %}

  enc_class setNZ_reg(rRegI dst)
  %{
    int dstenc = $dst$$reg;
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
      dstenc -= 8;
    } else if (dstenc >= 4) {
      emit_opcode(cbuf, Assembler::REX);
    }
    // SETNZ $dst
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x95);
    emit_rm(cbuf, 0x3, 0x0, dstenc);
  %}

  enc_class enc_cmpLTP(no_rcx_RegI p, no_rcx_RegI q, no_rcx_RegI y,
                       rcx_RegI tmp)
  %{
    // cadd_cmpLT

    // No way for the allocator to know about and set 'tmp' to RCX.
    // Instead I must use RCX explicitly
    int tmpReg = RCX_enc/*$tmp$$reg*/;

    int penc = $p$$reg;
    int qenc = $q$$reg;
    int yenc = $y$$reg;

    // subl $p,$q
    if (penc < 8) {
      if (qenc >= 8) {
        emit_opcode(cbuf, Assembler::REX_B);
      }
    } else {
      if (qenc < 8) {
        emit_opcode(cbuf, Assembler::REX_R);
      } else {
        emit_opcode(cbuf, Assembler::REX_RB);
      }
    }
    emit_opcode(cbuf, 0x2B);
    emit_rm(cbuf, 0x3, penc & 7, qenc & 7);

    // sbbl $tmp, $tmp
    emit_opcode(cbuf, 0x1B);
    emit_rm(cbuf, 0x3, tmpReg, tmpReg);

    // andl $tmp, $y
    if (yenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x23);
    emit_rm(cbuf, 0x3, tmpReg, yenc & 7);

    // addl $p,$tmp
    if (penc >= 8) {
        emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode(cbuf, 0x03);
    emit_rm(cbuf, 0x3, penc & 7, tmpReg);
  %}

  // Compare the lonogs and set -1, 0, or 1 into dst
  enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
  %{
    int src1enc = $src1$$reg;
    int src2enc = $src2$$reg;
    int dstenc = $dst$$reg;
    
    // cmpq $src1, $src2
    if (src1enc < 8) {
      if (src2enc < 8) {
        emit_opcode(cbuf, Assembler::REX_W);
      } else {
        emit_opcode(cbuf, Assembler::REX_WB);
      }
    } else {
      if (src2enc < 8) {
        emit_opcode(cbuf, Assembler::REX_WR);
      } else {
        emit_opcode(cbuf, Assembler::REX_WRB);
      }
    }
    emit_opcode(cbuf, 0x3B);
    emit_rm(cbuf, 0x3, src1enc & 7, src2enc & 7);

    // movl $dst, -1
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0xB8 | (dstenc & 7));
    emit_d32(cbuf, -1);

    // jl,s done
    emit_opcode(cbuf, 0x7C);
    emit_d8(cbuf, dstenc < 4 ? 0x06 : 0x08);

    // setne $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x95);
    emit_opcode(cbuf, 0xC0 | (dstenc & 7));

    // movzbl $dst, $dst
    if (dstenc >= 4) {
      emit_opcode(cbuf, dstenc < 8 ? Assembler::REX : Assembler::REX_RB);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0xB6);
    emit_rm(cbuf, 0x3, dstenc & 7, dstenc & 7);
  %}

  // obj: object to lock
  // box: box address (header location) 
  // RAX: killed tmp
  enc_class Fast_Lock(no_rax_RegP obj, no_rax_RegP box, rax_RegI tmp) 
  %{
    Register objReg = as_Register((int)$obj$$reg);
    Register boxReg = as_Register((int)$box$$reg);
    // Due to bug in the ADLC, I cannot use $tmp$$reg below.
    // Instead I must use RAX explicitly
    Register tmpReg = as_Register(RAX_enc/*$tmp$$reg*/);
    MacroAssembler masm(&cbuf);
    Label DONE_LABEL;

     // Regular locking case
//     masm.movq(tmpReg, Address(objReg));
//     masm.orq(tmpReg, 0x1);
    masm.movl(tmpReg, 0x1);
    masm.orq(tmpReg, Address(objReg));
    masm.movq(Address(boxReg), tmpReg);
    if (os::is_MP()) {
      masm.lock();
    }
    masm.cmpxchgq(boxReg, Address(objReg)); // Updates tmpReg
    masm.jcc(Assembler::equal, DONE_LABEL);
    
    // Recursive locking
    masm.subq(tmpReg, rsp);
    masm.andq(tmpReg, 7 - os::vm_page_size());
    masm.movq(Address(boxReg), tmpReg);

    masm.bind(DONE_LABEL); 
    masm.nop(); // avoid branch to branch
  %}

  // obj: object to unlock 
  // box: box address (displaced header location), killed
  // RBX: killed tmp; cannot be obj nor box
  enc_class Fast_Unlock(no_rax_rbx_RegP obj, rax_RegP box, rbx_RegP tmp)
  %{
    Label DONE_LABEL;
   
    Register objReg = as_Register($obj$$reg);
    Register boxReg = as_Register($box$$reg);
    // Due to bug in the ADLC, I cannot use $tmp$$reg below.
    // Instead I must use RBX explicitly
    Register tmpReg = as_Register(RBX_enc/*$tmp$$reg*/);
    MacroAssembler masm(&cbuf);

    // Check whether the displaced header is 0 
    //(=> recursive unlock)
    masm.movq(tmpReg, Address(boxReg));
    masm.testq(tmpReg, tmpReg);
    masm.jcc(Assembler::zero, DONE_LABEL);

    // If not recursive lock, reset the header to displaced header
    if (os::is_MP()) {
      masm.lock();
    }
    masm.cmpxchgq(tmpReg, Address(objReg)); // Uses RAX which is box
    masm.bind(DONE_LABEL);
    masm.nop(); // avoid branch to branch
  %}
  
  enc_class enc_String_Compare()
  %{
    Label RCX_GOOD_LABEL, LENGTH_DIFF_LABEL, 
	  POP_LABEL, DONE_LABEL, CONT_LABEL, 
	  WHILE_HEAD_LABEL;
    MacroAssembler masm(&cbuf);

    // Get the first character position in both strings
    //         [8] char array, [12] offset, [16] count
    int value_offset  = java_lang_String::value_offset_in_bytes();
    int offset_offset = java_lang_String::offset_offset_in_bytes();
    int count_offset  = java_lang_String::count_offset_in_bytes();
    int base_offset   = arrayOopDesc::base_offset_in_bytes(T_CHAR);

    masm.movq(rax, Address(rsi, value_offset));
    masm.movl(rcx, Address(rsi, offset_offset));
    masm.leaq(rax, Address(rax, rcx, Address::times_2, base_offset));
    masm.movq(rbx, Address(rdi, value_offset));
    masm.movl(rcx, Address(rdi, offset_offset));
    masm.leaq(rbx, Address(rbx, rcx, Address::times_2, base_offset));

    // Compute the minimum of the string lengths(rsi) and the
    // difference of the string lengths (stack)

    masm.movl(rdi, Address(rdi, count_offset));
    masm.movl(rsi, Address(rsi, count_offset));
    masm.movl(rcx, rdi);
    masm.subl(rdi, rsi);
    masm.pushq(rdi);
    masm.cmovl(Assembler::lessEqual, rsi, rcx);
    		
    // Is the minimum length zero?
    masm.bind(RCX_GOOD_LABEL);
    masm.testl(rsi, rsi);
    masm.jcc(Assembler::zero, LENGTH_DIFF_LABEL);
    
    // Load first characters
    masm.load_unsigned_word(rcx, Address(rbx));
    masm.load_unsigned_word(rdi, Address(rax));
    
    // Compare first characters
    masm.subl(rcx, rdi);
    masm.jcc(Assembler::notZero,  POP_LABEL);
    masm.decl(rsi);
    masm.jcc(Assembler::zero, LENGTH_DIFF_LABEL);

    {
      // Check after comparing first character to see if strings are equivalent
      Label LSkip2;
      // Check if the strings start at same location
      masm.cmpq(rbx, rax);
      masm.jcc(Assembler::notEqual, LSkip2);
    
      // Check if the length difference is zero (from stack)
      masm.cmpl(Address(rsp), 0x0);
      masm.jcc(Assembler::equal,  LENGTH_DIFF_LABEL);

      // Strings might not be equivalent
      masm.bind(LSkip2);
    }

    // Shift RAX and RBX to the end of the arrays, negate min
    masm.leaq(rax, Address(rax, rsi, Address::times_2, 2));
    masm.leaq(rbx, Address(rbx, rsi, Address::times_2, 2));
    masm.negq(rsi);

    // Compare the rest of the characters
    masm.bind(WHILE_HEAD_LABEL);
    masm.load_unsigned_word(rcx, Address(rbx, rsi, Address::times_2, 0));
    masm.load_unsigned_word(rdi, Address(rax, rsi, Address::times_2, 0));
    masm.subl(rcx, rdi);
    masm.jcc(Assembler::notZero, POP_LABEL);
    masm.incq(rsi);
    masm.jcc(Assembler::notZero, WHILE_HEAD_LABEL);
    
    // Strings are equal up to min length.  Return the length difference.
    masm.bind(LENGTH_DIFF_LABEL);
    masm.popq(rcx);
    masm.jmp(DONE_LABEL);

    // Discard the stored length difference
    masm.bind(POP_LABEL);
    masm.addq(rsp, 8);
       
    // That's it
    masm.bind(DONE_LABEL);
  %}

  enc_class enc_rethrow()
  %{
    cbuf.set_mark();
    emit_opcode(cbuf, 0xE9); // jmp entry
    emit_d32_reloc(cbuf, 
                   (int) (OptoRuntime::rethrow_stub() - cbuf.code_end() - 4), 
                   runtime_call_Relocation::spec(),
                   RELOC_DISP32);
  %}

  enc_class absF_encoding(regF dst)
  %{
    int dstenc = $dst$$reg;
    address signmask_address = (address) StubRoutines::amd64::float_sign_mask();

    cbuf.set_mark();
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
      dstenc -= 8;
    }
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x54);
    emit_rm(cbuf, 0x0, dstenc, 0x5);  // 00 reg 101
    emit_d32_reloc(cbuf, 
                   (int) (signmask_address - cbuf.code_end() - 4),
                   relocInfo::external_word_type,
                   RELOC_DISP32);
  %}

  enc_class absD_encoding(regD dst)
  %{
    int dstenc = $dst$$reg;
    address signmask_address = (address) StubRoutines::amd64::double_sign_mask();

    cbuf.set_mark();
    emit_opcode(cbuf, 0x66);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
      dstenc -= 8;
    }
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x54);
    emit_rm(cbuf, 0x0, dstenc, 0x5);  // 00 reg 101
    emit_d32_reloc(cbuf, 
                   (int) (signmask_address - cbuf.code_end() - 4),
                   relocInfo::external_word_type,
                   RELOC_DISP32);
  %}

  enc_class negF_encoding(regF dst)
  %{
    int dstenc = $dst$$reg;
    address signflip_address = (address) StubRoutines::amd64::float_sign_flip();

    cbuf.set_mark();
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
      dstenc -= 8;
    }
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x57);
    emit_rm(cbuf, 0x0, dstenc, 0x5);  // 00 reg 101
    emit_d32_reloc(cbuf, 
                   (int) (signflip_address - cbuf.code_end() - 4),
                   relocInfo::external_word_type,
                   RELOC_DISP32);
  %}

  enc_class negD_encoding(regD dst)
  %{
    int dstenc = $dst$$reg;
    address signflip_address = (address) StubRoutines::amd64::double_sign_flip();

    cbuf.set_mark();
    emit_opcode(cbuf, 0x66);
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
      dstenc -= 8;
    }
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x57);
    emit_rm(cbuf, 0x0, dstenc, 0x5);  // 00 reg 101
    emit_d32_reloc(cbuf, 
                   (int) (signflip_address - cbuf.code_end() - 4),
                   relocInfo::external_word_type,
                   RELOC_DISP32);
  %}

  enc_class f2i_fixup(rRegI dst, regF src)
  %{
    int dstenc = $dst$$reg;
    int srcenc = $src$$reg;

    // cmpl $dst, #0x80000000
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x81);
    emit_rm(cbuf, 0x3, 0x7, dstenc & 7);
    emit_d32(cbuf, 0x80000000);

    // jne,s done
    emit_opcode(cbuf, 0x75);
    if (srcenc < 8 && dstenc < 8) {
      emit_d8(cbuf, 0xF);
    } else if (srcenc >= 8 && dstenc >= 8) {
      emit_d8(cbuf, 0x11);
    } else {
      emit_d8(cbuf, 0x10);
    }

    // subq rsp, #8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x5, RSP_enc);
    emit_d8(cbuf, 8);

    // movss [rsp], $src
    emit_opcode(cbuf, 0xF3);
    if (srcenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x11);
    encode_RegMem(cbuf, srcenc, RSP_enc, 0x4, 0, 0, false); // 2 bytes

    // call f2i_fixup
    cbuf.set_mark();
    emit_opcode(cbuf, 0xE8);
    emit_d32_reloc(cbuf,
                   (int) 
                   (StubRoutines::amd64::f2i_fixup() - cbuf.code_end() - 4),
                   runtime_call_Relocation::spec(),
                   RELOC_DISP32);

    // popq $dst
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x58 | (dstenc & 7));

    // done:
  %}

  enc_class f2l_fixup(rRegL dst, regF src)
  %{
    int dstenc = $dst$$reg;
    int srcenc = $src$$reg;
    address const_address = (address) StubRoutines::amd64::double_sign_flip();

    // cmpq $dst, [0x8000000000000000]
    cbuf.set_mark();
    emit_opcode(cbuf, dstenc < 8 ? Assembler::REX_W : Assembler::REX_WR);
    emit_opcode(cbuf, 0x39);
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_rm(cbuf, 0x0, dstenc & 7, 0x5); // 00 reg 101
    emit_d32_reloc(cbuf, 
                   (int) (const_address - cbuf.code_end() - 4),
                   relocInfo::external_word_type,
                   RELOC_DISP32);


    // jne,s done
    emit_opcode(cbuf, 0x75);
    if (srcenc < 8 && dstenc < 8) {
      emit_d8(cbuf, 0xF);
    } else if (srcenc >= 8 && dstenc >= 8) {
      emit_d8(cbuf, 0x11);
    } else {
      emit_d8(cbuf, 0x10);
    }

    // subq rsp, #8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x5, RSP_enc);
    emit_d8(cbuf, 8);

    // movss [rsp], $src
    emit_opcode(cbuf, 0xF3);
    if (srcenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x11);
    encode_RegMem(cbuf, srcenc, RSP_enc, 0x4, 0, 0, false); // 2 bytes

    // call f2l_fixup
    cbuf.set_mark();
    emit_opcode(cbuf, 0xE8);
    emit_d32_reloc(cbuf,
                   (int) 
                   (StubRoutines::amd64::f2l_fixup() - cbuf.code_end() - 4),
                   runtime_call_Relocation::spec(),
                   RELOC_DISP32);

    // popq $dst
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x58 | (dstenc & 7));

    // done:
  %}

  enc_class d2i_fixup(rRegI dst, regD src)
  %{
    int dstenc = $dst$$reg;
    int srcenc = $src$$reg;

    // cmpl $dst, #0x80000000
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x81);
    emit_rm(cbuf, 0x3, 0x7, dstenc & 7);
    emit_d32(cbuf, 0x80000000);

    // jne,s done
    emit_opcode(cbuf, 0x75);
    if (srcenc < 8 && dstenc < 8) {
      emit_d8(cbuf, 0xF);
    } else if (srcenc >= 8 && dstenc >= 8) {
      emit_d8(cbuf, 0x11);
    } else {
      emit_d8(cbuf, 0x10);
    }

    // subq rsp, #8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x5, RSP_enc);
    emit_d8(cbuf, 8);

    // movsd [rsp], $src
    emit_opcode(cbuf, 0xF2);
    if (srcenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x11);
    encode_RegMem(cbuf, srcenc, RSP_enc, 0x4, 0, 0, false); // 2 bytes

    // call d2i_fixup
    cbuf.set_mark();
    emit_opcode(cbuf, 0xE8);
    emit_d32_reloc(cbuf,
                   (int) 
                   (StubRoutines::amd64::d2i_fixup() - cbuf.code_end() - 4),
                   runtime_call_Relocation::spec(),
                   RELOC_DISP32);

    // popq $dst
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x58 | (dstenc & 7));

    // done:
  %}

  enc_class d2l_fixup(rRegL dst, regD src)
  %{
    int dstenc = $dst$$reg;
    int srcenc = $src$$reg;
    address const_address = (address) StubRoutines::amd64::double_sign_flip();

    // cmpq $dst, [0x8000000000000000]
    cbuf.set_mark();
    emit_opcode(cbuf, dstenc < 8 ? Assembler::REX_W : Assembler::REX_WR);
    emit_opcode(cbuf, 0x39);
    // XXX reg_mem doesn't support RIP-relative addressing yet
    emit_rm(cbuf, 0x0, dstenc & 7, 0x5); // 00 reg 101
    emit_d32_reloc(cbuf, 
                   (int) (const_address - cbuf.code_end() - 4),
                   relocInfo::external_word_type,
                   RELOC_DISP32);


    // jne,s done
    emit_opcode(cbuf, 0x75);
    if (srcenc < 8 && dstenc < 8) {
      emit_d8(cbuf, 0xF);
    } else if (srcenc >= 8 && dstenc >= 8) {
      emit_d8(cbuf, 0x11);
    } else {
      emit_d8(cbuf, 0x10);
    }

    // subq rsp, #8
    emit_opcode(cbuf, Assembler::REX_W);
    emit_opcode(cbuf, 0x83);
    emit_rm(cbuf, 0x3, 0x5, RSP_enc);
    emit_d8(cbuf, 8);

    // movsd [rsp], $src
    emit_opcode(cbuf, 0xF2);
    if (srcenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_R);
    }
    emit_opcode(cbuf, 0x0F);
    emit_opcode(cbuf, 0x11);
    encode_RegMem(cbuf, srcenc, RSP_enc, 0x4, 0, 0, false); // 2 bytes

    // call d2l_fixup
    cbuf.set_mark();
    emit_opcode(cbuf, 0xE8);
    emit_d32_reloc(cbuf,
                   (int) 
                   (StubRoutines::amd64::d2l_fixup() - cbuf.code_end() - 4),
                   runtime_call_Relocation::spec(),
                   RELOC_DISP32);

    // popq $dst
    if (dstenc >= 8) {
      emit_opcode(cbuf, Assembler::REX_B);
    }
    emit_opcode(cbuf, 0x58 | (dstenc & 7));

    // done:
  %}

  enc_class enc_membar_acquire
  %{
    // [jk] not needed currently, if you enable this and it really
    // emits code don't forget to the remove the "size(0)" line in
    // membar_acquire()
    // MacroAssembler masm(&cbuf);
    // masm.membar(Assembler::Membar_mask_bits(Assembler::LoadStore | 
    //                                         Assembler::LoadLoad));
  %}

  enc_class enc_membar_release
  %{
    // [jk] not needed currently, if you enable this and it really
    // emits code don't forget to the remove the "size(0)" line in
    // membar_release()
    // MacroAssembler masm(&cbuf);
    // masm.membar(Assembler::Membar_mask_bits(Assembler::LoadStore |
    //                                         Assembler::StoreStore));
  %}

  enc_class enc_membar_volatile
  %{
    MacroAssembler masm(&cbuf);
    masm.membar(Assembler::Membar_mask_bits(Assembler::StoreLoad |
                                            Assembler::StoreStore));
  %}

  // Safepoint Poll.  This polls the safepoint page, and causes an
  // exception if it is not readable. Unfortunately, it kills
  // RFLAGS in the process.
  enc_class enc_safepoint_poll
  %{
    // testl %rax, off(%rip) // Opcode + ModRM + Disp32 == 6 bytes
    // XXX reg_mem doesn't support RIP-relative addressing yet
    cbuf.set_mark();
    cbuf.relocate(cbuf.mark(), relocInfo::poll_type, 0); // XXX
    emit_opcode(cbuf, 0x85); // testl
    emit_rm(cbuf, 0x0, RAX_enc, 0x5); // 00 rax 101 == 0x5
    // cbuf.mark() is beginning of instruction
    emit_d32_reloc(cbuf, 
                   (int) (((intptr_t) os::get_polling_page()) - 
                          ((intptr_t) cbuf.code_end()) - 4),
                   relocInfo::external_word_type, // XXX
//                    relocInfo::poll_type, 
                   RELOC_DISP32);
  %}
%}


//----------FRAME--------------------------------------------------------------
// Definition of frame structure and management information.
//
//  S T A C K   L A Y O U T    Allocators stack-slot number
//                             |   (to get allocators register number
//  G  Owned by    |        |  v    add SharedInfo::stack0)
//  r   CALLER     |        |
//  o     |        +--------+      pad to even-align allocators stack-slot 
//  w     V        |  pad0  |        numbers; owned by CALLER
//  t   -----------+--------+----> Matcher::_in_arg_limit, unaligned
//  h     ^        |   in   |  5   
//        |        |  args  |  4   Holes in incoming args owned by SELF
//  |     |        |        |  3
//  |     |        +--------+
//  V     |        | old out|      Empty on Intel, window on Sparc
//        |    old |preserve|      Must be even aligned.
//        |     SP-+--------+----> Matcher::_old_SP, even aligned
//        |        |   in   |  3   area for Intel ret address
//     Owned by    |preserve|      Empty on Sparc.
//       SELF      +--------+
//        |        |  pad2  |  2   pad to align old SP
//        |        +--------+  1
//        |        | locks  |  0
//        |        +--------+----> SharedInfo::stack0, even aligned  
//        |        |  pad1  | 11   pad to align new SP
//        |        +--------+
//        |        |        | 10
//        |        | spills |  9   spills
//        V        |        |  8   (pad0 slot for callee)
//      -----------+--------+----> Matcher::_out_arg_limit, unaligned
//        ^        |  out   |  7   
//        |        |  args  |  6   Holes in outgoing args owned by CALLEE
//     Owned by    +--------+
//      CALLEE     | new out|  6   Empty on Intel, window on Sparc
//        |    new |preserve|      Must be even-aligned.
//        |     SP-+--------+----> Matcher::_new_SP, even aligned
//        |        |        |
//
// Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is 
//         known from SELF's arguments and the Java calling convention.
//         Region 6-7 is determined per call site.
// Note 2: If the calling convention leaves holes in the incoming argument 
//         area, those holes are owned by SELF.  Holes in the outgoing area
//         are owned by the CALLEE.  Holes should not be nessecary in the
//         incoming area, as the Java calling convention is completely under
//         the control of the AD file.  Doubles can be sorted and packed to
//         avoid holes.  Holes in the outgoing arguments may be nessecary for
//         varargs C calling conventions.
// Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is 
//         even aligned with pad0 as needed.
//         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
//         region 6-11 is even aligned; it may be padded out more so that
//         the region from SP to FP meets the minimum stack alignment.
// Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
//         alignment.  Region 11, pad1, may be dynamically extended so that
//         SP meets the minimum alignment.

frame
%{
  // What direction does stack grow in (assumed to be same for C & Java)
  stack_direction(TOWARDS_LOW);

  // These three registers define part of the calling convention 
  // between compiled code and the interpreter.
  inline_cache_reg(RAX);                // Inline Cache Register or
                                        // methodOop for I2C
  interpreter_arg_ptr_reg(RBX);         // Argument pointer for I2C adapters
  compiler_method_oop_reg(RCX);         // Temporary in compiled entry-points
  interpreter_method_oop_reg(RBX);      // Method Oop Register when
                                        // calling interpreter

  // Optional: name the operand used by cisc-spilling to access
  // [stack_pointer + offset]
  cisc_spilling_operand_name(indOffset32);  

  // Number of stack slots consumed by locking an object
  sync_stack_slots(2);

  // Compiled code's Frame Pointer
  frame_pointer(RSP);

  // Interpreter stores its frame pointer in a register which is 
  // stored to the stack by I2CAdaptors.
  // I2CAdaptors convert from interpreted java to compiled java.
  interpreter_frame_pointer(RBP);

  // Stack alignment requirement
  stack_alignment(7); // Log of alignment size in bits (128-bit -> 7)

  // Number of stack slots between incoming argument block and the start of 
  // a new frame.  The PROLOG must add this many slots to the stack.  The
  // EPILOG must remove this many slots.  amd64 needs two slots for
  // return address.
  in_preserve_stack_slots(2 + 2 * VerifyStackAtCalls);

  // Number of stack slots reserved just above SELF's SP.
  // After a call, these remain between outgoing parameters and callee's frame.
  out_preserve_stack_slots(0);

  // Number of outgoing stack slots killed above the out_preserve_stack_slots
  // for calls to C.  Supports the var-args backing area for register parms.
  varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);

  // The after-PROLOG location of the return address.  Location of
  // return address specifies a type (REG or STACK) and a number
  // representing the register number (i.e. - use a register name) or
  // stack slot.
  // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
  // Otherwise, it is above the locks and verification slot and alignment word
  return_addr(STACK - 2 + 
              round_to(2 + 2 * VerifyStackAtCalls + 
                       Compile::current()->sync() * 
                       Compile::current()->sync_stack_slots(),
                       WordsPerLong * 2));

  // Body of function which returns an integer array locating
  // arguments either in registers or in stack slots.  Passed an array
  // of ideal registers called "sig" and a "length" count.  Stack-slot
  // offsets are based on outgoing arguments, i.e. a CALLER setting up
  // arguments for a CALLEE.  Incoming stack arguments are
  // automatically biased by the preserve_stack_slots field above.

  calling_convention 
  %{
#ifdef _WIN64
    static const MachRegisterNumbers INT_ArgReg[Argument::n_int_register_parameters] = {
      RCX_num, RDX_num, R8_num, R9_num
    };
    static const MachRegisterNumbers FP_ArgReg[Argument::n_float_register_parameters] = {
      XMM0_num, XMM1_num, XMM2_num, XMM3_num
    };
#else
//     static const MachRegisterNumbers INT_ArgReg[Argument::n_int_register_parameters] = {
//       RDI_num, RSI_num, RDX_num, RCX_num, R8_num, R9_num
//     };
    static const MachRegisterNumbers INT_ArgReg[Argument::n_int_register_parameters] = {
      RCX_num, RDX_num, RDI_num, RSI_num, R8_num, R9_num
    };
    static const MachRegisterNumbers FP_ArgReg[Argument::n_float_register_parameters] = {
      XMM0_num, XMM1_num, XMM2_num, XMM3_num,
      XMM4_num, XMM5_num, XMM6_num, XMM7_num
    };
#endif // _WIN64

    uint int_args = 0;
    uint fp_args = 0;
    uint stk_args = 0; // inc by 2 each time

    for (uint i = 0; i < length; i++) {
      switch (sig[i].ideal_reg()) {
      case Op_RegI:
        if (int_args < Argument::n_int_register_parameters) {
          sig[i].set1(INT_ArgReg[int_args++]);
        } else {
          sig[i].set1(SharedInfo::stack2reg(stk_args));
          stk_args += 2;
        }
        break;
      case Op_RegL:
        assert(sig[i + 1].ideal_reg() == 0, "expecting half");
        // fall through
      case Op_RegP:
        if (int_args < Argument::n_int_register_parameters) {
          sig[i].set2(INT_ArgReg[int_args++]);
        } else {
          sig[i].set2(SharedInfo::stack2reg(stk_args));
          stk_args += 2;
        }
        break;
      case Op_RegF:
        if (fp_args < Argument::n_float_register_parameters) {
          sig[i].set1(FP_ArgReg[fp_args++]);
        } else {
          sig[i].set1(SharedInfo::stack2reg(stk_args));
          stk_args += 2;
        }
        break;
      case Op_RegD:
        assert(sig[i + 1].ideal_reg() == 0, "expecting half");
        if (fp_args < Argument::n_float_register_parameters) {
          sig[i].set2(FP_ArgReg[fp_args++]);
        } else {
          sig[i].set2(SharedInfo::stack2reg(stk_args));
          stk_args += 2;
        }
        break;
      case 0: // Halves of longs and doubles
        sig[i].set_bad();
        break;
      default:
        ShouldNotReachHere();
        break;
      }
    }
  %}

  c_calling_convention 
  %{
#ifdef _WIN64
    static const MachRegisterNumbers INT_ArgReg[Argument::n_int_register_parameters] = {
      RCX_num, RDX_num, R8_num, R9_num
    };
    static const MachRegisterNumbers FP_ArgReg[Argument::n_float_register_parameters] = {
      XMM0_num, XMM1_num, XMM2_num, XMM3_num
    };
#else
    static const MachRegisterNumbers INT_ArgReg[Argument::n_int_register_parameters] = {
      RDI_num, RSI_num, RDX_num, RCX_num, R8_num, R9_num
    };
    static const MachRegisterNumbers FP_ArgReg[Argument::n_float_register_parameters] = {
      XMM0_num, XMM1_num, XMM2_num, XMM3_num,
      XMM4_num, XMM5_num, XMM6_num, XMM7_num
    };
#endif // _WIN64

    uint int_args = 0;
    uint fp_args = 0;
    uint stk_args = 0; // inc by 2 each time

    for (uint i = 0; i < length; i++) {
      switch (sig[i].ideal_reg()) {
      case Op_RegI:
        if (int_args < Argument::n_int_register_parameters) {
          sig[i].set1(INT_ArgReg[int_args++]);
#ifdef _WIN64
          fp_args++;
          stk_args += 2;
#endif
        } else {
          sig[i].set1(SharedInfo::stack2reg(stk_args));
          stk_args += 2;
        }
        break;
      case Op_RegL:
        assert(sig[i + 1].ideal_reg() == 0, "expecting half");
        // fall through
      case Op_RegP:
        if (int_args < Argument::n_int_register_parameters) {
          sig[i].set2(INT_ArgReg[int_args++]);
#ifdef _WIN64
          fp_args++;
          stk_args += 2;
#endif
        } else {
          sig[i].set2(SharedInfo::stack2reg(stk_args));
          stk_args += 2;
        }
        break;
      case Op_RegF:
        if (fp_args < Argument::n_float_register_parameters) {
          sig[i].set1(FP_ArgReg[fp_args++]);
#ifdef _WIN64
          int_args++;
          stk_args += 2;
#endif
        } else {
          sig[i].set1(SharedInfo::stack2reg(stk_args));
          stk_args += 2;
        }
        break;
      case Op_RegD:
        assert(sig[i + 1].ideal_reg() == 0, "expecting half");
        if (fp_args < Argument::n_float_register_parameters) {
          sig[i].set2(FP_ArgReg[fp_args++]);
#ifdef _WIN64
          int_args++;
          stk_args += 2;
#endif
        } else {
          sig[i].set2(SharedInfo::stack2reg(stk_args));
          stk_args += 2;
        }
        break;
      case 0: // Halves of longs and doubles
        sig[i].set_bad();
        break;
      default:
        ShouldNotReachHere();
        break;
      }
    }
  %}

  // Location of compiled Java return values.  Same as C for now.
  return_value 
  %{
    assert(ideal_reg >= Op_RegI && ideal_reg <= Op_RegL,
           "only return normal values");

    static const int lo[Op_RegL + 1] = { 
      0, 
      0, 
      RAX_num,  // Op_RegI
      RAX_num,  // Op_RegP
      XMM0_num, // Op_RegF
      XMM0_num, // Op_RegD
      RAX_num   // Op_RegL
    };
    static const int hi[Op_RegL + 1] = { 
      0, 
      0,
      OptoReg::Bad, // Op_RegI
      RAX_H_num,    // Op_RegP
      OptoReg::Bad, // Op_RegF
      XMM0_H_num,   // Op_RegD
      RAX_H_num     // Op_RegL
    };

    return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
  %}
%}

//----------ATTRIBUTES---------------------------------------------------------
//----------Operand Attributes-------------------------------------------------
op_attrib op_cost(0);        // Required cost attribute

//----------Instruction Attributes---------------------------------------------
ins_attrib ins_cost(100);       // Required cost attribute
ins_attrib ins_size(8);         // Required size attribute (in bits)
ins_attrib ins_pc_relative(0);  // Required PC Relative flag
ins_attrib ins_short_branch(0); // Required flag: is this instruction
                                // a non-matching short branch variant
                                // of some long branch?
ins_attrib ins_alignment(1);    // Required alignment attribute (must
                                // be a power of 2) specifies the
                                // alignment that some part of the
                                // instruction (not necessarily the
                                // start) requires.  If > 1, a
                                // compute_padding() function must be
                                // provided for the instruction

//----------OPERANDS-----------------------------------------------------------
// Operand definitions must precede instruction definitions for correct parsing
// in the ADLC because operands constitute user defined types which are used in
// instruction definitions.

//----------Simple Operands----------------------------------------------------
// Immediate Operands
// Integer Immediate
operand immI()
%{
  match(ConI);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for test vs zero
operand immI0()
%{
  predicate(n->get_int() == 0);
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for increment
operand immI1()
%{
  predicate(n->get_int() == 1);
  match(ConI);

  format %{ %}
  interface(CONST_INTER);
%}

// Constant for decrement
operand immI_M1()
%{
  predicate(n->get_int() == -1);
  match(ConI);

  format %{ %}
  interface(CONST_INTER);
%}

// Valid scale values for addressing modes
operand immI2()
%{
  predicate(0 <= n->get_int() && (n->get_int() <= 3));
  match(ConI);

  format %{ %}
  interface(CONST_INTER);
%}

operand immI8()
%{
  predicate((-0x80 <= n->get_int()) && (n->get_int() < 0x80));
  match(ConI);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

operand immI16()
%{
  predicate((-32768 < n->get_int()) && (n->get_int() < 32767));
  match(ConI);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for long shifts
operand immI_32()
%{
  predicate( n->get_int() == 32 );
  match(ConI);

  format %{ %}
  interface(CONST_INTER);
%}

// Pointer Immediate
operand immP()
%{
  match(ConP);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

// NULL Pointer Immediate
operand immP0()
%{
  predicate(n->get_ptr() == 0);
  match(ConP);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate
operand immL()
%{
  match(ConL);

  op_cost(20);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate 8-bit
operand immL8()
%{
  predicate(-0x80L <= n->get_long() && n->get_long() < 0x80L);
  match(ConL);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate 32-bit unsigned
operand immUL32()
%{
  predicate(n->get_long() == (unsigned int) (n->get_long()));
  match(ConL);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate 32-bit signed
operand immL32()
%{
  predicate(n->get_long() == (int) (n->get_long()));
  match(ConL);

  op_cost(15);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate zero
operand immL0()
%{
  predicate(n->get_long() == 0L);
  match(ConL);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

// Constant for increment
operand immL1()
%{
  predicate(n->get_long() == 1);
  match(ConL);

  format %{ %}
  interface(CONST_INTER);
%}

// Constant for decrement
operand immL_M1()
%{
  predicate(n->get_long() == -1);
  match(ConL);

  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate: the value 10
operand immL10()
%{
  predicate(n->get_long() == 10);
  match(ConL);

  format %{ %}
  interface(CONST_INTER);
%}

// Long immediate from 0 to 127.
// Used for a shorter form of long mul by 10.
operand immL_127()
%{
  predicate(0 <= n->get_long() && n->get_long() < 0x80);
  match(ConL);

  op_cost(10);
  format %{ %}
  interface(CONST_INTER);
%}

// Long Immediate: low 32-bit mask
operand immL_32bits()
%{
  predicate(n->get_long() == 0xFFFFFFFFL);
  match(ConL);
  op_cost(20);

  format %{ %}
  interface(CONST_INTER);
%}

// Float Immediate zero
operand immF0()
%{
  predicate(jint_cast(n->getf()) == 0);
  match(ConF);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Float Immediate
operand immF()
%{
  match(ConF);

  op_cost(15);
  format %{ %}
  interface(CONST_INTER);
%}

// Double Immediate zero
operand immD0()
%{
  predicate(jlong_cast(n->getd()) == 0);
  match(ConD);

  op_cost(5);
  format %{ %}
  interface(CONST_INTER);
%}

// Double Immediate
operand immD()
%{
  match(ConD);

  op_cost(15);
  format %{ %}
  interface(CONST_INTER);
%}

// Immediates for special shifts (sign extend)

// Constants for increment
operand immI_16()
%{
  predicate(n->get_int() == 16);
  match(ConI);

  format %{ %}
  interface(CONST_INTER);
%}

operand immI_24()
%{
  predicate(n->get_int() == 24);
  match(ConI);

  format %{ %}
  interface(CONST_INTER);
%}

// Constant for byte-wide masking
operand immI_255()
%{
  predicate(n->get_int() == 255);
  match(ConI);

  format %{ %}
  interface(CONST_INTER);
%}

// Constant for short-wide masking
operand immI_65535()
%{
  predicate(n->get_int() == 65535);
  match(ConI);

  format %{ %}
  interface(CONST_INTER);
%}

// Constant for byte-wide masking
operand immL_255()
%{
  predicate(n->get_long() == 255);
  match(ConL);

  format %{ %}
  interface(CONST_INTER);
%}

// Constant for short-wide masking
operand immL_65535()
%{
  predicate(n->get_long() == 65535);
  match(ConL);

  format %{ %}
  interface(CONST_INTER);
%}

// Register Operands
// Integer Register
operand rRegI() 
%{
  constraint(ALLOC_IN_RC(int_reg));
  match(RegI);

  match(rax_RegI);
  match(rbx_RegI);
  match(rcx_RegI);
  match(rdx_RegI);
  match(rdi_RegI);

  format %{ %}
  interface(REG_INTER);
%}

// Special Registers
operand rax_RegI()
%{
  constraint(ALLOC_IN_RC(int_rax_reg));
  match(RegI);
  match(rRegI);

  format %{ "RAX" %}
  interface(REG_INTER);
%}

// Special Registers
operand rbx_RegI()
%{
  constraint(ALLOC_IN_RC(int_rbx_reg));
  match(RegI);
  match(rRegI);

  format %{ "RBX" %}
  interface(REG_INTER);
%}

operand rcx_RegI()
%{
  constraint(ALLOC_IN_RC(int_rcx_reg));
  match(RegI);
  match(rRegI);

  format %{ "RCX" %}
  interface(REG_INTER);
%}

operand rdx_RegI()
%{
  constraint(ALLOC_IN_RC(int_rdx_reg));
  match(RegI);
  match(rRegI);

  format %{ "RDX" %}
  interface(REG_INTER);
%}

operand rdi_RegI()
%{
  constraint(ALLOC_IN_RC(int_rdi_reg));
  match(RegI);
  match(rRegI);

  format %{ "RDI" %}
  interface(REG_INTER);
%}

operand no_rcx_RegI()
%{
  constraint(ALLOC_IN_RC(int_no_rcx_reg));
  match(RegI);
  match(rax_RegI);
  match(rbx_RegI);
  match(rdx_RegI);
  match(rdi_RegI);

  format %{ %}
  interface(REG_INTER);
%}

operand no_rax_rdx_RegI()
%{
  constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
  match(RegI);
  match(rbx_RegI);
  match(rcx_RegI);
  match(rdi_RegI);

  format %{ %}
  interface(REG_INTER);
%}

// Pointer Register
operand any_RegP()
%{
  constraint(ALLOC_IN_RC(any_reg));
  match(RegP);
  match(rax_RegP);
  match(rbx_RegP);
  match(rdi_RegP);
  match(rsi_RegP);
  match(rbp_RegP);
  match(rRegP);

  format %{ %}
  interface(REG_INTER);
%}

operand rRegP()
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(RegP);
  match(rax_RegP);
  match(rbx_RegP);
  match(rdi_RegP);
  match(rsi_RegP);
  match(rbp_RegP);

  format %{ %}
  interface(REG_INTER);
%}

operand no_rax_RegP()
%{
  constraint(ALLOC_IN_RC(ptr_no_rax_reg));
  match(RegP);
  match(rbx_RegP);
  match(rsi_RegP);
  match(rdi_RegP);

  format %{ %}
  interface(REG_INTER);
%}

operand no_rax_rbx_RegP()
%{
  constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
  match(RegP);
  match(rsi_RegP);
  match(rdi_RegP);

  format %{ %}
  interface(REG_INTER);
%}

// Special Registers
// Return a pointer value
operand rax_RegP()
%{
  constraint(ALLOC_IN_RC(ptr_rax_reg));
  match(RegP);
  match(rRegP);

  format %{ "RAX" %}
  interface(REG_INTER);
%}

// Used in AtomicAdd
operand rbx_RegP()
%{
  constraint(ALLOC_IN_RC(ptr_rbx_reg));
  match(RegP);
  match(rRegP);

  format %{ "RBX" %}
  interface(REG_INTER);
%}

operand rsi_RegP()
%{
  constraint(ALLOC_IN_RC(ptr_rsi_reg));
  match(RegP);
  match(rRegP);

  format %{ "RSI" %}
  interface(REG_INTER);
%}

// Used in rep stosq
operand rdi_RegP()
%{
  constraint(ALLOC_IN_RC(ptr_rdi_reg));
  match(RegP);
  match(rRegP);

  format %{ "RDI" %}
  interface(REG_INTER);
%}

operand rbp_RegP()
%{
  constraint(ALLOC_IN_RC(ptr_rbp_reg));
  match(RegP);
  match(rRegP);

  format %{ "RBP" %}
  interface(REG_INTER);
%}

operand rRegL()
%{
  constraint(ALLOC_IN_RC(long_reg));
  match(RegL);
  match(rax_RegL);
  match(rdx_RegL);

  format %{ %}
  interface(REG_INTER);
%}

// Special Registers
operand no_rax_rdx_RegL()
%{
  constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
  match(RegL);
  match(rRegL);

  format %{ "RCX" %}
  interface(REG_INTER);
%}

operand no_rax_RegL()
%{
  constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
  match(RegL);
  match(rRegL);
  match(rdxRegL);

  format %{ "RCX" %}
  interface(REG_INTER);
%}

operand rax_RegL()
%{
  constraint(ALLOC_IN_RC(long_rax_reg));
  match(RegL);
  match(rRegL);

  format %{ "RAX" %}
  interface(REG_INTER);
%}

operand rdx_RegL()
%{
  constraint(ALLOC_IN_RC(long_rdx_reg));
  match(RegL);
  match(rRegL);

  format %{ "RDX" %}
  interface(REG_INTER);
%}

// Flags register, used as output of compare instructions
operand rFlagsReg()
%{
  constraint(ALLOC_IN_RC(int_flags));
  match(RegFlags);

  format %{ "RFLAGS" %}
  interface(REG_INTER);
%}

// Flags register, used as output of FLOATING POINT compare instructions
operand rFlagsRegU()
%{
  constraint(ALLOC_IN_RC(int_flags));
  match(RegFlags);

  format %{ "RFLAGS_U" %}
  interface(REG_INTER);
%}

// Float register operands
operand regF()
%{
  constraint(ALLOC_IN_RC(float_reg));
  match(RegF);

  format %{ %}
  interface(REG_INTER);
%}

// Double register operands
operand regD()
%{
  constraint(ALLOC_IN_RC(double_reg));
  match(RegD);

  format %{ %}
  interface(REG_INTER);
%}


//----------Memory Operands----------------------------------------------------
// Direct Memory Operand
// operand direct(immP addr)
// %{
//   match(addr);

//   format %{ "[$addr]" %}
//   interface(MEMORY_INTER) %{
//     base(0xFFFFFFFF);
//     index(0x4);
//     scale(0x0);
//     disp($addr);
//   %}
// %}

// Indirect Memory Operand
operand indirect(rRegP reg)
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(reg);

  format %{ "[$reg]" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index(0x4);
    scale(0x0);
    disp(0x0);
  %}
%}

// Indirect Memory Plus Short Offset Operand
operand indOffset8(rRegP reg, immL8 off)
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(AddP reg off);

  format %{ "[$reg + $off (8-bit)]" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index(0x4);
    scale(0x0);
    disp($off);
  %}
%}

// Indirect Memory Plus Long Offset Operand
operand indOffset32(rRegP reg, immL32 off)
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(AddP reg off);

  format %{ "[$reg + $off (32-bit)]" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index(0x4);
    scale(0x0);
    disp($off);
  %}
%}

// Indirect Memory Plus Index Register Plus Offset Operand
operand indIndexOffset(rRegP reg, rRegL lreg, immL32 off)
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(AddP (AddP reg lreg) off);

  op_cost(10);
  format %{"[$reg + $off + $lreg]" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index($lreg);
    scale(0x0);
    disp($off);
  %}
%}

// Indirect Memory Plus Index Register Plus Offset Operand
operand indIndex(rRegP reg, rRegL lreg)
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(AddP reg lreg);

  op_cost(10);
  format %{"[$reg + $lreg]" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index($lreg);
    scale(0x0);
    disp(0x0);
  %}
%}

// Indirect Memory Times Scale Plus Index Register 
operand indIndexScale(rRegP reg, rRegL lreg, immI2 scale)
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(AddP reg (LShiftL lreg scale));

  op_cost(10);
  format %{"[$reg + $lreg << $scale]" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index($lreg);
    scale($scale);
    disp(0x0);
  %}
%}

// Indirect Memory Times Scale Plus Index Register Plus Offset Operand
operand indIndexScaleOffset(rRegP reg, immL32 off, rRegL lreg, immI2 scale)
%{
  constraint(ALLOC_IN_RC(ptr_reg));
  match(AddP (AddP reg (LShiftL lreg scale)) off);

  op_cost(10);
  format %{"[$reg + $off + $lreg << $scale]" %}
  interface(MEMORY_INTER) %{
    base($reg);
    index($lreg);
    scale($scale);
    disp($off);
  %}
%}

//----------Special Memory Operands--------------------------------------------
// Stack Slot Operand - This operand is used for loading and storing temporary
//                      values on the stack where a match requires a value to
//                      flow through memory.
operand stackSlotP(sRegP reg) 
%{
  constraint(ALLOC_IN_RC(stack_slots));
  // No match rule because this operand is only generated in matching

  format %{ "[$reg]" %}
  interface(MEMORY_INTER) %{
    base(0x4);   // RSP
    index(0x4);  // No Index
    scale(0x0);  // No Scale
    disp($reg);  // Stack Offset
  %}
%}

operand stackSlotI(sRegI reg)
%{
  constraint(ALLOC_IN_RC(stack_slots));
  // No match rule because this operand is only generated in matching

  format %{ "[$reg]" %}
  interface(MEMORY_INTER) %{
    base(0x4);   // RSP
    index(0x4);  // No Index
    scale(0x0);  // No Scale
    disp($reg);  // Stack Offset
  %}
%}

operand stackSlotF(sRegF reg)
%{
  constraint(ALLOC_IN_RC(stack_slots));
  // No match rule because this operand is only generated in matching

  format %{ "[$reg]" %}
  interface(MEMORY_INTER) %{
    base(0x4);   // RSP
    index(0x4);  // No Index
    scale(0x0);  // No Scale
    disp($reg);  // Stack Offset
  %}
%}

operand stackSlotD(sRegD reg)
%{
  constraint(ALLOC_IN_RC(stack_slots));
  // No match rule because this operand is only generated in matching

  format %{ "[$reg]" %}
  interface(MEMORY_INTER) %{
    base(0x4);   // RSP
    index(0x4);  // No Index
    scale(0x0);  // No Scale
    disp($reg);  // Stack Offset
  %}
%}
operand stackSlotL(sRegL reg)
%{
  constraint(ALLOC_IN_RC(stack_slots));
  // No match rule because this operand is only generated in matching

  format %{ "[$reg]" %}
  interface(MEMORY_INTER) %{
    base(0x4);   // RSP
    index(0x4);  // No Index
    scale(0x0);  // No Scale
    disp($reg);  // Stack Offset
  %}
%}

//----------Conditional Branch Operands----------------------------------------
// Comparison Op  - This is the operation of the comparison, and is limited to
//                  the following set of codes:
//                  L (<), LE (<=), G (>), GE (>=), E (==), NE (!=)
//
// Other attributes of the comparison, such as unsignedness, are specified
// by the comparison instruction that sets a condition code flags register.
// That result is represented by a flags operand whose subtype is appropriate
// to the unsignedness (etc.) of the comparison.
//
// Later, the instruction which matches both the Comparison Op (a Bool) and
// the flags (produced by the Cmp) specifies the coding of the comparison op
// by matching a specific subtype of Bool operand below, such as cmpOpU.

// Comparision Code
operand cmpOp()
%{
  match(Bool);

  format %{ "" %}
  interface(COND_INTER) %{
    equal(0x4);
    not_equal(0x5);
    less(0xC);
    greater_equal(0xD);
    less_equal(0xE);
    greater(0xF);
  %}
%}

// Comparison Code, unsigned compare.  Used by FP also, with
// C2 (unordered) turned into GT or LT already.  The other bits
// C0 and C3 are turned into Carry & Zero flags.
operand cmpOpU()
%{
  match(Bool);

  format %{ "" %}
  interface(COND_INTER) %{
    equal(0x4);
    not_equal(0x5);
    less(0x2);
    greater_equal(0x3);
    less_equal(0x6);
    greater(0x7);
  %}
%}


//----------OPERAND CLASSES----------------------------------------------------
// Operand Classes are groups of operands that are used as to simplify
// instruction definitions by not requiring the AD writer to specify seperate
// instructions for every form of operand when the instruction accepts
// multiple operand types with the same basic encoding and format.  The classic
// case of this is memory operands.

// opclass memory(indirect, indOffset8, indOffset32, indIndexOffset,
// 	       indIndex, indIndexScale, indIndexScaleOffset);

opclass memory(indirect, indOffset8, indOffset32, indIndexOffset,
               indIndex, indIndexScale, indIndexScaleOffset);
// 	       indIndex, indIndexScale, indIndexScaleOffset);

//----------PIPELINE-----------------------------------------------------------
// Rules which define the behavior of the target architectures pipeline.
pipeline %{

//----------ATTRIBUTES---------------------------------------------------------
attributes %{
  variable_size_instructions;        // Fixed size instructions
  max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
  instruction_unit_size = 1;         // An instruction is 1 bytes long
  instruction_fetch_unit_size = 16;  // The processor fetches one line
  instruction_fetch_units = 1;       // of 16 bytes

  // List of nop instructions
  nops( MachNop );
%}

//----------RESOURCES----------------------------------------------------------
// Resources are the functional units available to the machine

// Generic P2/P3 pipeline
// 3 decoders, only D0 handles big operands; a "bundle" is the limit of
// 3 instructions decoded per cycle.
// 2 load/store ops per cycle, 1 branch, 1 FPU, 
// 3 ALU op, only ALU0 handles mul instructions.
resources( D0, D1, D2, DECODE = D0 | D1 | D2, 
           MS0, MS1, MS2, MEM = MS0 | MS1 | MS2, 
           BR, FPU, 
           ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);

//----------PIPELINE DESCRIPTION-----------------------------------------------
// Pipeline Description specifies the stages in the machine's pipeline

// Generic P2/P3 pipeline
pipe_desc(S0, S1, S2, S3, S4, S5);

//----------PIPELINE CLASSES---------------------------------------------------
// Pipeline Classes describe the stages in which input and output are
// referenced by the hardware pipeline.

// Naming convention: ialu or fpu
// Then: _reg
// Then: _reg if there is a 2nd register
// Then: _long if it's a pair of instructions implementing a long
// Then: _fat if it requires the big decoder
//   Or: _mem if it requires the big decoder and a memory unit.

// Integer ALU reg operation
pipe_class ialu_reg(rRegI dst)
%{
    single_instruction;
    dst    : S4(write);
    dst    : S3(read);
    DECODE : S0;  	// any decoder
    ALU    : S3;        // any alu
%}

// Long ALU reg operation
pipe_class ialu_reg_long(rRegL dst)
%{
    instruction_count(2);
    dst    : S4(write);
    dst    : S3(read);
    DECODE : S0(2);  	// any 2 decoders
    ALU    : S3(2);     // both alus
%}

// Integer ALU reg operation using big decoder
pipe_class ialu_reg_fat(rRegI dst)
%{
    single_instruction;
    dst    : S4(write);
    dst    : S3(read);
    D0     : S0;  	// big decoder only
    ALU    : S3;        // any alu
%}

// Long ALU reg operation using big decoder
pipe_class ialu_reg_long_fat(rRegL dst)
%{
    instruction_count(2);
    dst    : S4(write);
    dst    : S3(read);
    D0     : S0(2);  	// big decoder only; twice
    ALU    : S3(2);     // any 2 alus
%}

// Integer ALU reg-reg operation
pipe_class ialu_reg_reg(rRegI dst, rRegI src)
%{
    single_instruction;
    dst    : S4(write);
    src    : S3(read);
    DECODE : S0;  	// any decoder
    ALU    : S3;        // any alu
%}

// Long ALU reg-reg operation
pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
%{
    instruction_count(2);
    dst    : S4(write);
    src    : S3(read);
    DECODE : S0(2);  	// any 2 decoders
    ALU    : S3(2);     // both alus
%}

// Integer ALU reg-reg operation
pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
%{
    single_instruction;
    dst    : S4(write);
    src    : S3(read);
    D0     : S0;  	// big decoder only
    ALU    : S3;        // any alu
%}

// Long ALU reg-reg operation
pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
%{
    instruction_count(2);
    dst    : S4(write);
    src    : S3(read);
    D0     : S0(2);  	// big decoder only; twice
    ALU    : S3(2);     // both alus
%}

// Integer ALU reg-mem operation
pipe_class ialu_reg_mem(rRegI dst, memory mem)
%{
    single_instruction;
    dst    : S5(write);
    mem    : S3(read);
    D0     : S0;  	// big decoder only
    ALU    : S4;        // any alu
    MEM    : S3;        // any mem
%}

// Integer Store to Memory
pipe_class ialu_mem_reg(memory mem, rRegI src)
%{
    single_instruction;
    mem    : S3(read);
    src    : S5(read);
    D0     : S0;  	// big decoder only
    ALU    : S4;        // any alu
    MEM    : S3;
%}

// // Long Store to Memory
// pipe_class ialu_mem_long_reg(memory mem, rRegL src)
// %{
//     instruction_count(2);
//     mem    : S3(read);
//     src    : S5(read);
//     D0     : S0(2);  	// big decoder only; twice
//     ALU    : S4(2);     // any 2 alus
//     MEM    : S3(2);	// Both mems
// %}

// Integer Store to Memory
pipe_class ialu_mem_imm(memory mem)
%{
    single_instruction;
    mem    : S3(read);
    D0     : S0;  	// big decoder only
    ALU    : S4;        // any alu
    MEM    : S3;
%}

// Integer ALU0 reg-reg operation
pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
%{
    single_instruction;
    dst    : S4(write);
    src    : S3(read);
    D0     : S0;  	// Big decoder only
    ALU0   : S3;        // only alu0
%}

// Integer ALU0 reg-mem operation
pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
%{
    single_instruction;
    dst    : S5(write);
    mem    : S3(read);
    D0     : S0;  	// big decoder only
    ALU0   : S4;        // ALU0 only
    MEM    : S3;        // any mem
%}

// Integer ALU reg-reg operation
pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
%{
    single_instruction;
    cr     : S4(write);
    src1   : S3(read);
    src2   : S3(read);
    DECODE : S0;  	// any decoder
    ALU    : S3;        // any alu
%}

// Integer ALU reg-imm operation
pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
%{
    single_instruction;
    cr     : S4(write);
    src1   : S3(read);
    DECODE : S0;  	// any decoder
    ALU    : S3;        // any alu
%}

// Integer ALU reg-mem operation
pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
%{
    single_instruction;
    cr     : S4(write);
    src1   : S3(read);
    src2   : S3(read);
    D0     : S0;  	// big decoder only
    ALU    : S4;        // any alu
    MEM    : S3;
%}

// Conditional move reg-reg
pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
%{
    instruction_count(4);
    y      : S4(read);
    q      : S3(read);
    p      : S3(read);
    DECODE : S0(4);  	// any decoder
%}

// Conditional move reg-reg
pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
%{
    single_instruction;
    dst    : S4(write);
    src    : S3(read);
    cr     : S3(read);
    DECODE : S0;  	// any decoder
%}

// Conditional move reg-mem
pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
%{
    single_instruction;
    dst    : S4(write);
    src    : S3(read);
    cr     : S3(read);
    DECODE : S0;  	// any decoder
    MEM    : S3;
%}

// Conditional move reg-reg long
pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
%{
    single_instruction;
    dst    : S4(write);
    src    : S3(read);
    cr     : S3(read);
    DECODE : S0(2);  	// any 2 decoders
%}

// XXX
// // Conditional move double reg-reg
// pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
// %{
//     single_instruction;
//     dst    : S4(write);
//     src    : S3(read);
//     cr     : S3(read);
//     DECODE : S0;  	// any decoder
// %}

// Float reg-reg operation
pipe_class fpu_reg(regD dst)
%{
    instruction_count(2);
    dst    : S3(read);
    DECODE : S0(2);  	// any 2 decoders
    FPU    : S3;
%}

// Float reg-reg operation
pipe_class fpu_reg_reg(regD dst, regD src)
%{
    instruction_count(2);
    dst    : S4(write);
    src    : S3(read);
    DECODE : S0(2);  	// any 2 decoders
    FPU    : S3;
%}

// Float reg-reg operation
pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
%{
    instruction_count(3);
    dst    : S4(write);
    src1   : S3(read);
    src2   : S3(read);
    DECODE : S0(3);  	// any 3 decoders
    FPU    : S3(2);
%}

// Float reg-reg operation
pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
%{
    instruction_count(4);
    dst    : S4(write);
    src1   : S3(read);
    src2   : S3(read);
    src3   : S3(read);
    DECODE : S0(4);  	// any 3 decoders
    FPU    : S3(2);
%}

// Float reg-reg operation
pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
%{
    instruction_count(4);
    dst    : S4(write);
    src1   : S3(read);
    src2   : S3(read);
    src3   : S3(read);
    DECODE : S1(3);  	// any 3 decoders
    D0     : S0;        // Big decoder only
    FPU    : S3(2);
    MEM    : S3;
%}

// Float reg-mem operation
pipe_class fpu_reg_mem(regD dst, memory mem)
%{
    instruction_count(2);
    dst    : S5(write);
    mem    : S3(read);
    D0     : S0;  	// big decoder only
    DECODE : S1;        // any decoder for FPU POP
    FPU    : S4;
    MEM    : S3;        // any mem
%}

// Float reg-mem operation
pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
%{
    instruction_count(3);
    dst    : S5(write);
    src1   : S3(read);
    mem    : S3(read);
    D0     : S0;  	// big decoder only
    DECODE : S1(2);     // any decoder for FPU POP
    FPU    : S4;
    MEM    : S3;        // any mem
%}

// Float mem-reg operation
pipe_class fpu_mem_reg(memory mem, regD src)
%{
    instruction_count(2);
    src    : S5(read);
    mem    : S3(read);
    DECODE : S0;        // any decoder for FPU PUSH
    D0     : S1;  	// big decoder only
    FPU    : S4;
    MEM    : S3;        // any mem
%}

pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
%{
    instruction_count(3);
    src1   : S3(read);
    src2   : S3(read);
    mem    : S3(read);
    DECODE : S0(2);     // any decoder for FPU PUSH
    D0     : S1;  	// big decoder only
    FPU    : S4;
    MEM    : S3;        // any mem
%}

pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
%{
    instruction_count(3);
    src1   : S3(read);
    src2   : S3(read);
    mem    : S4(read);
    DECODE : S0;        // any decoder for FPU PUSH
    D0     : S0(2);  	// big decoder only
    FPU    : S4;
    MEM    : S3(2);     // any mem
%}

pipe_class fpu_mem_mem(memory dst, memory src1)
%{
    instruction_count(2);
    src1   : S3(read);
    dst    : S4(read);
    D0     : S0(2);  	// big decoder only
    MEM    : S3(2);     // any mem
%}

pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
%{
    instruction_count(3);
    src1   : S3(read);
    src2   : S3(read);
    dst    : S4(read);
    D0     : S0(3);  	// big decoder only
    FPU    : S4;
    MEM    : S3(3);     // any mem
%}

pipe_class fpu_mem_reg_con(memory mem, regD src1)
%{
    instruction_count(3);
    src1   : S4(read);
    mem    : S4(read);
    DECODE : S0;        // any decoder for FPU PUSH
    D0     : S0(2);  	// big decoder only
    FPU    : S4;
    MEM    : S3(2);     // any mem
%}

// Float load constant
pipe_class fpu_reg_con(regD dst)
%{
    instruction_count(2);
    dst    : S5(write);
    D0     : S0;  	// big decoder only for the load
    DECODE : S1;        // any decoder for FPU POP
    FPU    : S4;
    MEM    : S3;        // any mem
%}

// Float load constant
pipe_class fpu_reg_reg_con(regD dst, regD src)
%{
    instruction_count(3);
    dst    : S5(write);
    src    : S3(read);
    D0     : S0;  	// big decoder only for the load
    DECODE : S1(2);     // any decoder for FPU POP
    FPU    : S4;
    MEM    : S3;        // any mem
%}

// UnConditional branch
pipe_class pipe_jmp(label labl)
%{
    single_instruction;
    BR   : S3;
%}

// Conditional branch
pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
%{
    single_instruction;
    cr    : S1(read);
    BR    : S3;
%}

// Allocation idiom
pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
%{
    instruction_count(1); force_serialization;
    fixed_latency(6);
    heap_ptr : S3(read);
    DECODE   : S0(3);
    D0       : S2;
    MEM      : S3;
    ALU      : S3(2);
    dst      : S5(write);
    BR       : S5;
%}

// Generic big/slow expanded idiom
pipe_class pipe_slow() 
%{
    instruction_count(10); multiple_bundles; force_serialization;
    fixed_latency(100);
    D0  : S0(2);
    MEM : S3(2);
%}

// The real do-nothing guy
pipe_class empty()
%{
    instruction_count(0);
%}

// Define the class for the Nop node
define 
%{
   MachNop = empty;
%}

%}

//----------INSTRUCTIONS-------------------------------------------------------
// 
// match      -- States which machine-independent subtree may be replaced 
//               by this instruction.
// ins_cost   -- The estimated cost of this instruction is used by instruction
//               selection to identify a minimum cost tree of machine 
//               instructions that matches a tree of machine-independent 
//               instructions.
// format     -- A string providing the disassembly for this instruction.
//               The value of an instruction's operand may be inserted 
//               by referring to it with a '$' prefix.
// opcode     -- Three instruction opcodes may be provided.  These are referred 
//               to within an encode class as $primary, $secondary, and $tertiary
//               rrspectively.  The primary opcode is commonly used to 
//               indicate the type of machine instruction, while secondary 
//               and tertiary are often used for prefix options or addressing 
//               modes.
// ins_encode -- A list of encode classes with parameters. The encode class
//               name must have been defined in an 'enc_class' specification
//               in the encode section of the architecture description.

instruct box_handle(rRegP dst, stackSlotP src)
%{
  match(Set dst (Box src));

  ins_cost(110);
  format %{ "leaq    $dst, $src\t# box node" %}
  opcode(0x8D);
  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_reg_fat);
%}


//----------Load/Store/Move Instructions---------------------------------------
//----------Load Instructions--------------------------------------------------

// Load Byte (8 bit signed)
instruct loadB(rRegI dst, memory mem)
%{
  match(Set dst (LoadB mem));

  ins_cost(125);
  format %{ "movsbl  $dst, $mem\t# byte" %}
  opcode(0x0F, 0xBE);
  ins_encode(REX_reg_mem(dst, mem), OpcP, OpcS, reg_mem(dst, mem));
  ins_pipe(ialu_reg_mem);
%}

// Load Byte (8 bit signed) into long
// instruct loadB2L(rRegL dst, memory mem)
// %{
//   match(Set dst (ConvI2L (LoadB mem)));

//   ins_cost(125);
//   format %{ "movsbq  $dst, $mem\t# byte -> long" %}
//   opcode(0x0F, 0xBE);
//   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, OpcS, reg_mem(dst, mem));
//   ins_pipe(ialu_reg_mem);
// %}

// Load Byte (8 bit UNsigned)
instruct loadUB(rRegI dst, memory mem, immI_255 bytemask)
%{
  match(Set dst (AndI (LoadB mem) bytemask));

  ins_cost(125);
  format %{ "movzbl  $dst, $mem\t# ubyte" %}
  opcode(0x0F, 0xB6);
  ins_encode(REX_reg_mem(dst, mem), OpcP, OpcS, reg_mem(dst, mem));
  ins_pipe(ialu_reg_mem);
%}

// Load Byte (8 bit UNsigned) into long
// instruct loadUB2L(rRegL dst, memory mem, immI_255 bytemask)
// %{
//   match(Set dst (ConvI2L (AndI (LoadB mem) bytemask)));

//   ins_cost(125);
//   format %{ "movzbl  $dst, $mem\t# ubyte -> long" %}
//   opcode(0x0F, 0xB6);
//   ins_encode(REX_reg_mem(dst, mem), OpcP, OpcS, reg_mem(dst, mem));
//   ins_pipe(ialu_reg_mem);
// %}

// Load Short (16 bit signed)
instruct loadS(rRegI dst, memory mem)
%{
  match(Set dst (LoadS mem));

  ins_cost(125); // XXX
  format %{ "movswl $dst, $mem\t# short" %}
  opcode(0x0F, 0xBF);
  ins_encode(REX_reg_mem(dst, mem), OpcP, OpcS, reg_mem(dst, mem));
  ins_pipe(ialu_reg_mem);
%}

// Load Short (16 bit signed) into long
// instruct loadS2L(rRegL dst, memory mem)
// %{
//   match(Set dst (ConvI2L (LoadS mem)));

//   ins_cost(125); // XXX
//   format %{ "movswq $dst, $mem\t# short -> long" %}
//   opcode(0x0F, 0xBF);
//   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, OpcS, reg_mem(dst, mem));
//   ins_pipe(ialu_reg_mem);
// %}

// Load Char (16 bit UNsigned)
instruct loadC(rRegI dst, memory mem) 
%{
  match(Set dst (LoadC mem));

  ins_cost(125);
  format %{ "movzwl  $dst, $mem\t# char" %}
  opcode(0x0F, 0xB7);
  ins_encode(REX_reg_mem(dst, mem), OpcP, OpcS, reg_mem(dst, mem));
  ins_pipe(ialu_reg_mem);
%}

// Load Char (16 bit UNsigned) into long
// instruct loadC2L(rRegL dst, memory mem) 
// %{
//   match(Set dst (ConvI2L (LoadC mem)));

//   ins_cost(125);
//   format %{ "movzwl  $dst, $mem\t# char -> long" %}
//   opcode(0x0F, 0xB7);
//   ins_encode(REX_reg_mem(dst, mem), OpcP, OpcS, reg_mem(dst, mem));
//   ins_pipe(ialu_reg_mem);
// %}

// Load Integer
instruct loadI(rRegI dst, memory mem)
%{
  match(Set dst (LoadI mem));

  ins_cost(125); // XXX
  format %{ "movl    $dst, $mem\t# int" %}
  opcode(0x8B);
  ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
  ins_pipe(ialu_reg_mem);
%}

// Load Long
instruct loadL(rRegL dst, memory mem)
%{
  match(Set dst (LoadL mem));

  ins_cost(125); // XXX
  format %{ "movq    $dst, $mem\t# long" %}
  opcode(0x8B);
  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
  ins_pipe(ialu_reg_mem); // XXX
%}

// Load Range
instruct loadRange(rRegI dst, memory mem)
%{
  match(Set dst (LoadRange mem));

  ins_cost(125); // XXX
  format %{ "movl    $dst, $mem\t# range" %}
  opcode(0x8B);
  ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
  ins_pipe(ialu_reg_mem);
%}

// Load Pointer
instruct loadP(rRegP dst, memory mem)
%{
  match(Set dst (LoadP mem));

  ins_cost(125); // XXX
  format %{ "movq    $dst, $mem\t# ptr" %}
  opcode(0x8B);
  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
  ins_pipe(ialu_reg_mem); // XXX
%}

// Load Klass Pointer
instruct loadKlass(rRegP dst, memory mem)
%{
  match(Set dst (LoadKlass mem));

  ins_cost(125); // XXX
  format %{ "movq    $dst, $mem\t# class" %}
  opcode(0x8B);
  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
  ins_pipe(ialu_reg_mem); // XXX
%}

// Load Float
instruct loadF(regF dst, memory mem)
%{
  match(Set dst (LoadF mem));

  ins_cost(145); // XXX
  format %{ "movss   $dst, $mem\t# float" %}
  opcode(0xF3, 0x0F, 0x10);
  ins_encode(OpcP, REX_reg_mem(dst, mem), OpcS, OpcT, reg_mem(dst, mem));
  ins_pipe(pipe_slow); // XXX
%}

// Load Double
instruct loadD(regD dst, memory mem)
%{
  match(Set dst (LoadD mem));

  ins_cost(145); // XXX
  format %{ "movlpd  $dst, $mem\t# double" %}
  opcode(0x66, 0x0F, 0x12);
  ins_encode(OpcP, REX_reg_mem(dst, mem), OpcS, OpcT, reg_mem(dst, mem));
  ins_pipe(pipe_slow); // XXX
%}

// Load Effective Address
instruct leaP8(rRegP dst, indOffset8 mem) 
%{
  match(Set dst mem);

  ins_cost(110); // XXX
  format %{ "leaq    $dst, $mem\t# ptr 8" %}
  opcode(0x8D);
  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
  ins_pipe(ialu_reg_reg_fat);
%}

instruct leaP32(rRegP dst, indOffset32 mem)
%{
  match(Set dst mem);

  ins_cost(110);
  format %{ "leaq    $dst, $mem\t# ptr 32" %}
  opcode(0x8D);
  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
  ins_pipe(ialu_reg_reg_fat);
%}

// instruct leaPIdx(rRegP dst, indIndex mem)
// %{
//   match(Set dst mem);

//   ins_cost(110);
//   format %{ "leaq    $dst, $mem\t# ptr idx" %}
//   opcode(0x8D);
//   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
//   ins_pipe(ialu_reg_reg_fat);
// %}

instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
%{
  match(Set dst mem);

  ins_cost(110);
  format %{ "leaq    $dst, $mem\t# ptr idxoff" %}
  opcode(0x8D);
  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
  ins_pipe(ialu_reg_reg_fat);
%}

instruct leaPIdxScale(rRegP dst, indIndexScale mem)
%{
  match(Set dst mem);

  ins_cost(110);
  format %{ "leaq    $dst, $mem\t# ptr idxscale" %}
  opcode(0x8D);
  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
  ins_pipe(ialu_reg_reg_fat);
%}

instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
%{
  match(Set dst mem);

  ins_cost(110);
  format %{ "leaq    $dst, $mem\t# ptr idxscaleoff" %}
  opcode(0x8D);
  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
  ins_pipe(ialu_reg_reg_fat);
%}

instruct loadConI(rRegI dst, immI src)
%{
  match(Set dst src);

  format %{ "movl    $dst, $src\t# int" %}
  ins_encode(load_immI(dst, src));
  ins_pipe(ialu_reg_fat); // XXX
%}

instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
%{
  match(Set dst src);
  effect(KILL cr);
 
  ins_cost(50);
  format %{ "xorl    $dst, $dst\t# int" %}
  opcode(0x33); /* + rd */
  ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
  ins_pipe(ialu_reg);
%}

instruct loadConL(rRegL dst, immL src)
%{
  match(Set dst src);

  ins_cost(150);
  format %{ "movq    $dst, $src\t# long" %}
  ins_encode(load_immL(dst, src));
  ins_pipe(ialu_reg);
%}

instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
%{
  match(Set dst src);
  effect(KILL cr);
 
  ins_cost(50);
  format %{ "xorl    $dst, $dst\t# long" %}
  opcode(0x33); /* + rd */
  ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
  ins_pipe(ialu_reg); // XXX
%}

instruct loadConUL32(rRegL dst, immUL32 src)
%{
  match(Set dst src);

  ins_cost(60);
  format %{ "movl    $dst, $src\t# long (unsigned 32-bit)" %}
  ins_encode(load_immUL32(dst, src));
  ins_pipe(ialu_reg);
%}

instruct loadConL32(rRegL dst, immL32 src)
%{
  match(Set dst src);

  ins_cost(70);
  format %{ "movq    $dst, $src\t# long (32-bit)" %}
  ins_encode(load_immL32(dst, src));
  ins_pipe(ialu_reg);
%}

instruct loadConP(rRegP dst, immP src)
%{
  match(Set dst src);

  format %{ "movq    $dst, $src\t# ptr" %}
  ins_encode(load_immP(dst, src));
  ins_pipe(ialu_reg_fat); // XXX
%}

instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
%{
  match(Set dst src);
  effect(KILL cr);
 
  ins_cost(50);
  format %{ "xorl    $dst, $dst\t# ptr" %}
  opcode(0x33); /* + rd */
  ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
  ins_pipe(ialu_reg);
%}

// Load return address of the following native call into a register
instruct loadConPc(rRegP dst, method offset_to_call_return)
%{
  match(Set dst (LoadPC));
  effect(USE offset_to_call_return);

  format %{ "leaq    $dst, [rip + #$offset_to_call_return]\t# LoadPC" %}
  size(7); // REX + Opcode + ModRM + Disp32 == 7 bytes
  ins_encode(load_imm_PC(dst, offset_to_call_return));
  ins_pipe(ialu_reg_fat);
%}

instruct loadConF(regF dst, immF src)
%{
  match(Set dst src);

  format %{ "movss   $dst, [$src]" %}
  opcode(0xF3, 0x0F, 0x10);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, load_immF(dst, src));
  ins_pipe(pipe_slow);
%}

instruct loadConF0(regF dst, immF0 src)
%{
  match(Set dst src);

  format %{ "xorps   $dst, $dst\t# float" %}
  opcode(0x0F, 0x57);
  ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
  ins_pipe(pipe_slow);
%}

instruct loadConD(regD dst, immD src) 
%{
  match(Set dst src);

  format %{ "movlpd  $dst, [$src]" %}
  opcode(0x66, 0x0F, 0x12);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, load_immD(dst, src));
  ins_pipe(pipe_slow);
%}

instruct loadConD0(regD dst, immD0 src)
%{
  match(Set dst src);

  format %{ "xorpd   $dst, $dst\t# double" %}
  opcode(0x66, 0x0F, 0x57);
  ins_encode(OpcP, REX_reg_reg(dst, dst), OpcS, OpcT, reg_reg(dst, dst));
  ins_pipe(pipe_slow);
%}

instruct loadSSI(rRegI dst, stackSlotI src)
%{
  match(Set dst src);

  ins_cost(125);
  format %{ "movl    $dst, $src\t# int stk" %}
  opcode(0x8B);
  ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

instruct loadSSL(rRegL dst, stackSlotL src)
%{
  match(Set dst src);

  ins_cost(125);
  format %{ "movq    $dst, $src\t# long stk" %}
  opcode(0x8B);
  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

instruct loadSSP(rRegP dst, stackSlotP src)
%{
  match(Set dst src);

  ins_cost(125);
  format %{ "movq    $dst, $src\t# ptr stk" %}
  opcode(0x8B);
  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

instruct loadSSF(regF dst, stackSlotF src)
%{
  match(Set dst src);

  ins_cost(125);
  format %{ "movss   $dst, $src\t# float stk" %}
  opcode(0xF3, 0x0F, 0x10);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow); // XXX
%}

instruct loadSSD(regD dst, stackSlotD src)
%{
  match(Set dst src);

  ins_cost(125);
  format %{ "movlpd  $dst, $src\t# double stk" %}
  opcode(0x66, 0x0F, 0x12);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow); // XXX
%}

instruct prefetch(memory mem)
%{
  match(Prefetch mem);
  predicate(VM_Version::has_prefetchw());
  ins_cost(125);

//   format %{ "prefetcht2 $mem\t# prefetch to level 2 cache" %}
//   opcode(0x0F, 0x18); /* Opcode 0F 18 /3 */
//   ins_encode(REX_mem(mem), OpcP, OpcS, RM_opc_mem(0x03, mem));
  format %{ "prefetchw $mem\t# prefetch into L1 and mark as modified" %}
  opcode(0x0F, 0x0D); /* Opcode 0F 0D /1 */
  ins_encode(REX_mem(mem), OpcP, OpcS, RM_opc_mem(0x01, mem));
  ins_pipe(pipe_slow);
%}

//----------Store Instructions-------------------------------------------------

// Store Byte
instruct storeB(memory mem, rRegI src)
%{
  match(Set mem (StoreB mem src));

  ins_cost(125); // XXX
  format %{ "movb    $mem, $src\t# byte" %}
  opcode(0x88);
  ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
  ins_pipe(ialu_mem_reg);
%}

// Store Char/Short
instruct storeC(memory mem, rRegI src)
%{
  match(Set mem (StoreC mem src));

  ins_cost(125); // XXX
  format %{ "movw    $mem, $src\t# char/short" %}
  opcode(0x89);
  ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
  ins_pipe(ialu_mem_reg);
%}

// Store Integer
instruct storeI(memory mem, rRegI src) 
%{
  match(Set mem (StoreI mem src));

  ins_cost(125); // XXX
  format %{ "movl    $mem, $src\t# int" %}
  opcode(0x89);
  ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
  ins_pipe(ialu_mem_reg);
%}

// Store Long
instruct storeL(memory mem, rRegL src)
%{
  match(Set mem (StoreL mem src));

  ins_cost(125); // XXX
  format %{ "movq    $mem, $src\t# long" %}
  opcode(0x89);
  ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
  ins_pipe(ialu_mem_reg); // XXX
%}

// Store Pointer
instruct storeP(memory mem, any_RegP src)
%{
  match(Set mem (StoreP mem src));

  ins_cost(125); // XXX
  format %{ "movq    $mem, $src\t# ptr" %}
  opcode(0x89);
  ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
  ins_pipe(ialu_mem_reg);
%}

// Store NULL Pointer
instruct storeImmP(memory mem, immP0 src)
%{
  match(Set mem (StoreP mem src));

  ins_cost(125); // XXX
  format %{ "movq    $mem, $src\t# NULL ptr" %}
  opcode(0xC7); /* C7 /0 */
  ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
  ins_pipe(ialu_mem_imm);
%}

// Store Integer Immediate
instruct storeImmI(memory mem, immI src)
%{
  match(Set mem (StoreI mem src));

  ins_cost(150);
  format %{ "movl    $mem, $src\t# int" %}
  opcode(0xC7); /* C7 /0 */
  ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
  ins_pipe(ialu_mem_imm);
%}

// Store Long Immediate
instruct storeImmL(memory mem, immL32 src)
%{
  match(Set mem (StoreL mem src));

  ins_cost(150);
  format %{ "movq    $mem, $src\t# long" %}
  opcode(0xC7); /* C7 /0 */
  ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
  ins_pipe(ialu_mem_imm);
%}

// Store Short/Char Immediate
instruct storeImmI16(memory mem, immI16 src)
%{
  match(Set mem (StoreC mem src));

  ins_cost(150);
  format %{ "movw    $mem, $src\t# short/char" %}
  opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
  ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
  ins_pipe(ialu_mem_imm);
%}

// Store Byte Immediate
instruct storeImmB(memory mem, immI8 src)
%{
  match(Set mem (StoreB mem src));

  ins_cost(150); // XXX
  format %{ "movb    $mem, $src\t# byte" %}
  opcode(0xC6); /* C6 /0 */
  ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
  ins_pipe(ialu_mem_imm);	
%}

// Store CMS card-mark Immediate
instruct storeImmCM0(memory mem, immI0 src)
%{
  match(Set mem (StoreCM mem src));

  ins_cost(150); // XXX
  format %{ "movb    $mem, $src\t# CMS card-mark byte 0" %}
  opcode(0xC6); /* C6 /0 */
  ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
  ins_pipe(ialu_mem_imm);	
%}

// Store Float
instruct storeF(memory mem, regF src)
%{
  match(Set mem (StoreF mem src));

  ins_cost(95); // XXX
  format %{ "movss   $mem, $src\t# float" %}
  opcode(0xF3, 0x0F, 0x11);
  ins_encode(OpcP, REX_reg_mem(src, mem), OpcS, OpcT, reg_mem(src, mem));
  ins_pipe(pipe_slow); // XXX
%}

// Store Float
// instruct storeF_imm(memory mem, immF src)
// %{
//   match(Set mem (StoreF mem src));

//   ins_cost(150);
//   format %{ "movl    $mem, $src\t# float" %}
//   opcode(0xC7); /* C7 /0 */
//   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
//   ins_pipe(ialu_mem_imm);
// %}

// Store Double
instruct storeD(memory mem, regD src)
%{
  match(Set mem (StoreD mem src));

  ins_cost(95); // XXX
  format %{ "movsd   $mem, $src\t# double" %}
  opcode(0xF2, 0x0F, 0x11);
  ins_encode(OpcP, REX_reg_mem(src, mem), OpcS, OpcT, reg_mem(src, mem));
  ins_pipe(pipe_slow); // XXX
%}

instruct storeSSI(stackSlotI dst, rRegI src)
%{
  match(Set dst src);

  ins_cost(100);
  format %{ "movl    $dst, $src\t# int stk" %}
  opcode(0x89);
  ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe( ialu_mem_reg );
%}

instruct storeSSL(stackSlotL dst, rRegL src)
%{
  match(Set dst src);

  ins_cost(100);
  format %{ "movq    $dst, $src\t# long stk" %}
  opcode(0x89);
  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe(ialu_mem_reg);
%}

instruct storeSSP(stackSlotP dst, rRegP src)
%{
  match(Set dst src);

  ins_cost(100);
  format %{ "movq    $dst, $src\t# ptr stk" %}
  opcode(0x89);
  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe(ialu_mem_reg);
%}

instruct storeSSF(stackSlotF dst, regF src)
%{
  match(Set dst src);

  ins_cost(95); // XXX
  format %{ "movss   $dst, $src\t# float stk" %}
  opcode(0xF3, 0x0F, 0x11);
  ins_encode(OpcP, REX_reg_mem(src, dst), OpcS, OpcT, reg_mem(src, dst));
  ins_pipe(pipe_slow); // XXX
%}

instruct storeSSD(stackSlotD dst, regD src)
%{
  match(Set dst src);

  ins_cost(95); // XXX
  format %{ "movsd   $dst, $src\t# double stk" %}
  opcode(0xF2, 0x0F, 0x11);
  ins_encode(OpcP, REX_reg_mem(src, dst), OpcS, OpcT, reg_mem(src, dst));
  ins_pipe(pipe_slow); // XXX
%}

//----------MemBar Instructions-----------------------------------------------
// Memory barrier flavors

instruct membar_acquire()
%{
  match(MemBarAcquire);
  ins_cost(0);

  size(0);
  format %{ "MEMBAR-acquire" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct membar_acquire_lock() 
%{
  match(MemBarAcquire);
  predicate(Matcher::prior_fast_lock(n));
  ins_cost(0);

  size(0);
  format %{ "MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct membar_release()
%{
  match(MemBarRelease);
  ins_cost(0);

  size(0);
  format %{ "MEMBAR-release" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct membar_release_lock()
%{
  match(MemBarRelease);
  predicate(Matcher::post_fast_unlock(n));
  ins_cost(0);

  size(0);
  format %{ "MEMBAR-release (a FastUnlock follows so empty encoding)" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct membar_volatile()
%{
  match(MemBarVolatile);
  ins_cost(400);

  format %{ "MEMBAR-volatile" %}
  ins_encode(enc_membar_volatile);
  ins_pipe(pipe_slow);
%}

instruct unnecessary_membar_volatile()
%{
  match(MemBarVolatile);
  predicate(Matcher::post_store_load_barrier(n));
  ins_cost(0);

  size(0);
  format %{ "MEMBAR-volatile (unnecessary so empty encoding)" %}
  ins_encode();
  ins_pipe(empty);
%}

instruct membar_cpu_order()
%{
  match(MemBarCPUOrder);
  ins_cost(0);

  size(0);
  format %{ "MEMBAR-CPUOrder" %}
  ins_encode();
  ins_pipe(empty);
%}

//----------Move Instructions--------------------------------------------------

instruct castL2P(rRegP dst, rRegL src)
%{
  match(Set dst (CastL2P src));

  format %{ "movq    $dst, $src\t# long->ptr" %}
  ins_encode(enc_copy_wide(dst, src));
  ins_pipe(ialu_reg_reg); // XXX
%}

instruct castP2L(rRegL dst, rRegP src)
%{
  match(Set dst (CastP2L src));

  format %{ "movq    $dst, $src\t# ptr -> long" %}
  ins_encode(enc_copy_wide(dst, src));
  ins_pipe(ialu_reg_reg); // XXX
%}

//----------Conditional Move---------------------------------------------------
// Conditional move
instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
%{
  match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));

  ins_cost(200); // XXX
  format %{ "cmovl$cop $dst, $src\t# signed, int" %}
  opcode(0x0F, 0x40);
  ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
  ins_pipe(pipe_cmov_reg);
%}

instruct cmovI_regU(rRegI dst, rRegI src, rFlagsRegU cr, cmpOpU cop)
%{
  match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));

  ins_cost(200); // XXX
  format %{ "cmovl$cop $dst, $src\t# unsigned, int" %}
  opcode(0x0F, 0x40);
  ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
  ins_pipe(pipe_cmov_reg);
%}

// Conditional move
instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src)
%{
  match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));

  ins_cost(250); // XXX
  format %{ "cmovl$cop $dst, $src\t# signed, int" %}
  opcode(0x0F, 0x40);
  ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
  ins_pipe(pipe_cmov_mem);
%}

// Conditional move
instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
%{
  match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));

  ins_cost(250); // XXX
  format %{ "cmovl$cop $dst, $src\t# unsigned, int" %}
  opcode(0x0F, 0x40);
  ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
  ins_pipe(pipe_cmov_mem);
%}

// Conditional move
instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
%{
  match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));

  ins_cost(200); // XXX
  format %{ "cmovq$cop $dst, $src\t# signed, ptr" %}
  opcode(0x0F, 0x40);
  ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
  ins_pipe(pipe_cmov_reg);  // XXX
%}

// Conditional move
instruct cmovP_regU(rRegP dst, rRegP src, rFlagsRegU cr, cmpOpU cop)
%{
  match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));

  ins_cost(200); // XXX
  format %{ "cmovq$cop $dst, $src\t# unsigned, ptr" %}
  opcode(0x0F, 0x40);
  ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
  ins_pipe(pipe_cmov_reg); // XXX
%}

// DISABLED: Requires the ADLC to emit a bottom_type call that
// correctly meets the two pointer arguments; one is an incoming
// register but the other is a memory operand.  ALSO appears to
// be buggy with implicit null checks.
//
//// Conditional move
//instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src) 
//%{
//  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
//  ins_cost(250);
//  format %{ "CMOV$cop $dst,$src\t# ptr" %}
//  opcode(0x0F,0x40);
//  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
//  ins_pipe( pipe_cmov_mem );
//%}
//
//// Conditional move
//instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
//%{
//  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
//  ins_cost(250);
//  format %{ "CMOV$cop $dst,$src\t# ptr" %}
//  opcode(0x0F,0x40);
//  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
//  ins_pipe( pipe_cmov_mem );
//%}

instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
%{
  match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));

  ins_cost(200); // XXX
  format %{ "cmovq$cop $dst, $src\t# signed, long" %}
  opcode(0x0F, 0x40);
  ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
  ins_pipe(pipe_cmov_reg);  // XXX
%}

instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
%{
  match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));

  ins_cost(200); // XXX
  format %{ "cmovq$cop $dst, $src\t# signed, long" %}
  opcode(0x0F, 0x40);
  ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
  ins_pipe(pipe_cmov_mem);  // XXX
%}

instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
%{
  match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));

  ins_cost(200); // XXX
  format %{ "cmovq$cop $dst, $src\t# unsigned, long" %}
  opcode(0x0F, 0x40);
  ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
  ins_pipe(pipe_cmov_reg); // XXX
%}

instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
%{
  match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));

  ins_cost(200); // XXX
  format %{ "cmovq$cop $dst, $src\t# unsigned, long" %}
  opcode(0x0F, 0x40);
  ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
  ins_pipe(pipe_cmov_mem); // XXX
%}

instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
%{
  match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));

  ins_cost(200); // XXX
  format %{ "jn$cop    skip\t# signed cmove float\n\t"
            "movss     $dst, $src\n" 
    "skip:" %}
  ins_encode(enc_cmovf_branch(cop, dst, src));
  ins_pipe(pipe_slow);
%}

// instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
// %{
//   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));

//   ins_cost(200); // XXX
//   format %{ "jn$cop    skip\t# signed cmove float\n\t"
//             "movss     $dst, $src\n" 
//     "skip:" %}
//   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
//   ins_pipe(pipe_slow);
// %}

instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
%{
  match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));

  ins_cost(200); // XXX
  format %{ "jn$cop    skip\t# unsigned cmove float\n\t"
            "movss     $dst, $src\n" 
    "skip:" %}
  ins_encode(enc_cmovf_branch(cop, dst, src));
  ins_pipe(pipe_slow);
%}

instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
%{
  match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));

  ins_cost(200); // XXX
  format %{ "jn$cop    skip\t# signed cmove double\n\t"
            "movsd     $dst, $src\n" 
    "skip:" %}
  ins_encode(enc_cmovd_branch(cop, dst, src));
  ins_pipe(pipe_slow);
%}

instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
%{
  match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));

  ins_cost(200); // XXX
  format %{ "jn$cop    skip\t# unsigned cmove double\n\t"
            "movsd     $dst, $src\n" 
    "skip:" %}
  ins_encode(enc_cmovd_branch(cop, dst, src));
  ins_pipe(pipe_slow);
%}

//----------Arithmetic Instructions--------------------------------------------
//----------Addition Instructions----------------------------------------------

instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
%{
  match(Set dst (AddI dst src));
  effect(KILL cr);

  format %{ "addl    $dst, $src\t# int" %}
  opcode(0x03);
  ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg);
%}

instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
%{
  match(Set dst (AddI dst src));
  effect(KILL cr);

  format %{ "addl    $dst, $src\t# int" %}
  opcode(0x81, 0x00); /* /0 id */
  ins_encode(OpcSErm(dst, src), Con8or32(src));
  ins_pipe( ialu_reg );
%}

instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
%{
  match(Set dst (AddI dst (LoadI src)));
  effect(KILL cr);

  ins_cost(125); // XXX
  format %{ "addl    $dst, $src\t# int" %}
  opcode(0x03);
  ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (AddI (LoadI dst) src)));
  effect(KILL cr);

  ins_cost(150); // XXX
  format %{ "addl    $dst, $src\t# int" %}
  opcode(0x01); /* Opcode 01 /r */
  ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe(ialu_mem_reg);
%}

instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (AddI (LoadI dst) src)));
  effect(KILL cr);

  ins_cost(125); // XXX
  format %{ "addl    $dst, $src\t# int" %}
  opcode(0x81); /* Opcode 81 /0 id */
  ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
  ins_pipe(ialu_mem_imm);
%}

instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
%{
  match(Set dst (AddI dst src));
  effect(KILL cr);

  format %{ "incl    $dst\t# int" %}
  opcode(0xFF, 0x00); // FF /0
  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg);
%}

instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (AddI (LoadI dst) src)));
  effect(KILL cr);

  ins_cost(125); // XXX
  format %{ "incl    $dst\t# int" %}
  opcode(0xFF); /* Opcode FF /0 */
  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
  ins_pipe(ialu_mem_imm);
%}

// XXX why does that use AddI
instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr) 
%{
  match(Set dst (AddI dst src));
  effect(KILL cr);

  format %{ "decl    $dst\t# int" %}
  opcode(0xFF, 0x01); // FF /1
  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg);
%}

// XXX why does that use AddI
instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (AddI (LoadI dst) src)));
  effect(KILL cr);

  ins_cost(125); // XXX
  format %{ "decl    $dst\t# int" %}
  opcode(0xFF); /* Opcode FF /1 */
  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
  ins_pipe(ialu_mem_imm);
%}

instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
%{
  match(Set dst (AddI src0 src1));

  ins_cost(110);
  format %{ "addr32 leal $dst, [$src0 + $src1]\t# int" %}
  opcode(0x8D); /* 0x8D /r */
  ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
  ins_pipe(ialu_reg_reg);
%}

instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
%{
  match(Set dst (AddL dst src));
  effect(KILL cr);

  format %{ "addq    $dst, $src\t# long" %}
  opcode(0x03);
  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg);
%}

instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
%{
  match(Set dst (AddL dst src));
  effect(KILL cr);

  format %{ "addq    $dst, $src\t# long" %}
  opcode(0x81, 0x00); /* /0 id */
  ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
  ins_pipe( ialu_reg );
%}

instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
%{
  match(Set dst (AddL dst (LoadL src)));
  effect(KILL cr);

  ins_cost(125); // XXX
  format %{ "addq    $dst, $src\t# long" %}
  opcode(0x03);
  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (AddL (LoadL dst) src)));
  effect(KILL cr);

  ins_cost(150); // XXX
  format %{ "addq    $dst, $src\t# long" %}
  opcode(0x01); /* Opcode 01 /r */
  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe(ialu_mem_reg);
%}

instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (AddL (LoadL dst) src)));
  effect(KILL cr);

  ins_cost(125); // XXX
  format %{ "addq    $dst, $src\t# long" %}
  opcode(0x81); /* Opcode 81 /0 id */
  ins_encode(REX_mem_wide(dst),
             OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
  ins_pipe(ialu_mem_imm);
%}

instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
%{
  match(Set dst (AddL dst src));
  effect(KILL cr);

  format %{ "incq    $dst\t# long" %}
  opcode(0xFF, 0x00); // FF /0
  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg);
%}

instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (AddL (LoadL dst) src)));
  effect(KILL cr);

  ins_cost(125); // XXX
  format %{ "incq    $dst\t# long" %}
  opcode(0xFF); /* Opcode FF /0 */
  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
  ins_pipe(ialu_mem_imm);
%}

// XXX why does that use AddL
instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr) 
%{
  match(Set dst (AddL dst src));
  effect(KILL cr);

  format %{ "decq    $dst\t# long" %}
  opcode(0xFF, 0x01); // FF /1
  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg);
%}

// XXX why does that use AddL
instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (AddL (LoadL dst) src)));
  effect(KILL cr);

  ins_cost(125); // XXX
  format %{ "decq    $dst\t# long" %}
  opcode(0xFF); /* Opcode FF /1 */
  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
  ins_pipe(ialu_mem_imm);
%}

instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
%{
  match(Set dst (AddL src0 src1));

  ins_cost(110);
  format %{ "leaq    $dst, [$src0 + $src1]\t# long" %}
  opcode(0x8D); /* 0x8D /r */
  ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
  ins_pipe(ialu_reg_reg);
%}

instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
%{
  match(Set dst (AddP dst src));
  effect(KILL cr);

  format %{ "addq    $dst, $src\t# ptr" %}
  opcode(0x03);
  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg);
%}

instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
%{
  match(Set dst (AddP dst src));
  effect(KILL cr);

  format %{ "addq    $dst, $src\t# ptr" %}
  opcode(0x81, 0x00); /* /0 id */
  ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
  ins_pipe( ialu_reg );
%}

// XXX addP mem ops ????

instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
%{
  match(Set dst (AddP src0 src1));

  ins_cost(110);
  format %{ "leaq    $dst, [$src0 + $src1]\t# ptr" %}
  opcode(0x8D); /* 0x8D /r */
  ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
  ins_pipe(ialu_reg_reg);
%}

instruct checkCastPP(rRegP dst)
%{
  match(Set dst (CheckCastPP dst));

  size(0);
  format %{ "# checkcastPP of $dst" %}
  ins_encode(/* empty encoding */);
  ins_pipe(empty);
%}

instruct castPP(rRegP dst)
%{
  match(Set dst (CastPP dst));

  size(0);
  format %{ "# castPP of $dst" %}
  ins_encode(/* empty encoding */);
  ins_pipe(empty);
%}

// LoadP-locked same as a regular LoadP when used with compare-swap
instruct loadPLocked(rRegP dst, memory mem)
%{
  match(Set dst (LoadPLocked mem));

  ins_cost(125); // XXX
  format %{ "movq    $dst, $mem\t# ptr locked" %}
  opcode(0x8B);
  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
  ins_pipe(ialu_reg_mem); // XXX
%}

// LoadL-locked - same as a regular LoadL when used with compare-swap
instruct loadLLocked(rRegL dst, memory mem)
%{
  match(Set dst (LoadLLocked mem));

  ins_cost(125); // XXX
  format %{ "movq    $dst, $mem\t# long locked" %}
  opcode(0x8B);
  ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
  ins_pipe(ialu_reg_mem); // XXX
%}

// Conditional-store of the updated heap-top.
// Used during allocation of the shared heap.
// Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.

instruct storePConditional(memory heap_top_ptr, 
                           rax_RegP oldval, rRegP newval, 
                           rFlagsReg cr)
%{
  match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));

  format %{ "cmpxchgq $heap_top_ptr, $newval\t# (ptr) "
            "If rax == $heap_top_ptr then store $newval into $heap_top_ptr" %}
  opcode(0x0F, 0xB1);
  ins_encode(lock_prefix, 
             REX_reg_mem_wide(newval, heap_top_ptr), 
             OpcP, OpcS, 
             reg_mem(newval, heap_top_ptr));
  ins_pipe(pipe_cmpxchg);
%}

// Conditional-store of a long value
// Returns a boolean value (0/1) on success.  Implemented with a
// CMPXCHG8 on Intel.  mem_ptr can actually be in either RSI or RDI

instruct storeLConditional(rRegI res, 
                           memory mem_ptr,
                           rax_RegL oldval, rRegL newval,
                           rFlagsReg cr)
%{
  match(Set res (StoreLConditional mem_ptr (Binary oldval newval)));
  effect(KILL cr);

  format %{ "cmpxchgq $mem_ptr, $newval\t# (long) "
            "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
            "sete    $res\n\t"
            "movzbl  $res, $res" %}
  opcode(0x0F, 0xB1);
  ins_encode(lock_prefix, 
             REX_reg_mem_wide(newval, mem_ptr), 
             OpcP, OpcS, 
             reg_mem(newval, mem_ptr),
             REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
             REX_reg_breg(res, res), // movzbl
             Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
  ins_pipe(pipe_cmpxchg);
%}

// Conditional-store of a long value
// ZF flag is set on success, reset otherwise. Implemented with a
// CMPXCHG8 on Intel.  mem_ptr can actually be in either RSI or RDI
instruct storeLConditional_flags(memory mem_ptr,
                                 rax_RegL oldval, rRegL newval,
                                 rFlagsReg cr,
                                 immI0 zero)
%{
  match(Set cr (CmpI (StoreLConditional mem_ptr (Binary oldval newval)) zero));

  format %{ "cmpxchgq $mem_ptr, $newval\t# (long) "
            "If rax == $mem_ptr then store $newval into $mem_ptr" %}
  opcode(0x0F, 0xB1);
  ins_encode(lock_prefix, 
             REX_reg_mem_wide(newval, mem_ptr), 
             OpcP, OpcS, 
             reg_mem(newval, mem_ptr));
  ins_pipe(pipe_cmpxchg);
%}

instruct compareAndSwapP(rRegI res, 
                         memory mem_ptr,
                         rax_RegP oldval, rRegP newval,
                         rFlagsReg cr)
%{
  match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
  effect(KILL cr, KILL oldval);

  format %{ "cmpxchgq $mem_ptr,$newval\t# "
            "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
            "sete    $res\n\t"
            "movzbl  $res, $res" %}
  opcode(0x0F, 0xB1);
  ins_encode(lock_prefix, 
             REX_reg_mem_wide(newval, mem_ptr), 
             OpcP, OpcS, 
             reg_mem(newval, mem_ptr),
             REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
             REX_reg_breg(res, res), // movzbl
             Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
  ins_pipe( pipe_cmpxchg );
%}

// XXX No flag versions for CompareAndSwap{P,I,L} because matcher can't match them
instruct compareAndSwapL(rRegI res, 
                         memory mem_ptr,
                         rax_RegL oldval, rRegL newval,
                         rFlagsReg cr)
%{
  match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
  effect(KILL cr, KILL oldval);

  format %{ "cmpxchgq $mem_ptr,$newval\t# "
            "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
            "sete    $res\n\t"
            "movzbl  $res, $res" %}
  opcode(0x0F, 0xB1);
  ins_encode(lock_prefix, 
             REX_reg_mem_wide(newval, mem_ptr), 
             OpcP, OpcS, 
             reg_mem(newval, mem_ptr),
             REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
             REX_reg_breg(res, res), // movzbl
             Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
  ins_pipe( pipe_cmpxchg );
%}

instruct compareAndSwapI(rRegI res, 
                         memory mem_ptr,
                         rax_RegI oldval, rRegI newval,
                         rFlagsReg cr)
%{
  match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
  effect(KILL cr, KILL oldval);

  format %{ "cmpxchgl $mem_ptr,$newval\t# "
            "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
            "sete    $res\n\t"
            "movzbl  $res, $res" %}
  opcode(0x0F, 0xB1);
  ins_encode(lock_prefix, 
             REX_reg_mem(newval, mem_ptr), 
             OpcP, OpcS, 
             reg_mem(newval, mem_ptr),
             REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
             REX_reg_breg(res, res), // movzbl
             Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
  ins_pipe( pipe_cmpxchg );
%}


//----------Subtraction Instructions-------------------------------------------

// Integer Subtraction Instructions
instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
%{
  match(Set dst (SubI dst src));
  effect(KILL cr);

  format %{ "subl    $dst, $src\t# int" %}
  opcode(0x2B);
  ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg);
%}

instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
%{
  match(Set dst (SubI dst src));
  effect(KILL cr);

  format %{ "subl    $dst, $src\t# int" %}
  opcode(0x81, 0x05);  /* Opcode 81 /5 */
  ins_encode(OpcSErm(dst, src), Con8or32(src));
  ins_pipe(ialu_reg);
%}

instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
%{
  match(Set dst (SubI dst (LoadI src)));
  effect(KILL cr);

  ins_cost(125);
  format %{ "subl    $dst, $src\t# int" %}
  opcode(0x2B);
  ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (SubI (LoadI dst) src)));
  effect(KILL cr);

  ins_cost(150);
  format %{ "subl    $dst, $src\t# int" %}
  opcode(0x29); /* Opcode 29 /r */
  ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe(ialu_mem_reg);
%}

instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (SubI (LoadI dst) src)));
  effect(KILL cr);

  ins_cost(125); // XXX
  format %{ "subl    $dst, $src\t# int" %}
  opcode(0x81); /* Opcode 81 /5 id */
  ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
  ins_pipe(ialu_mem_imm);
%}

instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
%{
  match(Set dst (SubL dst src));
  effect(KILL cr);

  format %{ "subq    $dst, $src\t# long" %}
  opcode(0x2B);
  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg);
%}

instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
%{
  match(Set dst (SubL dst src));
  effect(KILL cr);

  format %{ "subq    $dst, $src\t# long" %}
  opcode(0x81, 0x05);  /* Opcode 81 /5 */
  ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
  ins_pipe(ialu_reg);
%}

instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
%{
  match(Set dst (SubL dst (LoadL src)));
  effect(KILL cr);

  ins_cost(125);
  format %{ "subq    $dst, $src\t# long" %}
  opcode(0x2B);
  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (SubL (LoadL dst) src)));
  effect(KILL cr);

  ins_cost(150);
  format %{ "subq    $dst, $src\t# long" %}
  opcode(0x29); /* Opcode 29 /r */
  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe(ialu_mem_reg);
%}

instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (SubL (LoadL dst) src)));
  effect(KILL cr);

  ins_cost(125); // XXX
  format %{ "subq    $dst, $src\t# long" %}
  opcode(0x81); /* Opcode 81 /5 id */
  ins_encode(REX_mem_wide(dst),
             OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
  ins_pipe(ialu_mem_imm);
%}

// Subtract from a pointer
// XXX hmpf???
instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
%{
  match(Set dst (AddP dst (SubI zero src)));
  effect(KILL cr);

  format %{ "subq    $dst, $src\t# ptr - int" %}
  opcode(0x2B);
  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg);
%}

instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
%{
  match(Set dst (SubI zero dst));
  effect(KILL cr);

  format %{ "negl    $dst\t# int" %}
  opcode(0xF7, 0x03);  // Opcode F7 /3
  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg);
%}

instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (SubI zero (LoadI dst))));
  effect(KILL cr);

  format %{ "negl    $dst\t# int" %}
  opcode(0xF7, 0x03);  // Opcode F7 /3
  ins_encode(REX_reg(dst), OpcP, RM_opc_mem(secondary, dst));
  ins_pipe(ialu_reg);
%}

instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
%{
  match(Set dst (SubL zero dst));
  effect(KILL cr);

  format %{ "negq    $dst\t# long" %}
  opcode(0xF7, 0x03);  // Opcode F7 /3
  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg);
%}

instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (SubL zero (LoadL dst))));
  effect(KILL cr);

  format %{ "negq    $dst\t# long" %}
  opcode(0xF7, 0x03);  // Opcode F7 /3
  ins_encode(REX_reg_wide(dst), OpcP, RM_opc_mem(secondary, dst));
  ins_pipe(ialu_reg);
%}


//----------Multiplication/Division Instructions-------------------------------
// Integer Multiplication Instructions
// Multiply Register

instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
%{
  match(Set dst (MulI dst src));
  effect(KILL cr);

  ins_cost(300);
  format %{ "imull   $dst, $src\t# int" %}
  opcode(0x0F, 0xAF);
  ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg_alu0);
%}

instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
%{
  match(Set dst (MulI src imm));
  effect(KILL cr);

  ins_cost(300);
  format %{ "imull   $dst, $src, $imm\t# int" %}
  opcode(0x69); /* 69 /r id */
  ins_encode(REX_reg_reg(dst, src), 
             OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
  ins_pipe(ialu_reg_reg_alu0);
%}

instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
%{
  match(Set dst (MulI dst (LoadI src)));
  effect(KILL cr);

  ins_cost(350);
  format %{ "imull   $dst, $src\t# int" %}
  opcode(0x0F, 0xAF);
  ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem_alu0);
%}

instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
%{
  match(Set dst (MulI (LoadI src) imm));
  effect(KILL cr);

  ins_cost(300);
  format %{ "imull   $dst, $src, $imm\t# int" %}
  opcode(0x69); /* 69 /r id */
  ins_encode(REX_reg_mem(dst, src), 
             OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
  ins_pipe(ialu_reg_mem_alu0);
%}

instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
%{
  match(Set dst (MulL dst src));
  effect(KILL cr);

  ins_cost(300);
  format %{ "imulq   $dst, $src\t# long" %}
  opcode(0x0F, 0xAF);
  ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg_alu0);
%}

instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
%{
  match(Set dst (MulL src imm));
  effect(KILL cr);

  ins_cost(300);
  format %{ "imulq   $dst, $src, $imm\t# long" %}
  opcode(0x69); /* 69 /r id */
  ins_encode(REX_reg_reg_wide(dst, src), 
             OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
  ins_pipe(ialu_reg_reg_alu0);
%}

instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
%{
  match(Set dst (MulL dst (LoadL src)));
  effect(KILL cr);

  ins_cost(350);
  format %{ "imulq   $dst, $src\t# long" %}
  opcode(0x0F, 0xAF);
  ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem_alu0);
%}

instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
%{
  match(Set dst (MulL (LoadL src) imm));
  effect(KILL cr);

  ins_cost(300);
  format %{ "imulq   $dst, $src, $imm\t# long" %}
  opcode(0x69); /* 69 /r id */
  ins_encode(REX_reg_mem_wide(dst, src), 
             OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
  ins_pipe(ialu_reg_mem_alu0);
%}

instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
                   rFlagsReg cr)
%{
  match(Set rax (DivI rax div));
  effect(KILL rdx, KILL cr);

  ins_cost(30*100+10*100); // XXX
  format %{ "cmpl    rax, 0x80000000\t# idiv\n\t"
            "jne,s   normal\n\t"
            "xorl    rdx, rdx\n\t"
            "cmpl    $div, -1\n\t"
            "je,s    done\n"
    "normal: cdql\n\t"
	    "idivl   $div\n"
    "done:"        %}
  opcode(0xF7, 0x7);  /* Opcode F7 /7 */
  ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
  ins_pipe(ialu_reg_reg_alu0);
%}

instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
                   rFlagsReg cr)
%{
  match(Set rax (DivL rax div));
  effect(KILL rdx, KILL cr);

  ins_cost(30*100+10*100); // XXX
  format %{ "movq    rdx, 0x8000000000000000\t# ldiv\n\t"
            "cmpq    rax, rdx\n\t"
            "jne,s   normal\n\t"
            "xorl    rdx, rdx\n\t"
            "cmpq    $div, -1\n\t"
            "je,s    done\n"
    "normal: cdqq\n\t"
	    "idivq   $div\n"
    "done:"        %}
  opcode(0xF7, 0x7);  /* Opcode F7 /7 */
  ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
  ins_pipe(ialu_reg_reg_alu0);
%}

//----------- DivL-By-Constant-Expansions--------------------------------------
// DivI cases are handled by the compiler

// Magic constant, reciprical of 10
instruct loadConL_0x6666666666666667(rRegL dst)
%{
  effect(DEF dst);

  format %{ "movq    $dst, #0x666666666666667\t# Used in div-by-10" %}
  ins_encode(load_immL(dst, 0x6666666666666667));
  ins_pipe(ialu_reg);
%}

instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
%{
  effect(DEF dst, USE src, USE_KILL rax, KILL cr);

  format %{ "imulq   rdx:rax, rax, $src\t# Used in div-by-10" %}
  opcode(0xF7, 0x5); /* Opcode F7 /5 */
  ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
  ins_pipe(ialu_reg_reg_alu0);
%}

instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
%{
  effect(USE_DEF dst, KILL cr);

  format %{ "sarq    $dst, #63\t# Used in div-by-10" %}
  opcode(0xC1, 0x7); /* C1 /7 ib */
  ins_encode(reg_opc_imm_wide(dst, 0x3F));
  ins_pipe(ialu_reg);
%}

instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
%{
  effect(USE_DEF dst, KILL cr);

  format %{ "sarq    $dst, #2\t# Used in div-by-10" %}
  opcode(0xC1, 0x7); /* C1 /7 ib */
  ins_encode(reg_opc_imm_wide(dst, 0x2));
  ins_pipe(ialu_reg);
%}

instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
%{
  match(Set dst (DivL src div));

  ins_cost((5+8)*100);
  expand %{
    rax_RegL rax;                     // Killed temp
    rFlagsReg cr;                     // Killed
    loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
    mul_hi(dst, src, rax, cr);        // mulq  rdx:rax <= rax * $src
    sarL_rReg_63(src, cr);            // sarq  src, 63
    sarL_rReg_2(dst, cr);             // sarq  rdx, 2
    subL_rReg(dst, src, cr);          // subl  rdx, src
  %}
%}

//-----------------------------------------------------------------------------

instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
                   rFlagsReg cr)
%{
  match(Set rdx (ModI rax div));
  effect(KILL rax, KILL cr);

  ins_cost(300); // XXX
  format %{ "cmpl    rax, 0x80000000\t# irem\n\t"
            "jne,s   normal\n\t"
            "xorl    rdx, rdx\n\t"
            "cmpl    $div, -1\n\t"
            "je,s    done\n"
    "normal: cdql\n\t"
	    "idivl   $div\n"
    "done:"        %}
  opcode(0xF7, 0x7);  /* Opcode F7 /7 */
  ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
  ins_pipe(ialu_reg_reg_alu0);
%}

instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
                   rFlagsReg cr)
%{
  match(Set rdx (ModL rax div));
  effect(KILL rax, KILL cr);

  ins_cost(300); // XXX
  format %{ "movq    rdx, 0x8000000000000000\t# lrem\n\t"
            "cmpq    rax, rdx\n\t"
            "jne,s   normal\n\t"
            "xorl    rdx, rdx\n\t"
            "cmpq    $div, -1\n\t"
            "je,s    done\n"
    "normal: cdqq\n\t"
	    "idivq   $div\n"
    "done:"        %}
  opcode(0xF7, 0x7);  /* Opcode F7 /7 */
  ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
  ins_pipe(ialu_reg_reg_alu0);
%}

// Integer Shift Instructions
// Shift Left by one
instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
%{
  match(Set dst (LShiftI dst shift));
  effect(KILL cr);

  format %{ "sall    $dst, $shift" %}
  opcode(0xD1, 0x4); /* D1 /4 */
  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg);
%}

// Shift Left by one
instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
  effect(KILL cr);

  format %{ "sarl    $dst, $shift\t" %}
  opcode(0xD1, 0x4); /* D1 /4 */
  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
  ins_pipe(ialu_mem_imm);
%}

// Shift Left by 8-bit immediate
instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
%{
  match(Set dst (LShiftI dst shift));
  effect(KILL cr);

  format %{ "sall    $dst, $shift" %}
  opcode(0xC1, 0x4); /* C1 /4 ib */
  ins_encode(reg_opc_imm(dst, shift));
  ins_pipe(ialu_reg);
%}

// Shift Left by 8-bit immediate
instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
  effect(KILL cr);

  format %{ "sall    $dst, $shift" %}
  opcode(0xC1, 0x4); /* C1 /4 ib */
  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
  ins_pipe(ialu_mem_imm);
%}

// Shift Left by variable
instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
%{
  match(Set dst (LShiftI dst shift));
  effect(KILL cr);

  format %{ "sall    $dst, $shift" %}
  opcode(0xD3, 0x4); /* D3 /4 */
  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg_reg);
%}

// Shift Left by variable
instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
  effect(KILL cr);

  format %{ "sall    $dst, $shift" %}
  opcode(0xD3, 0x4); /* D3 /4 */
  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
  ins_pipe(ialu_mem_reg);
%}

// Arithmetic shift right by one
instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
%{
  match(Set dst (RShiftI dst shift));
  effect(KILL cr);

  format %{ "sarl    $dst, $shift" %}
  opcode(0xD1, 0x7); /* D1 /7 */
  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg);
%}

// Arithmetic shift right by one
instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
  effect(KILL cr);

  format %{ "sarl    $dst, $shift" %}
  opcode(0xD1, 0x7); /* D1 /7 */
  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
  ins_pipe(ialu_mem_imm);
%}

// Arithmetic Shift Right by 8-bit immediate
instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
%{
  match(Set dst (RShiftI dst shift));
  effect(KILL cr);

  format %{ "sarl    $dst, $shift" %}
  opcode(0xC1, 0x7); /* C1 /7 ib */
  ins_encode(reg_opc_imm(dst, shift));
  ins_pipe(ialu_mem_imm);
%}

// Arithmetic Shift Right by 8-bit immediate
instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
  effect(KILL cr);

  format %{ "sarl    $dst, $shift" %}
  opcode(0xC1, 0x7); /* C1 /7 ib */
  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
  ins_pipe(ialu_mem_imm);
%}

// Arithmetic Shift Right by variable
instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
%{
  match(Set dst (RShiftI dst shift));
  effect(KILL cr);

  format %{ "sarl    $dst, $shift" %}
  opcode(0xD3, 0x7); /* D3 /7 */
  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg_reg);
%}

// Arithmetic Shift Right by variable
instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
  effect(KILL cr);

  format %{ "sarl    $dst, $shift" %}
  opcode(0xD3, 0x7); /* D3 /7 */
  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
  ins_pipe(ialu_mem_reg);
%}

// Logical shift right by one
instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr) 
%{
  match(Set dst (URShiftI dst shift));
  effect(KILL cr);

  format %{ "shrl    $dst, $shift" %}
  opcode(0xD1, 0x5); /* D1 /5 */
  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg);
%}

// Logical shift right by one
instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
  effect(KILL cr);

  format %{ "shrl    $dst, $shift" %}
  opcode(0xD1, 0x5); /* D1 /5 */
  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
  ins_pipe(ialu_mem_imm);
%}

// Logical Shift Right by 8-bit immediate
instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
%{
  match(Set dst (URShiftI dst shift));
  effect(KILL cr);

  format %{ "shrl    $dst, $shift" %}
  opcode(0xC1, 0x5); /* C1 /5 ib */
  ins_encode(reg_opc_imm(dst, shift));
  ins_pipe(ialu_reg);
%}

// Logical Shift Right by 8-bit immediate
instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
  effect(KILL cr);

  format %{ "shrl    $dst, $shift" %}
  opcode(0xC1, 0x5); /* C1 /5 ib */
  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
  ins_pipe(ialu_mem_imm);
%}

// Logical Shift Right by variable
instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
%{
  match(Set dst (URShiftI dst shift));
  effect(KILL cr);

  format %{ "shrl    $dst, $shift" %}
  opcode(0xD3, 0x5); /* D3 /5 */
  ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg_reg);
%}

// Logical Shift Right by variable
instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
  effect(KILL cr);

  format %{ "shrl    $dst, $shift" %}
  opcode(0xD3, 0x5); /* D3 /5 */
  ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
  ins_pipe(ialu_mem_reg);
%}

// Long Shift Instructions
// Shift Left by one
instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
%{
  match(Set dst (LShiftL dst shift));
  effect(KILL cr);

  format %{ "salq    $dst, $shift" %}
  opcode(0xD1, 0x4); /* D1 /4 */
  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg);
%}

// Shift Left by one
instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
  effect(KILL cr);

  format %{ "sarq    $dst, $shift" %}
  opcode(0xD1, 0x4); /* D1 /4 */
  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
  ins_pipe(ialu_mem_imm);
%}

// Shift Left by 8-bit immediate
instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
%{
  match(Set dst (LShiftL dst shift));
  effect(KILL cr);

  format %{ "salq    $dst, $shift" %}
  opcode(0xC1, 0x4); /* C1 /4 ib */
  ins_encode(reg_opc_imm_wide(dst, shift));
  ins_pipe(ialu_reg);
%}

// Shift Left by 8-bit immediate
instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
  effect(KILL cr);

  format %{ "salq    $dst, $shift" %}
  opcode(0xC1, 0x4); /* C1 /4 ib */
  ins_encode(REX_mem_wide(dst), OpcP, 
             RM_opc_mem(secondary, dst), Con8or32(shift));
  ins_pipe(ialu_mem_imm);
%}

// Shift Left by variable
instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
%{
  match(Set dst (LShiftL dst shift));
  effect(KILL cr);

  format %{ "salq    $dst, $shift" %}
  opcode(0xD3, 0x4); /* D3 /4 */
  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg_reg);
%}

// Shift Left by variable
instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
  effect(KILL cr);

  format %{ "salq    $dst, $shift" %}
  opcode(0xD3, 0x4); /* D3 /4 */
  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
  ins_pipe(ialu_mem_reg);
%}

// Arithmetic shift right by one
instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
%{
  match(Set dst (RShiftL dst shift));
  effect(KILL cr);

  format %{ "sarq    $dst, $shift" %}
  opcode(0xD1, 0x7); /* D1 /7 */
  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg);
%}

// Arithmetic shift right by one
instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
  effect(KILL cr);

  format %{ "sarq    $dst, $shift" %}
  opcode(0xD1, 0x7); /* D1 /7 */
  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
  ins_pipe(ialu_mem_imm);
%}

// Arithmetic Shift Right by 8-bit immediate
instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
%{
  match(Set dst (RShiftL dst shift));
  effect(KILL cr);

  format %{ "sarq    $dst, $shift" %}
  opcode(0xC1, 0x7); /* C1 /7 ib */
  ins_encode(reg_opc_imm_wide(dst, shift));
  ins_pipe(ialu_mem_imm);
%}

// Arithmetic Shift Right by 8-bit immediate
instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
  effect(KILL cr);

  format %{ "sarq    $dst, $shift" %}
  opcode(0xC1, 0x7); /* C1 /7 ib */
  ins_encode(REX_mem_wide(dst), OpcP, 
             RM_opc_mem(secondary, dst), Con8or32(shift));
  ins_pipe(ialu_mem_imm);
%}

// Arithmetic Shift Right by variable
instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
%{
  match(Set dst (RShiftL dst shift));
  effect(KILL cr);

  format %{ "sarq    $dst, $shift" %}
  opcode(0xD3, 0x7); /* D3 /7 */
  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg_reg);
%}

// Arithmetic Shift Right by variable
instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
  effect(KILL cr);

  format %{ "sarq    $dst, $shift" %}
  opcode(0xD3, 0x7); /* D3 /7 */
  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
  ins_pipe(ialu_mem_reg);
%}

// Logical shift right by one
instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr) 
%{
  match(Set dst (URShiftL dst shift));
  effect(KILL cr);

  format %{ "shrq    $dst, $shift" %}
  opcode(0xD1, 0x5); /* D1 /5 */
  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
  ins_pipe(ialu_reg);
%}

// Logical shift right by one
instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
  effect(KILL cr);

  format %{ "shrq    $dst, $shift" %}
  opcode(0xD1, 0x5); /* D1 /5 */
  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
  ins_pipe(ialu_mem_imm);
%}

// Logical Shift Right by 8-bit immediate
instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
%{
  match(Set dst (URShiftL dst shift));
  effect(KILL cr);

  format %{ "shrq    $dst, $shift" %}
  opcode(0xC1, 0x5); /* C1 /5 ib */
  ins_encode(reg_opc_imm_wide(dst, shift));
  ins_pipe(ialu_reg);
%}

// Logical Shift Right by 8-bit immediate
instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
  effect(KILL cr);

  format %{ "shrq    $dst, $shift" %}
  opcode(0xC1, 0x5); /* C1 /5 ib */
  ins_encode(REX_mem_wide(dst), OpcP,
             RM_opc_mem(secondary, dst), Con8or32(shift));
  ins_pipe(ialu_mem_imm);
%}

// Logical Shift Right by variable
instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
%{
  match(Set dst (URShiftL dst shift));
  effect(KILL cr);

  format %{ "shrq    $dst, $shift" %}
  opcode(0xD3, 0x5); /* D3 /5 */
  ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
  ins_pipe(ialu_reg_reg);
%}

// Logical Shift Right by variable
instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
  effect(KILL cr);

  format %{ "shrq    $dst, $shift" %}
  opcode(0xD3, 0x5); /* D3 /5 */
  ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
  ins_pipe(ialu_mem_reg);
%}

// Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
// This idiom is used by the compiler for the i2b bytecode.
instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
%{
  match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));

  format %{ "movsbl  $dst, $src\t# i2b" %}
  opcode(0x0F, 0xBE);
  ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg);
%}

// Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
// This idiom is used by the compiler the i2s bytecode.
instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
%{
  match(Set dst (RShiftI (LShiftI src sixteen) sixteen));

  format %{ "movswl  $dst, $src\t# i2s" %}
  opcode(0x0F, 0xBF);
  ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg);
%}


// Logical Instructions

// Integer Logical Instructions

// And Instructions
// And Register with Register
instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
%{
  match(Set dst (AndI dst src));
  effect(KILL cr);

  format %{ "andl    $dst, $src\t# int" %}
  opcode(0x23);
  ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg);
%}

// And Register with Immediate 255
instruct andI_rReg_imm255(rRegI dst, immI_255 src)
%{
  match(Set dst (AndI dst src));

  format %{ "movzbl  $dst, $dst\t# int & 0xFF" %}
  opcode(0x0F, 0xB6);
  ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
  ins_pipe(ialu_reg);
%}

// And Register with Immediate 255 and promote to long
instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
%{
  match(Set dst (ConvI2L (AndI src mask)));

  format %{ "movzbl  $dst, $src\t# int & 0xFF -> long" %}
  opcode(0x0F, 0xB6);
  ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
  ins_pipe(ialu_reg);
%}

// And Register with Immediate 65535
instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
%{
  match(Set dst (AndI dst src));

  format %{ "movzwl  $dst, $dst\t# int & 0xFFFF" %}
  opcode(0x0F, 0xB7);
  ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
  ins_pipe(ialu_reg);
%}

// And Register with Immediate 65535 and promote to long
instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
%{
  match(Set dst (ConvI2L (AndI src mask)));

  format %{ "movzwl  $dst, $src\t# int & 0xFFFF -> long" %}
  opcode(0x0F, 0xB7);
  ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
  ins_pipe(ialu_reg);
%}

// And Register with Immediate
instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
%{
  match(Set dst (AndI dst src));
  effect(KILL cr);

  format %{ "andl    $dst, $src\t# int" %}
  opcode(0x81, 0x04); /* Opcode 81 /4 */
  ins_encode(OpcSErm(dst, src), Con8or32(src));
  ins_pipe(ialu_reg);
%}

// And Register with Memory
instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
%{
  match(Set dst (AndI dst (LoadI src)));
  effect(KILL cr);

  ins_cost(125);
  format %{ "andl    $dst, $src\t# int" %}
  opcode(0x23);
  ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

// And Memory with Register
instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (AndI (LoadI dst) src)));
  effect(KILL cr);

  ins_cost(150);
  format %{ "andl    $dst, $src\t# int" %}
  opcode(0x21); /* Opcode 21 /r */
  ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe(ialu_mem_reg);
%}

// And Memory with Immediate
instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (AndI (LoadI dst) src)));
  effect(KILL cr);

  ins_cost(125);
  format %{ "andl    $dst, $src\t# int" %}
  opcode(0x81, 0x4); /* Opcode 81 /4 id */
  ins_encode(REX_mem(dst), OpcSE(src), 
             RM_opc_mem(secondary, dst), Con8or32(src));
  ins_pipe(ialu_mem_imm);
%}

// Or Instructions
// Or Register with Register
instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
%{
  match(Set dst (OrI dst src));
  effect(KILL cr);

  format %{ "orl     $dst, $src\t# int" %}
  opcode(0x0B);
  ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg);
%}

// Or Register with Immediate
instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
%{
  match(Set dst (OrI dst src));
  effect(KILL cr);

  format %{ "orl     $dst, $src\t# int" %}
  opcode(0x81, 0x01); /* Opcode 81 /1 id */
  ins_encode(OpcSErm(dst, src), Con8or32(src));
  ins_pipe(ialu_reg);
%}

// Or Register with Memory
instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
%{
  match(Set dst (OrI dst (LoadI src)));
  effect(KILL cr);

  ins_cost(125);
  format %{ "orl     $dst, $src\t# int" %}
  opcode(0x0B);
  ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

// Or Memory with Register
instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (OrI (LoadI dst) src)));
  effect(KILL cr);

  ins_cost(150);
  format %{ "orl     $dst, $src\t# int" %}
  opcode(0x09); /* Opcode 09 /r */
  ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe(ialu_mem_reg);
%}

// Or Memory with Immediate
instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (OrI (LoadI dst) src)));
  effect(KILL cr);

  ins_cost(125);
  format %{ "orl     $dst, $src\t# int" %}
  opcode(0x81, 0x1); /* Opcode 81 /1 id */
  ins_encode(REX_mem(dst), OpcSE(src),
             RM_opc_mem(secondary, dst), Con8or32(src));
  ins_pipe(ialu_mem_imm);
%}

// Xor Instructions
// Xor Register with Register
instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
%{
  match(Set dst (XorI dst src));
  effect(KILL cr);

  format %{ "xorl    $dst, $src\t# int" %}
  opcode(0x33);
  ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg);
%}

// Xor Register with Immediate
instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
%{
  match(Set dst (XorI dst src));
  effect(KILL cr);

  format %{ "xorl    $dst, $src\t# int" %}
  opcode(0x81, 0x06); /* Opcode 81 /6 id */
  ins_encode(OpcSErm(dst, src), Con8or32(src));
  ins_pipe(ialu_reg);
%}

// Xor Register with Memory
instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
%{
  match(Set dst (XorI dst (LoadI src)));
  effect(KILL cr);

  ins_cost(125);
  format %{ "xorl    $dst, $src\t# int" %}
  opcode(0x33);
  ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

// Xor Memory with Register
instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (XorI (LoadI dst) src)));
  effect(KILL cr);

  ins_cost(150);
  format %{ "xorl    $dst, $src\t# int" %}
  opcode(0x31); /* Opcode 31 /r */
  ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe(ialu_mem_reg);
%}

// Xor Memory with Immediate
instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
%{
  match(Set dst (StoreI dst (XorI (LoadI dst) src)));
  effect(KILL cr);

  ins_cost(125);
  format %{ "xorl    $dst, $src\t# int" %}
  opcode(0x81, 0x6); /* Opcode 81 /6 id */
  ins_encode(REX_mem(dst), OpcSE(src),
             RM_opc_mem(secondary, dst), Con8or32(src));
  ins_pipe(ialu_mem_imm);
%}


// Long Logical Instructions

// And Instructions
// And Register with Register
instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
%{
  match(Set dst (AndL dst src));
  effect(KILL cr);

  format %{ "andq    $dst, $src\t# long" %}
  opcode(0x23);
  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg);
%}

// And Register with Immediate 255
instruct andL_rReg_imm255(rRegL dst, immL_255 src)
%{
  match(Set dst (AndL dst src));

  format %{ "movzbq  $dst, $src\t# long & 0xFF" %}
  opcode(0x0F, 0xB6);
  ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
  ins_pipe(ialu_reg);
%}

// And Register with Immediate 65535
instruct andL_rReg_imm65535(rRegI dst, immL_65535 src)
%{
  match(Set dst (AndL dst src));

  format %{ "movzwq  $dst, $dst\t# long & 0xFFFF" %}
  opcode(0x0F, 0xB7);
  ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
  ins_pipe(ialu_reg);
%}

// And Register with Immediate
instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
%{
  match(Set dst (AndL dst src));
  effect(KILL cr);

  format %{ "andq    $dst, $src\t# long" %}
  opcode(0x81, 0x04); /* Opcode 81 /4 */
  ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
  ins_pipe(ialu_reg);
%}

// And Register with Memory
instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
%{
  match(Set dst (AndL dst (LoadL src)));
  effect(KILL cr);

  ins_cost(125);
  format %{ "andq    $dst, $src\t# long" %}
  opcode(0x23);
  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

// And Memory with Register
instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (AndL (LoadL dst) src)));
  effect(KILL cr);

  ins_cost(150);
  format %{ "andq    $dst, $src\t# long" %}
  opcode(0x21); /* Opcode 21 /r */
  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe(ialu_mem_reg);
%}

// And Memory with Immediate
instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (AndL (LoadL dst) src)));
  effect(KILL cr);

  ins_cost(125);
  format %{ "andq    $dst, $src\t# long" %}
  opcode(0x81, 0x4); /* Opcode 81 /4 id */
  ins_encode(REX_mem_wide(dst), OpcSE(src), 
             RM_opc_mem(secondary, dst), Con8or32(src));
  ins_pipe(ialu_mem_imm);
%}

// Or Instructions
// Or Register with Register
instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
%{
  match(Set dst (OrL dst src));
  effect(KILL cr);

  format %{ "orq     $dst, $src\t# long" %}
  opcode(0x0B);
  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg);
%}

// Or Register with Immediate
instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
%{
  match(Set dst (OrL dst src));
  effect(KILL cr);

  format %{ "orq     $dst, $src\t# long" %}
  opcode(0x81, 0x01); /* Opcode 81 /1 id */
  ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
  ins_pipe(ialu_reg);
%}

// Or Register with Memory
instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
%{
  match(Set dst (OrL dst (LoadL src)));
  effect(KILL cr);

  ins_cost(125);
  format %{ "orq     $dst, $src\t# long" %}
  opcode(0x0B);
  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

// Or Memory with Register
instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (OrL (LoadL dst) src)));
  effect(KILL cr);

  ins_cost(150);
  format %{ "orq     $dst, $src\t# long" %}
  opcode(0x09); /* Opcode 09 /r */
  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe(ialu_mem_reg);
%}

// Or Memory with Immediate
instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (OrL (LoadL dst) src)));
  effect(KILL cr);

  ins_cost(125);
  format %{ "orq     $dst, $src\t# long" %}
  opcode(0x81, 0x1); /* Opcode 81 /1 id */
  ins_encode(REX_mem_wide(dst), OpcSE(src),
             RM_opc_mem(secondary, dst), Con8or32(src));
  ins_pipe(ialu_mem_imm);
%}

// Xor Instructions
// Xor Register with Register
instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
%{
  match(Set dst (XorL dst src));
  effect(KILL cr);

  format %{ "xorq    $dst, $src\t# long" %}
  opcode(0x33);
  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
  ins_pipe(ialu_reg_reg);
%}

// Xor Register with Immediate
instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
%{
  match(Set dst (XorL dst src));
  effect(KILL cr);

  format %{ "xorq    $dst, $src\t# long" %}
  opcode(0x81, 0x06); /* Opcode 81 /6 id */
  ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
  ins_pipe(ialu_reg);
%}

// Xor Register with Memory
instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
%{
  match(Set dst (XorL dst (LoadL src)));
  effect(KILL cr);

  ins_cost(125);
  format %{ "xorq    $dst, $src\t# long" %}
  opcode(0x33);
  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

// Xor Memory with Register
instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (XorL (LoadL dst) src)));
  effect(KILL cr);

  ins_cost(150);
  format %{ "xorq    $dst, $src\t# long" %}
  opcode(0x31); /* Opcode 31 /r */
  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe(ialu_mem_reg);
%}

// Xor Memory with Immediate
instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
%{
  match(Set dst (StoreL dst (XorL (LoadL dst) src)));
  effect(KILL cr);

  ins_cost(125);
  format %{ "xorq    $dst, $src\t# long" %}
  opcode(0x81, 0x6); /* Opcode 81 /6 id */
  ins_encode(REX_mem_wide(dst), OpcSE(src),
             RM_opc_mem(secondary, dst), Con8or32(src));
  ins_pipe(ialu_mem_imm);
%}

// Convert Int to Boolean
instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
%{
  match(Set dst (Conv2B src));
  effect(KILL cr);

  format %{ "testl   $src, $src\t# ci2b\n\t"
            "setnz   $dst\n\t"
            "movzbl  $dst, $dst" %}
  ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
             setNZ_reg(dst),
             REX_reg_breg(dst, dst), // movzbl
             Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
  ins_pipe(pipe_slow); // XXX
%}

// Convert Pointer to Boolean
instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
%{
  match(Set dst (Conv2B src));
  effect(KILL cr);

  format %{ "testq   $src, $src\t# cp2b\n\t"
            "setnz   $dst\n\t"
            "movzbl  $dst, $dst" %}
  ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
             setNZ_reg(dst),
             REX_reg_breg(dst, dst), // movzbl
             Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
  ins_pipe(pipe_slow); // XXX
%}

instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
%{
  match(Set dst (CmpLTMask p q));
  effect(KILL cr);

  ins_cost(400); // XXX
  format %{ "cmpl    $p, $q\t# cmpLTMask\n\t"
	    "setlt   $dst\n\t"
            "movzbl  $dst, $dst\n\t"
	    "negl    $dst" %}
  ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
             setLT_reg(dst),
             REX_reg_breg(dst, dst), // movzbl
             Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
             neg_reg(dst));
  ins_pipe(pipe_slow);
%}

instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
%{
  match(Set dst (CmpLTMask dst zero));
  effect(KILL cr);

  ins_cost(100); // XXX
  format %{ "sarl    $dst, #31\t# cmpLTMask0" %}
  opcode(0xC1, 0x7);  /* C1 /7 ib */
  ins_encode(reg_opc_imm(dst, 0x1F));
  ins_pipe(ialu_reg);
%}


instruct cadd_cmpLTMask1(no_rcx_RegI p, no_rcx_RegI q, no_rcx_RegI y,
                         rcx_RegI tmp, 
                         rFlagsReg cr)
%{
  match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
  effect(USE_KILL tmp, KILL cr);

  ins_cost(400); // XXX
  // annoyingly, $tmp has no edges so you cant ask for it in
  // any format or encoding
  format %{ "subl    $p, $q\t# cadd_cmpLTMask1\n\t"
	    "sbbl    rcx, rcx\n\t"
	    "andl    rcx, $y\n\t"
	    "addl    $p, rcx" %}
  ins_encode(enc_cmpLTP(p, q, y, tmp)); 
  ins_pipe(pipe_cmplt);
%}

instruct cadd_cmpLTMask2(no_rcx_RegI p, no_rcx_RegI q, no_rcx_RegI y,
                         rcx_RegI tmp,
                         rFlagsReg cr)
%{
  match(Set p (AddI (SubI p q) (AndI (CmpLTMask p q) y)));
  effect(USE_KILL tmp, KILL cr);

  ins_cost(400); // XXX
  format %{ "subl    $p, $q\t# cadd_cmpLTMask2\n\t"
	    "sbbl    rcx, rcx\n\t"
	    "andl    rcx, $y\n\t"
	    "addl    $p, rcx" %}
  ins_encode(enc_cmpLTP(p, q, y, tmp)); 
  ins_pipe(pipe_cmplt);
%}

/* If I enable these 2, I encourage spilling in the inner loop of compress.
instruct cadd_cmpLTMask1_mem( no_rcx_RegI p, no_rcx_RegI q, memory y, rcx_RegI tmp, rFlagsReg cr ) 
%{
  match(Set p (AddI (AndI (CmpLTMask p q) (LoadI y)) (SubI p q)));
  effect( USE_KILL tmp, KILL cr );
  ins_cost(400);

  format %{ "SUB    $p,$q\n\t"
	    "SBB    RCX,RCX\n\t"
	    "AND    RCX,$y\n\t"
	    "ADD    $p,RCX" %}
  ins_encode( enc_cmpLTP_mem(p,q,y,tmp) ); 
%}

instruct cadd_cmpLTMask2_mem( no_rcx_RegI p, no_rcx_RegI q, memory y, rcx_RegI tmp, rFlagsReg cr ) 
%{
  match(Set p (AddI (SubI p q) (AndI (CmpLTMask p q) (LoadI y))));
  effect( USE_KILL tmp, KILL cr );
  ins_cost(400);

  format %{ "SUB    $p,$q\n\t"
	    "SBB    RCX,RCX\n\t"
	    "AND    RCX,$y\n\t"
	    "ADD    $p,RCX" %}
  ins_encode( enc_cmpLTP_mem(p,q,y,tmp) ); 
%}
*/

//---------- FP Instructions------------------------------------------------

instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2) 
%{
  match(Set cr (CmpF src1 src2));

  ins_cost(145);
  format %{ "ucomiss $src1, $src2\n\t"
            "jnp,s   exit\n\t"
            "pushfq\t# saw NaN, set CF\n\t"
            "andq    [rsp], #0xffffff2b\n\t"
            "popfq\n"
    "exit:   nop\t# avoid branch to branch" %}
  opcode(0x0F, 0x2E);
  ins_encode(REX_reg_reg(src1, src2), OpcP, OpcS, reg_reg(src1, src2),
             cmpfp_fixup);
  ins_pipe(pipe_slow);
%}

instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2) 
%{
  match(Set cr (CmpF src1 (LoadF src2)));

  ins_cost(145);
  format %{ "ucomiss $src1, $src2\n\t"
            "jnp,s   exit\n\t"
            "pushfq\t# saw NaN, set CF\n\t"
            "andq    [rsp], #0xffffff2b\n\t"
            "popfq\n"
    "exit:   nop\t# avoid branch to branch" %}
  opcode(0x0F, 0x2E);
  ins_encode(REX_reg_mem(src1, src2), OpcP, OpcS, reg_mem(src1, src2),
             cmpfp_fixup);
  ins_pipe(pipe_slow);
%}

instruct cmpF_cc_imm(rFlagsRegU cr, regF src1, immF src2)
%{
  match(Set cr (CmpF src1 src2));

  ins_cost(145);
  format %{ "ucomiss $src1, $src2\n\t"
            "jnp,s   exit\n\t"
            "pushfq\t# saw NaN, set CF\n\t"
            "andq    [rsp], #0xffffff2b\n\t"
            "popfq\n"
    "exit:   nop\t# avoid branch to branch" %}
  opcode(0x0F, 0x2E);
  ins_encode(REX_reg_mem(src1, src2), OpcP, OpcS, load_immF(src1, src2),
             cmpfp_fixup);
  ins_pipe(pipe_slow);
%}

instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2) 
%{
  match(Set cr (CmpD src1 src2));

  ins_cost(145);
  format %{ "ucomisd $src1, $src2\n\t"
            "jnp,s   exit\n\t"
            "pushfq\t# saw NaN, set CF\n\t"
            "andq    [rsp], #0xffffff2b\n\t"
            "popfq\n"
    "exit:   nop\t# avoid branch to branch" %}
  opcode(0x66, 0x0F, 0x2E);
  ins_encode(OpcP, REX_reg_reg(src1, src2), OpcS, OpcT, reg_reg(src1, src2),
             cmpfp_fixup);
  ins_pipe(pipe_slow);
%}

instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2) 
%{
  match(Set cr (CmpD src1 (LoadD src2)));

  ins_cost(145);
  format %{ "ucomisd $src1, $src2\n\t"
            "jnp,s   exit\n\t"
            "pushfq\t# saw NaN, set CF\n\t"
            "andq    [rsp], #0xffffff2b\n\t"
            "popfq\n"
    "exit:   nop\t# avoid branch to branch" %}
  opcode(0x66, 0x0F, 0x2E);
  ins_encode(OpcP, REX_reg_mem(src1, src2), OpcS, OpcT, reg_mem(src1, src2),
             cmpfp_fixup);
  ins_pipe(pipe_slow);
%}

instruct cmpD_cc_imm(rFlagsRegU cr, regD src1, immD src2) 
%{
  match(Set cr (CmpD src1 src2));

  ins_cost(145);
  format %{ "ucomisd $src1, [$src2]\n\t"
            "jnp,s   exit\n\t"
            "pushfq\t# saw NaN, set CF\n\t"
            "andq    [rsp], #0xffffff2b\n\t"
            "popfq\n"
    "exit:   nop\t# avoid branch to branch" %}
  opcode(0x66, 0x0F, 0x2E);
  ins_encode(OpcP, REX_reg_mem(src1, src2), OpcS, OpcT, load_immD(src1, src2),
             cmpfp_fixup);
  ins_pipe(pipe_slow);
%}

// Compare into -1,0,1
instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
%{
  match(Set dst (CmpF3 src1 src2));
  effect(KILL cr);

  ins_cost(275);
  format %{ "ucomiss $src1, $src2\n\t"
            "movl    $dst, #-1\n\t"
            "jp,s    done\n\t"
            "jb,s    done\n\t"
            "setne   $dst\n\t"
            "movzbl  $dst, $dst\n"
    "done:" %}

  opcode(0x0F, 0x2E);
  ins_encode(REX_reg_reg(src1, src2), OpcP, OpcS, reg_reg(src1, src2),
             cmpfp3(dst));
  ins_pipe(pipe_slow);
%}

// Compare into -1,0,1
instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
%{
  match(Set dst (CmpF3 src1 (LoadF src2)));
  effect(KILL cr);

  ins_cost(275);
  format %{ "ucomiss $src1, $src2\n\t"
            "movl    $dst, #-1\n\t"
            "jp,s    done\n\t"
            "jb,s    done\n\t"
            "setne   $dst\n\t"
            "movzbl  $dst, $dst\n"
    "done:" %}

  opcode(0x0F, 0x2E);
  ins_encode(REX_reg_mem(src1, src2), OpcP, OpcS, reg_mem(src1, src2),
             cmpfp3(dst));
  ins_pipe(pipe_slow);
%}

// Compare into -1,0,1
instruct cmpF_imm(rRegI dst, regF src1, immF src2, rFlagsReg cr)
%{
  match(Set dst (CmpF3 src1 src2));
  effect(KILL cr);

  ins_cost(275);
  format %{ "ucomiss $src1, [$src2]\n\t"
            "movl    $dst, #-1\n\t"
            "jp,s    done\n\t"
            "jb,s    done\n\t"
            "setne   $dst\n\t"
            "movzbl  $dst, $dst\n"
    "done:" %}

  opcode(0x0F, 0x2E);
  ins_encode(REX_reg_mem(src1, src2), OpcP, OpcS, load_immF(src1, src2),
             cmpfp3(dst));
  ins_pipe(pipe_slow);
%}

// Compare into -1,0,1
instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
%{
  match(Set dst (CmpD3 src1 src2));
  effect(KILL cr);

  ins_cost(275);
  format %{ "ucomisd $src1, $src2\n\t"
            "movl    $dst, #-1\n\t"
            "jp,s    done\n\t"
            "jb,s    done\n\t"
            "setne   $dst\n\t"
            "movzbl  $dst, $dst\n"
    "done:" %}

  opcode(0x66, 0x0F, 0x2E);
  ins_encode(OpcP, REX_reg_reg(src1, src2), OpcS, OpcT, reg_reg(src1, src2),
             cmpfp3(dst));
  ins_pipe(pipe_slow);
%}

// Compare into -1,0,1
instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
%{
  match(Set dst (CmpD3 src1 (LoadD src2)));
  effect(KILL cr);

  ins_cost(275);
  format %{ "ucomisd $src1, $src2\n\t"
            "movl    $dst, #-1\n\t"
            "jp,s    done\n\t"
            "jb,s    done\n\t"
            "setne   $dst\n\t"
            "movzbl  $dst, $dst\n"
    "done:" %}

  opcode(0x66, 0x0F, 0x2E);
  ins_encode(OpcP, REX_reg_mem(src1, src2), OpcS, OpcT, reg_mem(src1, src2),
             cmpfp3(dst));
  ins_pipe(pipe_slow);
%}

// Compare into -1,0,1
instruct cmpD_imm(rRegI dst, regD src1, immD src2, rFlagsReg cr)
%{
  match(Set dst (CmpD3 src1 src2));
  effect(KILL cr);

  ins_cost(275);
  format %{ "ucomisd $src1, [$src2]\n\t"
            "movl    $dst, #-1\n\t"
            "jp,s    done\n\t"
            "jb,s    done\n\t"
            "setne   $dst\n\t"
            "movzbl  $dst, $dst\n"
    "done:" %}

  opcode(0x66, 0x0F, 0x2E);
  ins_encode(OpcP, REX_reg_mem(src1, src2), OpcS, OpcT, load_immD(src1, src2),
             cmpfp3(dst));
  ins_pipe(pipe_slow);
%}

instruct addF_reg(regF dst, regF src)
%{
  match(Set dst (AddF dst src));

  format %{ "addss   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF3, 0x0F, 0x58);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow);
%}

instruct addF_mem(regF dst, memory src)
%{
  match(Set dst (AddF dst (LoadF src)));

  format %{ "addss   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF3, 0x0F, 0x58);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow);
%}

instruct addF_imm(regF dst, immF src)
%{
  match(Set dst (AddF dst src));

  format %{ "addss   $dst, [$src]" %}
  ins_cost(150); // XXX
  opcode(0xF3, 0x0F, 0x58);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, load_immF(dst, src));
  ins_pipe(pipe_slow);
%}

instruct addD_reg(regD dst, regD src)
%{
  match(Set dst (AddD dst src));

  format %{ "addsd   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x58);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow);
%}

instruct addD_mem(regD dst, memory src)
%{
  match(Set dst (AddD dst (LoadD src)));

  format %{ "addsd   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x58);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow);
%}

instruct addD_imm(regD dst, immD src)
%{
  match(Set dst (AddD dst src));

  format %{ "addsd   $dst, [$src]" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x58);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, load_immD(dst, src));
  ins_pipe(pipe_slow);
%}

instruct subF_reg(regF dst, regF src)
%{
  match(Set dst (SubF dst src));

  format %{ "subss   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF3, 0x0F, 0x5C);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow);
%}

instruct subF_mem(regF dst, memory src)
%{
  match(Set dst (SubF dst (LoadF src)));

  format %{ "subss   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF3, 0x0F, 0x5C);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow);
%}

instruct subF_imm(regF dst, immF src)
%{
  match(Set dst (SubF dst src));

  format %{ "subss   $dst, [$src]" %}
  ins_cost(150); // XXX
  opcode(0xF3, 0x0F, 0x5C);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, load_immF(dst, src));
  ins_pipe(pipe_slow);
%}

instruct subD_reg(regD dst, regD src)
%{
  match(Set dst (SubD dst src));

  format %{ "subsd   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x5C);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow);
%}

instruct subD_mem(regD dst, memory src)
%{
  match(Set dst (SubD dst (LoadD src)));

  format %{ "subsd   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x5C);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow);
%}

instruct subD_imm(regD dst, immD src)
%{
  match(Set dst (SubD dst src));

  format %{ "subsd   $dst, [$src]" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x5C);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, load_immD(dst, src));
  ins_pipe(pipe_slow);
%}

instruct mulF_reg(regF dst, regF src)
%{
  match(Set dst (MulF dst src));

  format %{ "mulss   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF3, 0x0F, 0x59);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow);
%}

instruct mulF_mem(regF dst, memory src)
%{
  match(Set dst (MulF dst (LoadF src)));

  format %{ "mulss   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF3, 0x0F, 0x59);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow);
%}

instruct mulF_imm(regF dst, immF src)
%{
  match(Set dst (MulF dst src));

  format %{ "mulss   $dst, [$src]" %}
  ins_cost(150); // XXX
  opcode(0xF3, 0x0F, 0x59);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, load_immF(dst, src));
  ins_pipe(pipe_slow);
%}

instruct mulD_reg(regD dst, regD src)
%{
  match(Set dst (MulD dst src));

  format %{ "mulsd   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x59);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow);
%}

instruct mulD_mem(regD dst, memory src)
%{
  match(Set dst (MulD dst (LoadD src)));

  format %{ "mulsd   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x59);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow);
%}

instruct mulD_imm(regD dst, immD src)
%{
  match(Set dst (MulD dst src));

  format %{ "mulsd   $dst, [$src]" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x59);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, load_immD(dst, src));
  ins_pipe(pipe_slow);
%}

instruct divF_reg(regF dst, regF src)
%{
  match(Set dst (DivF dst src));

  format %{ "divss   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF3, 0x0F, 0x5E);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow);
%}

instruct divF_mem(regF dst, memory src)
%{
  match(Set dst (DivF dst (LoadF src)));

  format %{ "divss   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF3, 0x0F, 0x5E);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow);
%}

instruct divF_imm(regF dst, immF src)
%{
  match(Set dst (DivF dst src));

  format %{ "divss   $dst, [$src]" %}
  ins_cost(150); // XXX
  opcode(0xF3, 0x0F, 0x5E);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, load_immF(dst, src));
  ins_pipe(pipe_slow);
%}

instruct divD_reg(regD dst, regD src)
%{
  match(Set dst (DivD dst src));

  format %{ "divsd   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x5E);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow);
%}

instruct divD_mem(regD dst, memory src)
%{
  match(Set dst (DivD dst (LoadD src)));

  format %{ "divsd   $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x5E);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow);
%}

instruct divD_imm(regD dst, immD src)
%{
  match(Set dst (DivD dst src));

  format %{ "divsd   $dst, [$src]" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x5E);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, load_immD(dst, src));
  ins_pipe(pipe_slow);
%}

instruct sqrtD_reg(regD dst, regD src)
%{
  match(Set dst (SqrtD src));

  format %{ "sqrtsd  $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x51);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow);
%}

instruct sqrtD_mem(regD dst, memory src)
%{
  match(Set dst (SqrtD (LoadD src)));

  format %{ "sqrtsd  $dst, $src" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x51);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow);
%}

instruct sqrtD_imm(regD dst, immD src)
%{
  match(Set dst (SqrtD src));

  format %{ "sqrtsd  $dst, [$src]" %}
  ins_cost(150); // XXX
  opcode(0xF2, 0x0F, 0x51);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, load_immD(dst, src));
  ins_pipe(pipe_slow);
%}

instruct absF_reg(regF dst)
%{
  match(Set dst (AbsF dst));

  format %{ "andps   $dst, [0x7fffffff]\t# abs float by sign masking" %}
  ins_encode(absF_encoding(dst));
  ins_pipe(pipe_slow);
%}

instruct absD_reg(regD dst)
%{
  match(Set dst (AbsD dst));

  format %{ "andpd   $dst, [0x7fffffffffffffff]\t"
            "# abs double by sign masking" %}
  ins_encode(absD_encoding(dst));
  ins_pipe(pipe_slow);
%}

instruct negF_reg(regF dst)
%{
  match(Set dst (NegF dst));

  format %{ "xorps   $dst, [0x80000000]\t# neg float by sign flipping" %}
  ins_encode(negF_encoding(dst));
  ins_pipe(pipe_slow);
%}

instruct negD_reg(regD dst)
%{
  match(Set dst (NegD dst));

  format %{ "xorpd   $dst, [0x8000000000000000]\t"
            "# neg double by sign flipping" %}
  ins_encode(negD_encoding(dst));
  ins_pipe(pipe_slow);
%}

//----------Arithmetic Conversion Instructions---------------------------------

instruct roundFloat_nop(regF dst)
%{
  match(Set dst (RoundFloat dst));

  ins_cost(0);
  ins_encode();
  ins_pipe(empty);
%}

instruct roundDouble_nop(regD dst)
%{
  match(Set dst (RoundDouble dst));

  ins_cost(0);
  ins_encode();
  ins_pipe(empty);
%}

instruct convF2D_reg_reg(regD dst, regF src)
%{
  match(Set dst (ConvF2D src));

  format %{ "cvtss2sd $dst, $src" %}
  opcode(0xF3, 0x0F, 0x5A);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow); // XXX
%}

instruct convF2D_reg_mem(regD dst, memory src)
%{
  match(Set dst (ConvF2D (LoadF src)));

  format %{ "cvtss2sd $dst, $src" %}
  opcode(0xF3, 0x0F, 0x5A);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow); // XXX
%}

instruct convD2F_reg_reg(regF dst, regD src)
%{
  match(Set dst (ConvD2F src));

  format %{ "cvtsd2ss $dst, $src" %}
  opcode(0xF2, 0x0F, 0x5A);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow); // XXX
%}

instruct convD2F_reg_mem(regF dst, memory src)
%{
  match(Set dst (ConvD2F (LoadD src)));

  format %{ "cvtsd2ss $dst, $src" %}
  opcode(0xF2, 0x0F, 0x5A);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow); // XXX
%}

// XXX do mem variants
instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr) 
%{
  match(Set dst (ConvF2I src));
  effect(KILL cr);

  format %{ "cvttss2sil $dst, $src\t# f2i\n\t"
            "cmpl    $dst, #0x80000000\n\t"
            "jne,s   done\n\t"
            "subq    rsp, #8\n\t"
            "movss   [rsp], $src\n\t"
            "call    f2i_fixup\n\t"
            "popq    $dst\n"
    "done:   "%}
  opcode(0xF3, 0x0F, 0x2C);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src),
             f2i_fixup(dst, src));
  ins_pipe(pipe_slow);
%}

instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr) 
%{
  match(Set dst (ConvF2L src));
  effect(KILL cr);

  format %{ "cvttss2siq $dst, $src\t# f2l\n\t"
            "cmpq    $dst, [0x8000000000000000]\n\t"
            "jne,s   done\n\t"
            "subq    rsp, #8\n\t"
            "movss   [rsp], $src\n\t"
            "call    f2l_fixup\n\t"
            "popq    $dst\n"
    "done:   "%}
  opcode(0xF3, 0x0F, 0x2C);
  ins_encode(OpcP, REX_reg_reg_wide(dst, src), OpcS, OpcT, reg_reg(dst, src),
             f2l_fixup(dst, src));
  ins_pipe(pipe_slow);
%}

instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr) 
%{
  match(Set dst (ConvD2I src));
  effect(KILL cr);

  format %{ "cvttsd2sil $dst, $src\t# d2i\n\t"
            "cmpl    $dst, #0x80000000\n\t"
            "jne,s   done\n\t"
            "subq    rsp, #8\n\t"
            "movsd   [rsp], $src\n\t"
            "call    d2i_fixup\n\t"
            "popq    $dst\n"
    "done:   "%}
  opcode(0xF2, 0x0F, 0x2C);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src),
             d2i_fixup(dst, src));
  ins_pipe(pipe_slow);
%}

instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr) 
%{
  match(Set dst (ConvD2L src));
  effect(KILL cr);

  format %{ "cvttsd2siq $dst, $src\t# d2l\n\t"
            "cmpq    $dst, [0x8000000000000000]\n\t"
            "jne,s   done\n\t"
            "subq    rsp, #8\n\t"
            "movsd   [rsp], $src\n\t"
            "call    d2l_fixup\n\t"
            "popq    $dst\n"
    "done:   "%}
  opcode(0xF2, 0x0F, 0x2C);
  ins_encode(OpcP, REX_reg_reg_wide(dst, src), OpcS, OpcT, reg_reg(dst, src),
             d2l_fixup(dst, src));
  ins_pipe(pipe_slow);
%}

instruct convI2F_reg_reg(regF dst, rRegI src) 
%{
  match(Set dst (ConvI2F src));

  format %{ "cvtsi2ssl $dst, $src\t# i2f" %}
  opcode(0xF3, 0x0F, 0x2A);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow); // XXX
%}

instruct convI2F_reg_mem(regF dst, memory src) 
%{
  match(Set dst (ConvI2F (LoadI src)));

  format %{ "cvtsi2ssl $dst, $src\t# i2f" %}
  opcode(0xF3, 0x0F, 0x2A);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow); // XXX
%}

instruct convI2D_reg_reg(regD dst, rRegI src) 
%{
  match(Set dst (ConvI2D src));

  format %{ "cvtsi2sdl $dst, $src\t# i2d" %}
  opcode(0xF2, 0x0F, 0x2A);
  ins_encode(OpcP, REX_reg_reg(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow); // XXX
%}

instruct convI2D_reg_mem(regD dst, memory src) 
%{
  match(Set dst (ConvI2D (LoadI src)));

  format %{ "cvtsi2sdl $dst, $src\t# i2d" %}
  opcode(0xF2, 0x0F, 0x2A);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow); // XXX
%}

instruct convL2F_reg_reg(regF dst, rRegL src) 
%{
  match(Set dst (ConvL2F src));

  format %{ "cvtsi2ssq $dst, $src\t# l2f" %}
  opcode(0xF3, 0x0F, 0x2A);
  ins_encode(OpcP, REX_reg_reg_wide(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow); // XXX
%}

instruct convL2F_reg_mem(regF dst, memory src) 
%{
  match(Set dst (ConvL2F (LoadL src)));

  format %{ "cvtsi2ssq $dst, $src\t# l2f" %}
  opcode(0xF3, 0x0F, 0x2A);
  ins_encode(OpcP, REX_reg_mem_wide(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow); // XXX
%}

instruct convL2D_reg_reg(regD dst, rRegL src) 
%{
  match(Set dst (ConvL2D src));

  format %{ "cvtsi2sdq $dst, $src\t# l2d" %}
  opcode(0xF2, 0x0F, 0x2A);
  ins_encode(OpcP, REX_reg_reg_wide(dst, src), OpcS, OpcT, reg_reg(dst, src));
  ins_pipe(pipe_slow); // XXX
%}

instruct convL2D_reg_mem(regD dst, memory src) 
%{
  match(Set dst (ConvL2D (LoadL src)));

  format %{ "cvtsi2sdq $dst, $src\t# l2d" %}
  opcode(0xF2, 0x0F, 0x2A);
  ins_encode(OpcP, REX_reg_mem_wide(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow); // XXX
%}

instruct convI2L_reg_reg(rRegL dst, rRegI src)
%{
  match(Set dst (ConvI2L src));

  ins_cost(125);
  format %{ "movslq  $dst, $src\t# i2l" %}
  opcode(0x63); // needs REX.W
  ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
  ins_pipe(ialu_reg_reg);
%}

// instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
// %{
//   match(Set dst (ConvI2L src));
// //   predicate(_kids[0]->_leaf->is_Type()->type()->is_int()->_lo >= 0 &&
// //             _kids[0]->_leaf->is_Type()->type()->is_int()->_hi >= 0);
//   predicate(((const TypeNode*) n)->type()->is_long()->_hi ==
//             (unsigned int) ((const TypeNode*) n)->type()->is_long()->_hi &&
//             ((const TypeNode*) n)->type()->is_long()->_lo ==
//             (unsigned int) ((const TypeNode*) n)->type()->is_long()->_lo);

//   format %{ "movl    $dst, $src\t# unsigned i2l" %}
//   ins_encode(enc_copy(dst, src));
// //   opcode(0x63); // needs REX.W
// //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
//   ins_pipe(ialu_reg_reg);
// %}

instruct convI2L_reg_mem(rRegL dst, memory src)
%{
  match(Set dst (ConvI2L (LoadI src)));

  format %{ "movslq  $dst, $src\t# i2l" %}
  opcode(0x63); // needs REX.W
  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst,src));
  ins_pipe(ialu_reg_mem);
%}

// Zero-extend convert int to long
instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
%{
  match(Set dst (AndL (ConvI2L src) mask));

  format %{ "movl    $dst, $src\t# i2l zero-extend\n\t" %}
  ins_encode(enc_copy(dst, src));
  ins_pipe(ialu_reg_reg);
%}

// Zero-extend convert int to long
instruct convI2L_reg_reg_reg_zex(rRegL dst, rRegI src, rRegL mask)
%{
  match(Set dst (AndL (ConvI2L src) mask));
  predicate(_kids[1]->_leaf->Opcode() == Op_ConL && 
            _kids[1]->_leaf->is_Type()->type()->is_long()->get_con() == 
            0xFFFFFFFFL);

  format %{ "movl    $dst, $src\t# i2l zero-extend\n\t" %}
  ins_encode(enc_copy(dst, src));
  ins_pipe(ialu_reg_reg);
%}

// Zero-extend convert int to long
instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
%{
  match(Set dst (AndL (ConvI2L (LoadI src)) mask));

  format %{ "movl    $dst, $src\t# i2l zero-extend\n\t" %}
  opcode(0x8B);
  ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
%{
  match(Set dst (AndL src mask));

  format %{ "movl    $dst, $src\t# zero-extend long" %}
  ins_encode(enc_copy_always(dst, src));
  ins_pipe(ialu_reg_reg);
%}

instruct convL2I_reg_reg(rRegI dst, rRegL src) 
%{
  match(Set dst (ConvL2I src));

  format %{ "movl    $dst, $src\t# l2i" %}
  ins_encode(enc_copy_always(dst, src));
  ins_pipe(ialu_reg_reg);
%}


instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
  match(Set dst (MoveF2I src));
  effect(DEF dst, USE src);

  ins_cost(125);
  format %{ "movl    $dst, $src\t# MoveF2I_stack_reg" %}
  opcode(0x8B);
  ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
  match(Set dst (MoveI2F src));
  effect(DEF dst, USE src);

  ins_cost(125);
  format %{ "movss   $dst, $src\t# MoveI2F_stack_reg" %}
  opcode(0xF3, 0x0F, 0x10);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow);
%}

instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
  match(Set dst (MoveD2L src));
  effect(DEF dst, USE src);

  ins_cost(125);
  format %{ "movq    $dst, $src\t# MoveD2L_stack_reg" %}
  opcode(0x8B);
  ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
  ins_pipe(ialu_reg_mem);
%}

instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
  match(Set dst (MoveL2D src));
  effect(DEF dst, USE src);

  ins_cost(125);
  format %{ "movlpd  $dst, $src\t# MoveL2D_stack_reg" %}
  opcode(0x66, 0x0F, 0x12);
  ins_encode(OpcP, REX_reg_mem(dst, src), OpcS, OpcT, reg_mem(dst, src));
  ins_pipe(pipe_slow);
%}


instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
  match(Set dst (MoveF2I src));
  effect(DEF dst, USE src);

  ins_cost(95); // XXX
  format %{ "movss   $dst, $src\t# MoveF2I_reg_stack" %}
  opcode(0xF3, 0x0F, 0x11);
  ins_encode(OpcP, REX_reg_mem(src, dst), OpcS, OpcT, reg_mem(src, dst));
  ins_pipe(pipe_slow);
%}

instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
  match(Set dst (MoveI2F src));
  effect(DEF dst, USE src);

  ins_cost(100);
  format %{ "movl    $dst, $src\t# MoveI2F_reg_stack" %}
  opcode(0x89);
  ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe( ialu_mem_reg );
%}

instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
  match(Set dst (MoveD2L src));
  effect(DEF dst, USE src);

  ins_cost(95); // XXX
  format %{ "movsd   $dst, $src\t# MoveL2D_reg_stack" %}
  opcode(0xF2, 0x0F, 0x11);
  ins_encode(OpcP, REX_reg_mem(src, dst), OpcS, OpcT, reg_mem(src, dst));
  ins_pipe(pipe_slow);
%}

instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
  match(Set dst (MoveL2D src));
  effect(DEF dst, USE src);

  ins_cost(100);
  format %{ "movq    $dst, $src\t# MoveL2D_reg_stack" %}
  opcode(0x89);
  ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
  ins_pipe(ialu_mem_reg);
%}


// =======================================================================
// fast clearing of an array
instruct rep_stos(rcx_RegI cnt, rdi_RegP base, rax_RegI zero, rRegI dummy, 
                  rFlagsReg cr)
%{
  match(Set dummy (ClearArray cnt base));
  effect(USE_KILL cnt, USE_KILL base, KILL zero, KILL cr);

  format %{ "xorl    rax, rax\t# ClearArray:\n\t"
	    "rep stosq\t# Store rax to *rdi++ while rcx--" %}
  ins_encode(opc_reg_reg(0x33, RAX, RAX), // xorl %eax, %eax
             Opcode(0xF3), Opcode(0x48), Opcode(0xAB)); // rep REX_W stos
  ins_pipe(pipe_slow);
%}

instruct string_compare(rdi_RegP str1, rsi_RegP str2, rax_RegI tmp1,
                        rbx_RegI tmp2, rcx_RegI result, rFlagsReg cr)
%{
  match(Set result (StrComp str1 str2));
  effect(USE_KILL str1, USE_KILL str2, KILL tmp1, KILL tmp2, KILL cr);
  //ins_cost(300);

  format %{ "String Compare $str1, $str2 -> $result    // XXX KILL RAX, RBX" %}
  ins_encode( enc_String_Compare() );
  ins_pipe( pipe_slow );
%}

//----------Control Flow Instructions------------------------------------------
// Signed compare Instructions

// XXX more variants!!
instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
%{
  match(Set cr (CmpI op1 op2));
  effect(DEF cr, USE op1, USE op2);

  format %{ "cmpl    $op1, $op2" %}
  opcode(0x3B);  /* Opcode 3B /r */
  ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
  ins_pipe(ialu_cr_reg_reg);
%}

instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
%{
  match(Set cr (CmpI op1 op2));

  format %{ "cmpl    $op1, $op2" %}
  opcode(0x81, 0x07); /* Opcode 81 /7 */
  ins_encode(OpcSErm(op1, op2), Con8or32(op2));
  ins_pipe(ialu_cr_reg_imm);
%}

instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
%{
  match(Set cr (CmpI op1 (LoadI op2)));
 
  ins_cost(500); // XXX
  format %{ "cmpl    $op1, $op2" %}
  opcode(0x3B); /* Opcode 3B /r */
  ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
  ins_pipe(ialu_cr_reg_mem);
%}

instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
%{
  match(Set cr (CmpI src zero));

  format %{ "testl   $src, $src" %}
  opcode(0x85);
  ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
  ins_pipe(ialu_cr_reg_imm);
%}

instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
%{
  match(Set cr (CmpI (AndI src con) zero));

  format %{ "testl   $src, $con" %}
  opcode(0xF7, 0x00);
  ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
  ins_pipe(ialu_cr_reg_imm);
%}

instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
%{
  match(Set cr (CmpI (AndI src (LoadI mem)) zero));

  format %{ "testl   $src, $mem" %}
  opcode(0x85);
  ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
  ins_pipe(ialu_cr_reg_mem);
%}

// Unsigned compare Instructions; really, same as signed except they
// produce an rFlagsRegU instead of rFlagsReg.
instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
%{
  match(Set cr (CmpU op1 op2));

  format %{ "cmpl    $op1, $op2\t# unsigned" %}
  opcode(0x3B); /* Opcode 3B /r */
  ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
  ins_pipe(ialu_cr_reg_reg);
%}

instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
%{
  match(Set cr (CmpU op1 op2));

  format %{ "cmpl    $op1, $op2\t# unsigned" %}
  opcode(0x81,0x07); /* Opcode 81 /7 */
  ins_encode(OpcSErm(op1, op2), Con8or32(op2));
  ins_pipe(ialu_cr_reg_imm);
%}

instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
%{
  match(Set cr (CmpU op1 (LoadI op2)));
 
  ins_cost(500); // XXX
  format %{ "cmpl    $op1, $op2\t# unsigned" %}
  opcode(0x3B); /* Opcode 3B /r */
  ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
  ins_pipe(ialu_cr_reg_mem);
%}

// // // Cisc-spilled version of cmpU_rReg
// //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2) 
// //%{
// //  match(Set cr (CmpU (LoadI op1) op2));
// // 
// //  format %{ "CMPu   $op1,$op2" %}
// //  ins_cost(500);
// //  opcode(0x39);  /* Opcode 39 /r */
// //  ins_encode( OpcP, reg_mem( op1, op2) );
// //%}

instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
%{
  match(Set cr (CmpU src zero));

  format %{ "testl  $src, $src\t# unsigned" %}
  opcode(0x85);
  ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
  ins_pipe(ialu_cr_reg_imm);
%}

instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
%{
  match(Set cr (CmpP op1 op2));

  format %{ "cmpq    $op1, $op2\t# ptr" %}
  opcode(0x3B); /* Opcode 3B /r */
  ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
  ins_pipe(ialu_cr_reg_reg);
%}

instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
%{
  match(Set cr (CmpP op1 (LoadP op2)));
 
  ins_cost(500); // XXX
  format %{ "cmpq    $op1, $op2\t# ptr" %}
  opcode(0x3B); /* Opcode 3B /r */
  ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
  ins_pipe(ialu_cr_reg_mem);
%}

// // // Cisc-spilled version of cmpP_rReg
// //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2) 
// //%{
// //  match(Set cr (CmpP (LoadP op1) op2));
// // 
// //  format %{ "CMPu   $op1,$op2" %}
// //  ins_cost(500);
// //  opcode(0x39);  /* Opcode 39 /r */
// //  ins_encode( OpcP, reg_mem( op1, op2) );
// //%}

// XXX this is generalized by compP_rReg_mem???
// Compare raw pointer (used in out-of-heap check).
// Only works because non-oop pointers must be raw pointers
// and raw pointers have no anti-dependencies.
instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
%{
  predicate(!n->in(2)->in(2)->bottom_type()->isa_oop_ptr());
  match(Set cr (CmpP op1 (LoadP op2)));
 
  format %{ "cmpq    $op1, $op2\t# raw ptr" %}
  opcode(0x3B); /* Opcode 3B /r */
  ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
  ins_pipe(ialu_cr_reg_mem);
%}

// This will generate a signed flags result. This should be OK since
// any compare to a zero should be eq/neq.
instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
%{
  match(Set cr (CmpP src zero));

  format %{ "testq   $src, $src\t# ptr" %}
  opcode(0x85);
  ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
  ins_pipe(ialu_cr_reg_imm);
%}

// This will generate a signed flags result. This should be OK since
// any compare to a zero should be eq/neq.
instruct testP_reg_mem(rFlagsReg cr, memory op, immP0 zero)
%{
  match(Set cr (CmpP (LoadP op) zero));
 
  ins_cost(500); // XXX
  format %{ "testq   $op, 0xffffffffffffffff\t# ptr" %}
  opcode(0xF7); /* Opcode F7 /0 */
  ins_encode(REX_mem_wide(op),
             OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
  ins_pipe(ialu_cr_reg_imm);
%}

// Yanked all unsigned pointer compare operations.
// Pointer compares are done with CmpP which is already unsigned.

instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
%{
  match(Set cr (CmpL op1 op2));

  format %{ "cmpq    $op1, $op2" %}
  opcode(0x3B);  /* Opcode 3B /r */
  ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
  ins_pipe(ialu_cr_reg_reg);
%}

instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
%{
  match(Set cr (CmpL op1 op2));

  format %{ "cmpq    $op1, $op2" %}
  opcode(0x81, 0x07); /* Opcode 81 /7 */
  ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
  ins_pipe(ialu_cr_reg_imm);
%}

instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
%{
  match(Set cr (CmpL op1 (LoadL op2)));
 
  ins_cost(500); // XXX
  format %{ "cmpq    $op1, $op2" %}
  opcode(0x3B); /* Opcode 3B /r */
  ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
  ins_pipe(ialu_cr_reg_mem);
%}

instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
%{
  match(Set cr (CmpL src zero));

  format %{ "testq   $src, $src" %}
  opcode(0x85);
  ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
  ins_pipe(ialu_cr_reg_imm);
%}

instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
%{
  match(Set cr (CmpL (AndL src con) zero));

  format %{ "testq   $src, $con\t# long" %}
  opcode(0xF7, 0x00);
  ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
  ins_pipe(ialu_cr_reg_imm);
%}

instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
%{
  match(Set cr (CmpL (AndL src (LoadL mem)) zero));

  format %{ "testq   $src, $mem" %}
  opcode(0x85);
  ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
  ins_pipe(ialu_cr_reg_mem);
%}

// Manifest a CmpL result in an integer register.  Very painful.
// This is the test to avoid.
instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
%{
  match(Set dst (CmpL3 src1 src2));
  effect(KILL flags);

  ins_cost(275); // XXX
  format %{ "cmpq    $src1, $src2\t# CmpL3\n\t"
            "movl    $dst, -1\n\t"
            "jl,s    done\n\t"
            "setne   $dst\n\t"
            "movzbl  $dst, $dst\n\t"
    "done:" %}
  ins_encode(cmpl3_flag(src1, src2, dst));
  ins_pipe(pipe_slow);
%}

//----------Max and Min--------------------------------------------------------
// Min Instructions

instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr) 
%{
  effect(USE_DEF dst, USE src, USE cr);

  format %{ "cmovlgt  $dst, $src\t# min" %}
  opcode(0x0F, 0x4F);
  ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
  ins_pipe(pipe_cmov_reg);
%}


instruct minI_rReg(rRegI dst, rRegI src)
%{
  match(Set dst (MinI dst src));

  ins_cost(200);
  expand %{
    rFlagsReg cr;
    compI_rReg(cr, dst, src);
    cmovI_reg_g(dst, src, cr);
  %}
%}

instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr) 
%{
  effect(USE_DEF dst, USE src, USE cr);

  format %{ "cmovllt $dst, $src\t# max" %}
  opcode(0x0F, 0x4C);
  ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
  ins_pipe(pipe_cmov_reg);
%}


instruct maxI_rReg(rRegI dst, rRegI src)
%{
  match(Set dst (MaxI dst src));

  ins_cost(200);
  expand %{
    rFlagsReg cr;
    compI_rReg(cr, dst, src);
    cmovI_reg_l(dst, src, cr);
  %}
%}

// ============================================================================
// Branch Instructions

// Jump Direct - Label defines a relative address from JMP+1
instruct jmpDir(label labl)
%{
  match(Goto);
  effect(USE labl);

  ins_cost(300);
  format %{ "jmp     $labl" %}
  size(5);
  opcode(0xE9);
  ins_encode(OpcP, Lbl(labl));
  ins_pipe(pipe_jmp);
  ins_pc_relative(1);
%}

// Jump Direct Conditional - Label defines a relative address from Jcc+1
instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
%{
  match(If cop cr);
  effect(USE labl);

  ins_cost(300);
  format %{ "j$cop     $labl" %}
  size(6);
  opcode(0x0F, 0x80);
  ins_encode(Jcc(cop, labl));
  ins_pipe(pipe_jcc);
  ins_pc_relative(1);
%}

// Jump Direct Conditional - Label defines a relative address from Jcc+1
instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
%{
  match(CountedLoopEnd cop cr);
  effect(USE labl);

  ins_cost(300);
  format %{ "j$cop     $labl\t# loop end" %}
  size(6);
  opcode(0x0F, 0x80);
  ins_encode(Jcc(cop, labl));
  ins_pipe(pipe_jcc);
  ins_pc_relative(1);
%}

// Jump Direct Conditional - Label defines a relative address from Jcc+1
instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl)
%{
  match(CountedLoopEnd cop cmp);
  effect(USE labl);

  ins_cost(300);
  format %{ "j$cop,u   $labl\t# loop end" %}
  size(6);
  opcode(0x0F, 0x80);
  ins_encode(Jcc(cop, labl));
  ins_pipe(pipe_jcc);
  ins_pc_relative(1);
%}

// Jump Direct Conditional - using unsigned comparison
instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl)
%{
  match(If cop cmp);
  effect(USE labl);

  ins_cost(300);
  format %{ "j$cop,u   $labl" %}
  size(6);
  opcode(0x0F, 0x80);
  ins_encode(Jcc(cop, labl));
  ins_pipe(pipe_jcc);
  ins_pc_relative(1);
%}

// ============================================================================
// The 2nd slow-half of a subtype check.  Scan the subklass's 2ndary
// superklass array for an instance of the superklass.  Set a hidden
// internal cache on a hit (cache is checked with exposed code in
// gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
// encoding ALSO sets flags.

instruct partialSubtypeCheck(rdi_RegI result,
                             rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
                             rFlagsReg cr)
%{
  match(Set result (PartialSubtypeCheck sub super));
  effect(KILL rcx, KILL cr);

  ins_cost(1000); // XXX
  format %{ "movq    rdi, [$sub + (sizeof(oopDesc) + Klass::secondary_supers_offset_in_bytes())]\n\t"
            "movl    rcx, [rdi + arrayOopDesc::length_offset_in_bytes()]\t# length to scan\n\t"
            "addq    rdi, arrayOopDex::base_offset_in_bytes(T_OBJECT)\t# Skip to start of data; set NZ in case count is zero\n\t"
            "repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t"
            "jne,s   miss\t\t# Missed: rdi not-zero\n\t"
            "movq    [$sub + (sizeof(oopDesc) + Klass::secondary_super_cache_offset_in_bytes())], $super\t# Hit: update cache\n\t"
            "xorl    $result, $result\t\t Hit: rdi zero\n\t"
    "miss:\t" %}

  opcode(0x1); // Force a XOR of RDI
  ins_encode(enc_PartialSubtypeCheck());
  ins_pipe(pipe_slow);
%}

instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr, 
                                     rsi_RegP sub, rax_RegP super, rcx_RegI rcx, 
                                     rdi_RegI result)
%{
  match(Set cr (PartialSubtypeCheck sub super));
  effect(KILL rcx, KILL result);

  ins_cost(1000);
  format %{ "movq    rdi, [$sub + (sizeof(oopDesc) + Klass::secondary_supers_offset_in_bytes())]\n\t"
            "movl    rcx, [rdi + arrayOopDesc::length_offset_in_bytes()]\t# length to scan\n\t"
            "addq    rdi, arrayOopDex::base_offset_in_bytes(T_OBJECT)\t# Skip to start of data; set NZ in case count is zero\n\t"
            "repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t"
            "jne,s   miss\t\t# Missed: flags nz\n\t"
            "movq    [$sub + (sizeof(oopDesc) + Klass::secondary_super_cache_offset_in_bytes())], $super\t# Hit: update cache\n\t"
    "miss:\t" %}

  opcode(0x0); // No need to XOR RDI
  ins_encode(enc_PartialSubtypeCheck());
  ins_pipe(pipe_slow);
%}

// ============================================================================
// Branch Instructions -- short offset versions
// 
// These instructions are used to replace jumps of a long offset (the default
// match) with jumps of a shorter offset.  These instructions are all tagged
// with the ins_short_branch attribute, which causes the ADLC to suppress the
// match rules in general matching.  Instead, the ADLC generates a conversion
// method in the MachNode which can be used to do in-place replacement of the
// long variant with the shorter variant.  The compiler will determine if a
// branch can be taken by the is_short_branch_offset() predicate in the machine
// specific code section of the file.

// Jump Direct - Label defines a relative address from JMP+1
instruct jmpDir_short(label labl)
%{
  match(Goto);
  effect(USE labl);

  ins_cost(300);
  format %{ "jmp,s   $labl" %}
  size(2);
  opcode(0xEB);
  ins_encode(OpcP, LblShort(labl));
  ins_pipe(pipe_jmp);
  ins_pc_relative(1);
  ins_short_branch(1);
%}

// Jump Direct Conditional - Label defines a relative address from Jcc+1
instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) 
%{
  match(If cop cr);
  effect(USE labl);

  ins_cost(300);
  format %{ "j$cop,s   $labl" %}
  size(2);
  opcode(0x70);
  ins_encode(JccShort(cop, labl));
  ins_pipe(pipe_jcc);
  ins_pc_relative(1);
  ins_short_branch(1);
%}

// Jump Direct Conditional - Label defines a relative address from Jcc+1
instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl)
%{
  match(CountedLoopEnd cop cr);
  effect(USE labl);

  ins_cost(300);
  format %{ "j$cop,s   $labl" %}
  size(2);
  opcode(0x70);
  ins_encode(JccShort(cop, labl));
  ins_pipe(pipe_jcc);
  ins_pc_relative(1);
  ins_short_branch(1);
%}

// Jump Direct Conditional - Label defines a relative address from Jcc+1
instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl)
%{
  match(CountedLoopEnd cop cmp);
  effect(USE labl);

  ins_cost(300);
  format %{ "j$cop,us  $labl" %}
  size(2);
  opcode(0x70);
  ins_encode(JccShort(cop, labl));
  ins_pipe(pipe_jcc);
  ins_pc_relative(1);
  ins_short_branch(1);
%}

// Jump Direct Conditional - using unsigned comparison
instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl)
%{
  match(If cop cmp);
  effect(USE labl);

  ins_cost(300);
  format %{ "j$cop,us  $labl" %}
  size(2);
  opcode(0x70);
  ins_encode(JccShort(cop, labl));
  ins_pipe(pipe_jcc);
  ins_pc_relative(1);
  ins_short_branch(1);
%}

// ============================================================================
// inlined locking and unlocking

instruct cmpFastLock(rFlagsReg cr, 
                     no_rax_RegP object, no_rax_RegP box, rax_RegI tmp)
%{
  match(Set cr (FastLock object box));
  effect(KILL tmp);

  ins_cost(300);
  format %{ "fastlock $object, $box, kills rax" %}
  ins_encode(Fast_Lock(object, box, tmp));
  ins_pipe(pipe_slow);
  ins_pc_relative(1);
%}

instruct cmpFastUnlock(rFlagsReg cr,
                       no_rax_rbx_RegP object, rax_RegP box, rbx_RegP tmp)
%{
  match(Set cr (FastUnlock object box));
  effect(KILL box, KILL tmp);

  ins_cost(300);
  format %{ "fastunlock $object, kills $box, rbx" %}
  ins_encode(Fast_Unlock(object, box, tmp));
  ins_pipe(pipe_slow);
  ins_pc_relative(1);
%}

// ============================================================================
// Safepoint Instructions

instruct safePoint()
%{
  match(SafePoint);
  predicate(!SafepointPolling);

  format %{ "Safepoint_ " %}
  ins_encode();
  opcode(0x90); /* NOP = 0x90 */
  ins_encode(OpcP, OpcP, safepoint_reloc);
  ins_pipe(empty);
%}

instruct safePoint_poll(rFlagsReg cr)
%{
  match(SafePoint);
  predicate(SafepointPolling);
  effect(KILL cr);

  format %{ "testl   rax, [rip + #offset_to_poll_page]\t"
            "# Safepoint: poll for GC" %}
  size(6); // Opcode + ModRM + Disp32 == 6 bytes
  ins_cost(125);
  ins_encode(enc_safepoint_poll);
  ins_pipe(ialu_reg_mem);
%}

// ============================================================================
// Procedure Call/Return Instructions
// Call Java Static Instruction
// Note: If this code changes, the corresponding ret_addr_offset() and
//       compute_padding() functions will have to be adjusted.
instruct CallStaticJavaDirect(method meth)
%{
  match(CallStaticJava);
  effect(USE meth);

  ins_cost(300);
  format %{ "call,static " %}
  opcode(0xE8); /* E8 cd */
  ins_encode(Java_Static_Call(meth), call_epilog);
  ins_pipe(pipe_slow);
  ins_pc_relative(1);
  ins_alignment(4);
%}

// Call Java Dynamic Instruction
// Note: If this code changes, the corresponding ret_addr_offset() and
//       compute_padding() functions will have to be adjusted.
instruct CallDynamicJavaDirect(method meth)
%{
  match(CallDynamicJava);
  effect(USE meth);

  ins_cost(300);
  format %{ "movq    rax, #Universe::non_oop_word()\n\t"
	    "call,dynamic " %}
  opcode(0xE8); /* E8 cd */
  ins_encode(Java_Dynamic_Call(meth), call_epilog);
  ins_pipe(pipe_slow);
  ins_pc_relative(1);
  ins_alignment(4);
%}

// Call Compiled Java Instruction
// Required: Used in converter frame from interpreter to compiler
instruct CallCompiledJavaDirect(method meth, rbp_RegP interp_fp)
%{
  match(CallCompiledJava);
  effect(USE meth, KILL interp_fp);

  ins_cost(300);
  format %{ "call,compiled *[rax+compiled_code_entry_point_offset]" %}
  opcode(0xFF, 0x02); /* FF /2 */
  ins_encode(Java_Compiled_Call(meth));
  ins_pipe(pipe_slow);
  ins_pc_relative(1);
%}

// Call Java Interpreter Instruction
// Required: Used in converter frame from compiled code to interpreter
// Note: If this code changes, the corresponding ret_addr_offset() and
//       compute_padding() functions will have to be adjusted.
instruct CallInterpreterDirect(method meth)
%{
  match(CallInterpreter);
  effect(USE meth);

  ins_cost(300);
  format %{ "xorl    rbp, rbp\n\t"
            "call,interpreter " %}
  opcode(0xE8); /* E8 cd */
  ins_encode(opc_reg_reg(0x33, RBP, RBP), 
             Java_To_Interpreter(meth));
  ins_pipe(pipe_slow);
  ins_pc_relative(1);
  ins_alignment(4);
%}

// Call Runtime Instruction
instruct CallRuntimeDirect(method meth)
%{
  match(CallRuntime);
  effect(USE meth);

  ins_cost(300);
  format %{ "call,runtime " %}
  opcode(0xE8); /* E8 cd */
  ins_encode(Java_To_Runtime(meth));
  ins_pipe(pipe_slow);
  ins_pc_relative(1);
%}

// Call runtime without safepoint
instruct CallLeafDirect(method meth)
%{
  match(CallLeaf);
  effect(USE meth);

  ins_cost(300);
  format %{ "call_leaf,runtime " %}
  opcode(0xE8); /* E8 cd */
  ins_encode(Java_To_Runtime(meth));
  ins_pipe(pipe_slow);
  ins_pc_relative(1);
%}

// Call runtime without safepoint
instruct CallLeafNoFPDirect(method meth)
%{
  match(CallLeafNoFP);
  effect(USE meth);

  ins_cost(300);
  format %{ "call_leaf_nofp,runtime " %}
  opcode(0xE8); /* E8 cd */
  ins_encode(Java_To_Runtime(meth));
  ins_pipe(pipe_slow);
  ins_pc_relative(1);
%}

// Return Instruction
// Remove the return address & jump to it.
// Notice: We always emit a nop after a ret to make sure there is room 
// for safepoint patching
instruct Ret()
%{
  match(Return);
  
  format %{ "ret\t# with nops for safepoint patching\n\t"
	    "nop  # without if SafepointPolling\n\t"
	    "nop" %}
  opcode(0xC3);  
  ins_encode(RetWithNops());
  ins_pipe(pipe_jmp);
%}

// Tail Call; Jump from runtime stub to Java code.
// Also known as an 'interprocedural jump'.
// Target of jump will eventually return to caller.
// TailJump below removes the return address.
instruct TailCalljmpInd(rRegP jump_target, rax_RegP method_oop)
%{
  match(TailCall jump_target method_oop);

  ins_cost(300);
  format %{ "jmp     $jump_target\t# rax holds method oop" %}
  opcode(0xFF, 0x4); /* Opcode FF /4 */
  ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
  ins_pipe(pipe_jmp);
%}

// Tail Jump; remove the return address; jump to target.
// TailCall above leaves the return address around.
instruct tailjmpInd(rRegP jump_target, rax_RegP ex_oop)
%{
  match(TailJump jump_target ex_oop);

  ins_cost(300);
  format %{ "popq    rdx\t# pop return address\n\t"
	    "jmp     $jump_target" %}
  opcode(0xFF, 0x4); /* Opcode FF /4 */
  ins_encode(Opcode(0x5a), // popq rdx
             REX_reg(jump_target), OpcP, reg_opc(jump_target));
  ins_pipe(pipe_jmp);
%}

// Create exception oop: created by stack-crawling runtime code.
// Created exception is now available to this handler, and is setup
// just prior to jumping to this handler.  No code emitted.
instruct CreateException(rax_RegP ex_oop)
%{
  match(Set ex_oop (CreateEx));

  size(0);
  // use the following format syntax
  format %{ "# exception oop is in rax; no code emitted" %}
  ins_encode();
  ins_pipe(empty);
%}

// Rethrow exception: 
// The exception oop will come in the first argument position.
// Then JUMP (not call) to the rethrow stub code.
instruct RethrowException()
%{
  match(Rethrow);

  // use the following format syntax
  format %{ "jmp     rethrow_stub" %}
  ins_encode(enc_rethrow);
  ins_pipe(pipe_jmp);
%}


//----------PEEPHOLE RULES-----------------------------------------------------
// These must follow all instruction definitions as they use the names
// defined in the instructions definitions.
// 
// peepmatch ( root_instr_name [precerding_instruction]* );
//
// peepconstraint %{
// (instruction_number.operand_name relational_op instruction_number.operand_name
//  [, ...] );
// // instruction numbers are zero-based using left to right order in peepmatch
//
// peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
// // provide an instruction_number.operand_name for each operand that appears
// // in the replacement instruction's match rule
//
// ---------VM FLAGS---------------------------------------------------------
// 
// All peephole optimizations can be turned off using -XX:-OptoPeephole
// 
// Each peephole rule is given an identifying number starting with zero and
// increasing by one in the order seen by the parser.  An individual peephole
// can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
// on the command-line.
// 
// ---------CURRENT LIMITATIONS----------------------------------------------
// 
// Only match adjacent instructions in same basic block
// Only equality constraints
// Only constraints between operands, not (0.dest_reg == RAX_enc)
// Only one replacement instruction
//
// ---------EXAMPLE----------------------------------------------------------
//
// // pertinent parts of existing instructions in architecture description
// instruct movI(rRegI dst, rRegI src) 
// %{
//   match(Set dst (CopyI src));
// %}
// 
// instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr) 
// %{
//   match(Set dst (AddI dst src));
//   effect(KILL cr);
// %}
// 
// // Change (inc mov) to lea
// peephole %{
//   // increment preceeded by register-register move
//   peepmatch ( incI_rReg movI );
//   // require that the destination register of the increment 
//   // match the destination register of the move
//   peepconstraint ( 0.dst == 1.dst );
//   // construct a replacement instruction that sets
//   // the destination to ( move's source register + one )
//   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
// %}
// 

// Implementation no longer uses movX instructions since 
// machine-independent system no longer uses CopyX nodes.
//
// peephole
// %{
//   peepmatch (incI_rReg movI);
//   peepconstraint (0.dst == 1.dst);
//   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
// %}

// peephole
// %{
//   peepmatch (decI_rReg movI);
//   peepconstraint (0.dst == 1.dst);
//   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
// %}

// peephole
// %{
//   peepmatch (addI_rReg_imm movI);
//   peepconstraint (0.dst == 1.dst);
//   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
// %}

// peephole
// %{
//   peepmatch (incL_rReg movL);
//   peepconstraint (0.dst == 1.dst);
//   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
// %}

// peephole
// %{
//   peepmatch (decL_rReg movL);
//   peepconstraint (0.dst == 1.dst);
//   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
// %}

// peephole
// %{
//   peepmatch (addL_rReg_imm movL);
//   peepconstraint (0.dst == 1.dst);
//   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
// %}

// peephole
// %{
//   peepmatch (addP_rReg_imm movP);
//   peepconstraint (0.dst == 1.dst);
//   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
// %}

// // Change load of spilled value to only a spill
// instruct storeI(memory mem, rRegI src) 
// %{
//   match(Set mem (StoreI mem src));
// %}
// 
// instruct loadI(rRegI dst, memory mem) 
// %{
//   match(Set dst (LoadI mem));
// %}
// 

peephole
%{
  peepmatch (loadI storeI);
  peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
  peepreplace (storeI(1.mem 1.mem 1.src));
%}

peephole
%{
  peepmatch (loadL storeL);
  peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
  peepreplace (storeL(1.mem 1.mem 1.src));
%}

//----------SMARTSPILL RULES---------------------------------------------------
// These must follow all instruction definitions as they use the names
// defined in the instructions definitions.
