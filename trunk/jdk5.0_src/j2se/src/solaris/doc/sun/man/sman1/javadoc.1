<!DOCTYPE REFENTRY PUBLIC "-//Sun Microsystems//DTD DocBook V3.0-Based SolBook Subset V2.0//EN" [
<!--ArborText, Inc., 1988-1999, v.4002-->
<!ENTITY % javaents SYSTEM "javaman.ent">
%javaents;
]>
<?Pub UDT _bookmark _target>
<?Pub EntList minus bsol>
<?Pub Inc>
<refentry id="javadoc-1">
<!--@(#)javadoc.1 1.16 01/03/14 SMI;-->
<refmeta><refentrytitle>javadoc</refentrytitle><manvolnum>1</manvolnum>
<refmiscinfo class="date">23 Apr 2001</refmiscinfo>
<refmiscinfo class="sectdesc">&man1;</refmiscinfo>
<refmiscinfo class="software">&java-release;</refmiscinfo>
<refmiscinfo class="arch">generic</refmiscinfo>
<refmiscinfo class="copyright"> Copyright 2001 Sun Microsystems, Inc. All
rights reserved.  Copyright 2001 Sun Microsystems, Inc. Tous droits r&eacute;serv&eacute;s.
</refmiscinfo>
</refmeta>
<refnamediv><refname>javadoc</refname><refpurpose>Java API documentation generator
</refpurpose></refnamediv>
<refsynopsisdiv><title>&synp-tt;</title>
<cmdsynopsis><command>javadoc</command><arg choice="opt"><replaceable>options
</replaceable></arg><arg choice="opt"><replaceable>packagenames</replaceable></arg>
<arg choice="opt"><replaceable>sourcefilenames</replaceable></arg><arg choice="opt"><replaceable>
subpackages [pkg1:pkg2:...]</replaceable></arg><arg choice="opt"><replaceable>
@argfiles</replaceable></arg>
</cmdsynopsis></refsynopsisdiv>
<refsect1><title>ARGUMENTS</title>
<para>Arguments can be in any order.  </para>
<variablelist termlength="narrow">
<varlistentry><term remap="15"><replaceable>options</replaceable> </term>
<listitem><para>Command-line options, as specified in this document. To see
a typical use of <command>javadoc</command> options, see <literal>Real World
Example</literal>.</para>
</listitem></varlistentry>
<varlistentry><term><replaceable>packagenames</replaceable> </term><listitem>
<para>A series of names of packages, separated by spaces, such as <literal>
java.lang java.lang.reflect java.awt</literal>. You must separately specify
each package you want to document. The Javadoc tool uses <option>sourcepath
</option> to look for these package names. The Javadoc tool does not recursively
traverse subpackages. Wildcards such as asterisks (<literal>*</literal>) are
not allowed. See EXAMPLES, <literal>Documenting One or More Packages</literal>.
</para>
</listitem></varlistentry>
<varlistentry><term><replaceable>sourcefilenames</replaceable> </term><listitem>
<para>A series of source file names, separated by spaces, each of which canbegin
with a path and contain a wildcard such as asterisk (<literal>*</literal>).
The Javadoc tool will process every file whose name ends with <literal>.java
</literal>, and whose name, when stripped of that suffix, is actually a legal
class name (see <literal>Identifiers</literal>). Therefore, you can name files
with dashes (such as <literal>X-Buffer</literal>), or other illegl characters,
to prevent them from being documented. This is useful for test files and files
generated from templates. The path that precedes the source file name determines
where <command>javadoc</command> will look for it. (The Javadoc tool does
not use <option>sourcepath</option> to look for these source file names.)
For example, passing in <literal>Button.java</literal> is identical to <literal>
./Button.java</literal>. An example source file name with a full path is <literal>
/home/src/java/awt/Graphics*.java</literal>. See EXAMPLES, <literal>Documenting
One or More Classes</literal>. You can also mix  <replaceable>packagenames
</replaceable> and <replaceable>sourcefilenames</replaceable>, as in EXAMPLES, <literal>
Documenting Both Packages and Classes</literal>.</para>
</listitem></varlistentry>
<varlistentry><term><replaceable>subpackages pkg1:pkg2:...</replaceable></term>
<listitem><para>Generates documentation from source files in the specified
packages and recursively in their subpackages. An alternative to supplying
packagenames or sourcefilenames. </para>
</listitem></varlistentry>
<varlistentry><term><replaceable>@argfiles</replaceable> </term><listitem>
<para>One or more files that contain a list of Javadoc options, <replaceable>
packagenames</replaceable> and <replaceable>sourcefilenames</replaceable>
in any order. Wildcards (<literal>*</literal>) and <replaceable>-J</replaceable>
options are not allowed in these files. </para>
</listitem></varlistentry>
</variablelist></refsect1>
<refsect1><title>DESCRIPTION</title>
<para>The Javdoc tool parses the declarations and documentation comments in
a set of Java source files and produces a corresponding set of HTML pages
describing (by default) the public and protected classes, nested classes (but
not anonymous inner classes), interfaces, constructors, methods, and fields.
</para>
<para>You can run the Javadoc tool on entire packages, individual source files,
or both. In the first case, you pass in as an argument to <command>javadoc
</command> a series of package names. In the second case, you pass in a series
of source (<literal>.java</literal>) file names. EXAMPLESare given at the
end of this document.</para>
<para><emphasis>Note</emphasis>: When you pass in package names to the Javadoc
tool, it currently processes all <literal>.java</literal> classes in the specified
package directories, even if the <literal>.java</literal> files are code examples
or other classes that are not actually members of the specified packages.
It does not parse each <literal>.java</literal> file for a package declaration;
we may add this parsing in a future release.</para>
<para>During a run, the Javadoc tool automatically adds cross-reference links
to package, class and member names that are being documented as part of that
run. Links appear in several places: <itemizedlist>
<listitem><para>Declarations (return types, argument types, field types) 
</para></listitem>
<listitem><para>"See Also" sections generated from<literal> @see</literal>
tags</para></listitem>
<listitem><para>In-line text generated from<literal> {@link}</literal> tags 
</para></listitem>
<listitem><para>Exception names generated from <literal>@throws</literal>
tags </para></listitem>
<listitem><para><literal>Specified by</literal> links to members in interfaces
and <literal>Overrides links</literal> to members in classes </para></listitem>
<listitem><para>Summary tables listing packages, classes and members </para>
</listitem>
<listitem><para>Package and class inheritance trees </para></listitem>
<listitem><para>The index </para></listitem>
</itemizedlist></para>
<para>You can add hyperlinks to existing text for classes not included on
the command line (but generated separately) by way of the<literal> link</literal>
and<literal> linkoffline</literal> options. </para>
<para>The Javadoc tool produces one complete document each time it is run;
it cannot do incremental builds &mdash; that is, it cannot modify or <emphasis>
directly</emphasis> incorporate results from previous runs of the Javadoc
tool. However, it can link to results from previous runs, as just mentioned.
</para>
<para>As implemented, the Javadoc tool requires and relies on the java compiler
to do its job. The Javadoc tool calls part of <command>javac</command> to
compile the declarations, ignoring the member implementation. It builds a
rich internal representation of the classes, including the class hierarchy,
and "use" relationships, then generates the HTML from that. <command>javadoc
</command> also picks up user-supplied documentation from documentation comments
in the source code.</para>
<para>In fact, the Javadoc tool will run on <literal>.java</literal> source
files that are pure stub files with no method bodies. This means you can write
documentation comments and run the Javadoc tool in the earliest stages of
design while creating the <acronym>API</acronym>, before writing the implementation.
</para>
<para>Relying on the compiler ensures that the HTML output corresponds exactly
with the actual implementation, which may rely on implicit, rather than explicit,
source code. For example, the Javadoc tool will document default constructors
(section 8.6.7 of Java Language Specification) that are present in the <literal>
.class</literal> files but not in the source code.</para>
<para>In many cases, the Javadoc tool allows you to generate documentation
for source files whose code is incomplete or erroneous. This is a benefit
that enables you to generate documentation before all debugging and troubleshooting
is done. For example, according to the       Java Language Specification,
a class that contains an abstract method should itself be declared abstract.
The Javadoc tool does not check for this, and would proceed without a warning,
whereas the javac compiler stops on this error. The Javadoc tool does do some
primitive checking of doc comments. Use the DocCheck doclet to check the doc
comments more thoroughly. </para>
<para>When the Javadoc tool builds its internal structure for the documentation,
it loads all referenced classes. Because of this, the Javadoc tool must be
able to find all referenced classes, whether bootstrap classes, extensions,
or user classes. For more about this, see <literal>How Classes are Found</literal>.
Generally speaking, classes you create must either be loaded as an extension
or in the class path of <command>javadoc</command>.</para>
<refsect2>
<title>javadoc Doclets</title>
<para>You can customize the content and format of  the Javadoc tool's output
by using doclets. The Javadoc tool has a default "built-in" doclet, called
the standard doclet, that generates HTML-formatted <acronym>API</acronym>
documentation. You can modify or subclass the standard doclet, or write your
own doclet to generate HTML, XML, MIF, RTF or whatever output format you'd
like. Information about doclets and their use is at the following locations:
</para>
<itemizedlist>
<listitem><para><command>Javadoc</command> Doclets</para></listitem>
<listitem><para>The <option>doclet</option> command-line option</para></listitem>
</itemizedlist>
<para>When a custom doclet is not specified with the <option>doclet</option>
command line option, the Javadoc tool will use the default standard doclet.
The Javadoc tool has several command line options that are available regardless
of which doclet is being used. The standard doclet adds a supplementary set
of command line options. Both sets of options are described below in the options
section.</para>
</refsect2>
<refsect2>
<title>Related Documentation and Doclets</title>
<itemizedlist>
<listitem><para><literal>Javadoc Enhancements</literal> for details about
improvements added in Javadoc 1.4. </para></listitem>
<listitem><para><literal>Javadoc FAQ</literal> for answers to common questions,
information about Javadoc-related tools, and workarounds for bugs. </para>
</listitem>
<listitem><para><literal>How to Write Doc Comments for Javadoc</literal> for
more information about Sun conventions for writing documentation comments. 
</para></listitem>
<listitem><para><literal>Requirements for Writing API Specifications</literal>
- Standard requirements used when writing the Java 2 Platform Specification.
It can be useful whether you are writing API specifications in source file
documentation comments or in other formats. It covers requirements for packages,
classes, interfaces, fields and methods to satisfy testable assertions. </para>
</listitem>
<listitem><para><literal>Documentation Comment Specification</literal> - The
original specification on documentation comments, Chapter 18, Documentation
Comments, in the Java Language Specification, First Edition, by James Gosling,
Bill Joy, and Guy Steele. (This             chapter was removed from the second
edition.) </para></listitem>
<listitem><para><literal>DocCheck Doclet</literal> - Checks doc comments in
source files and             generates a report listing the errors and irregularities
it finds. It is part of the Sun Doc Check Utilities. </para></listitem>
<listitem><para><literal>MIF Doclet</literal> - Can automate the generation
of API documentation in MIF, FrameMaker and PDF formats. MIF is Adobe FrameMaker's
interchange format. </para></listitem>
</itemizedlist>
</refsect2>
<refsect2>
<title>Terminology</title>
<para>A few terms have specific meanings within the context of the Javadoc
tool:: </para>
<variablelist termlength="medium">
<varlistentry><term remap="20">generated document</term><listitem><para>The
document generated by the <command>javadoc</command> tool from the doc comments
in Java source code. The default generated document is in HTML and is created
by the standard doclet.</para>
</listitem></varlistentry>
<varlistentry><term>name</term><listitem><para>A name in the Java Language,
namely the name of a package, class, interface, field, constructor, or method.
A name can be fully-qualified, such as <literal>java.lang.String.equals(java.lang.Object)
</literal>, or partially-qualified, such as <literal>equals(Object)</literal>.
</para>
</listitem></varlistentry>
<varlistentry><term>documented classes</term><listitem><para>The classes and
interfaces for which full documentation is generated during a <command>javadoc
</command> run. To be documented, the source files must be available, and
either their source filenames or package names must be passed into the <command>
javadoc</command> command. We also refer to these as the classes included
in the <command>javadoc</command> run, or the included classes.</para>
</listitem></varlistentry>
<varlistentry><term>excluded classes</term><listitem><para>Classes and interfaces
whose source filenames or package names are not passed into the <command>
javadoc</command> command.</para>
</listitem></varlistentry>
<varlistentry><term>referenced classes</term><listitem><para>The classes and
interfaces that are explicitly referred to in the definition (implementation)
or doc comments of the documented classes and interfaces. Examples of references
include return type, parameter type, cast type, extended class, implemented
interface, imported classes, classes used in method bodies, <literal>@see
</literal>,<literal> {@link}</literal>, <literal>{@linkplain}</literal>, and<literal>
 {@inheritDoc}</literal> tags. (Notice that this definition has changed since
1.3.) When the Javadoc too is run, it should load into memory all of the referenced
classes in the javadoc's bootclasspath and classpath. (The Javadoc tool prints
a "Class not found" warning for referenced classes not found.) The Javadoc
tool can derive enough information from the <literal>.class</literal> files
to determine their existence and the fully qualified names of their members.
</para>
</listitem></varlistentry>
<varlistentry><term>external referenced classes</term><listitem><para>The
referenced classes whose documentation is not being generated during a <command>
javadoc</command> run. In other words, these classes are not passed into the
Javadoc tool on the command line. Links in the generated documentation to
those classes are said to be external references or external links. For example,
if you run the Javadoc tool on only the <literal>java.awt</literal> package,
then any class in <literal>java.lang</literal>, such as Object, is an external
referenced class. External referenced classes can be linked to using the <option>
link</option>and <option>linkoffline</option>options.An important property
of an external             referenced class is that its source comments are
normally not available to the Javadoc run. In this case, these comments cannot
be inherited. </para>
</listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title>Source Files</title>
<para>The Javadoc tool generates output originating from four different types
of "source" files: Java language source files for classes (<literal>.java
</literal>), package comment files, overview comment files, and miscellaneous
unprocessed files.</para>
</refsect2>
<refsect2>
<title>Class Source Code Files</title>
<para>Each class or interface and its members can have their own documentation
comments, contained in a <literal>.java</literal> file. For more details about
these doc commments, see <literal>Documentation Comments</literal>.</para>
</refsect2>
<refsect2>
<title>Package Comment Files</title>
<para>Each package can have its own documentation comment, contained in its
own "source" file, that the Javadoc tool will merge into the package summary
page that it generates. You typically include in this comment any documentation
that applies to the entire package.</para>
<para>To create a package comment file, you must name it  <literal>package.html
</literal> and place it in the package directory in the source tree along
with the <literal>.java</literal> files. The Javadoc tool will automatically
look for this filename in this location. Notice that the filename is identical
for all packages. For explicit details, see the example of <literal>package.html
</literal>. </para>
<para>The content of the package comment file is one big documentation comment,
written in HTML, like all other comments, with one exception: the documentation
comment should not include the comment separators /** and */ or leading asterisks.
When writing the comment, you should make the first sentence a summary about
the package, and not put a title or any other text between <literal>&lt;body>
</literal> and the first sentence. You can include package tags. As with any
documentation comment, all tags except {<literal>@link</literal>} must appear
after the description. If you add a <literal>@see</literal> tag in a package
comment file, it must have a fully qualified name.</para>
<para>When the Javadoc tool runs, it will automatically look for this file;
if found, the Javadoc tool does the following:</para>
<itemizedlist>
<listitem><para>Copies all content between <literal>&lt;body></literal> and
 <literal>&lt;/body></literal> tags for processing.</para></listitem>
<listitem><para>Processes any package tags that are present.</para></listitem>
<listitem><para>Inserts the processed text at the bottom of the package summary
page it generates, as shown in Package Summary.</para></listitem>
<listitem><para>Copies the first sentence of the package comment to the top
of the package summary page. It also adds the package name and this first
sentence to the list of packages on the overview page, as shown in <literal>
Overview Summary</literal>. The end-of-sentence is determined by the same
rules used for the end of the first sentence of class and member descriptions.
</para></listitem>
</itemizedlist>
</refsect2>
<refsect2>
<title>Overview Comment File</title>
<para>Each application or set of packages that you are documenting can have
its own overview documentation comment, kept in its own "source" file, that
the Javadoc tool will merge into the overview page that it generates. You
typically include in this comment any documentation that applies to the entire
application or set of packages.</para>
<para>To create an overview comment file, you can name the file anything you
want, typically <literal>overview.html</literal>, and place it anywhere, typically
at the top level of the source tree. Notice you can have multiple overview
comment files for the same set of source files, in case you want to run <command>
javadoc</command> multiple times on different sets of packages. For example,
if the source files for the <literal>java.applet</literal> package are contained
in <literal>/home/user/src/java/applet</literal> directory, you could create
an overview comment file at <literal>/home/user/src/overview.html</literal>.
</para>
<para>The content of the overview comment file is one big documentation comment,
written in HTML, like the package comment file described previously. See that
description for details. See that description for details. To reiterate, when
writing the comment, you should make the first sentence a summary about the
application or set of packages, and not put a title or any other text between
 <literal>&lt;body></literal> and the first sentence. You can include overview
tags; as with any documentation comment, all tags except in-line tags, such
as {<literal>@link</literal>} must appear after the description. If you add
a <literal>@see</literal> tag, it must have a fully-qualified name.</para>
<para>When you run the Javadoc tool, you specify the overview comment file
name with the <option>overview</option> option. The file is then processed,
similar to that of a package comment file:</para>
<itemizedlist>
<listitem><para>Copies all content between  <literal>&lt;body></literal> and
 <literal>&lt;/body></literal> tags for processing.</para></listitem>
<listitem><para>Processes any overview tags that are present.</para></listitem>
<listitem><para>Inserts the processed text at the bottom of the overview page
it generates, as shown in <literal>Overview Summary</literal>.</para></listitem>
<listitem><para>Copies the first sentence of the overview comment to the top
of the overview summary page.</para></listitem>
</itemizedlist>
</refsect2>
<refsect2>
<title>Miscellaneous Unprocessed Files</title>
<para>You can also include in your source any miscellaneous files that you
want the Javadoc tool to copy to the destination directory. These typically
include graphic files, example Java source (<literal>.java</literal>) and
class (<literal>.class</literal>) files, and self-standing HTML files whose
content would overwhelm the documentation comment of a normal Java source
file.</para>
<para>To include unprocessed files, put them in a directory called <literal>
doc-files</literal>, which can be a subdirectory of any package directory.
You can have one such subdirectory for each package. You might include images,
example code, source files, <literal>.class</literal> files, applets, and
HTML files. For example, if you want to include the image of a button <literal>
button.gif</literal> in the  <literal>java.awt.Button</literal> class documentation,
you place that file in the <literal>/home/user/src/java/awt/doc-files/</literal>
directory. Notice the <literal>doc-files</literal> directory should not be
located at <literal>/home/user/src/java/doc-files</literal> because <literal>
java</literal> is not a package -- that is, it does not directly contain any
source files. </para>
<para>All links to these unprocessed files must be hard-coded, because the
Javadoc tool does not look at the file &mdash; it simply copies the directory
and all its contents to the destination. For example, the link in the <literal>
Button.java</literal> doc comment might look like this:<informalexample>
<screen><userinput>/**
* This button looks like this:
* &lt;img src="doc-files/Button.gif">
*/</userinput></screen>
</informalexample></para>
</refsect2>
<refsect2>
<title>Test Files and Template Files</title>
<para>Some developers have indicated they want to store test files and templates
files in the source tree near their corresponding source files. That is, they
would like to put them in the same directory, or a subdirectory, of those
source files.</para>
<para>If you run the Javadoc tool by explicitly passing in individual source
file names, you can deliberately omit test and templates files and prevent
them from being processed. However, if you are passing in package names or
wildcards, you need to follow certain rules to ensure these test files and
templates files are not processed.</para>
<para>Test files differ from template files in that the former are legal,
compilable source files, while the latter are not, but may end with ".java".
</para>
<para>Test files - Often developers want to put compilable, runnable test
files for a given package in the same directory as the source files for that
package. But they want the test files to belong to a package other than the
source file package, such as the unnamed package (so the test files have no
package statement or a different package statement from the source). In this
scenario, when the source is being documented by specifying its package name
specified on the command line, the test files will cause warnings or errors.
You need to put such test files in a subdirectory. For example, if you want
to add test files for source files in <literal>com.package1</literal>, put
them in a subdirectory that would be an invalid package name (because it contains
a hyphen): </para>
<screen>com/package1/test-files/</screen>
<para>The test directory will be skipped by the Javadoc tool with no warnings. 
</para>
<para>If your test files contain doc comments, you can set up a separate run
of the Javadoc tool to produce documentation of the test files by passing
in their test source filenames with wildcards, such as <literal>com/package1/test-files/*.java
</literal>. </para>
<para>Templates for source files - Template files have names that often end
in ".java" and are not compilable. If you have a template for a source file
that you want to keep in the source directory, you can name it with a dash
(such as <literal>Buffer-Template.java</literal>), or any other illegal Java
character, to prevent it from being processed. This relies on the fact that
the Javadoc tool will only process source files whose name, when stripped
of the ".java" suffix, is actually a legal class name (see Identifiers). 
</para>
</refsect2>
<refsect2>
<title>Generated Files</title>
<para>By default, <command>javadoc</command> uses a standard doclet that generates
HTML-formatted documentation. This doclet generates the following kinds of
files (where each HTML "page" corresponds to a separate file). Note that <command>
javadoc</command> generates files with two types of names: those named after
classes/interfaces, and those that are not (such as <literal>package-summary.html
</literal>). Files in the latter group contain hyphens to prevent file name
conflicts with those in the former group.</para>
</refsect2>
<refsect2>
<title>Basic Content Pages</title>
<itemizedlist>
<listitem><para>One class or interface page (<literal>classname.html</literal>)
for each class or interface it is documenting.</para></listitem>
<listitem><para>One package page (<literal>package-summary.html</literal>)
for each package it is documenting. The Javadoc tool will include any HTML
text provided in a file named  <literal>package.html</literal> in the package
directory of the source tree.</para></listitem>
<listitem><para>One overview page (<literal>overview-summary.html</literal>)
for the entire set of packages. This is the front page of the generated document.
The Javadoc tool will include any HTML text provided in a file specified with
the <option>overview</option> option. Note that this file is created only
if you pass into <command>javadoc</command> two or more package names. For
further explanation, see <literal>HTML Frames</literal>.</para></listitem>
</itemizedlist>
</refsect2>
<refsect2>
<title>Cross-Reference Pages</title>
<itemizedlist>
<listitem><para>One class hierarchy page for the entire set of packages (<literal>
overview-tree.html</literal>). To view this, click on "Overview" in the navigation
bar, then click on "Tree".</para></listitem>
<listitem><para>One class hierarchy page for each package (<literal>package-tree.html
</literal>). To view this, go to a particular package, class or interface
page; click "Tree" to display the hierarchy for that package.</para></listitem>
<listitem><para>One "use" page for each package (<literal>package-use.html
</literal>) and a separate one for each class and interface (<literal>class-use/classname.html
</literal>). This page describes what packages, classes, methods, constructors,
and fields use any part of the given class, interface, or package. Given a
class or interface A, its "use" page includes subclasses of A, fields declared
as A, methods that return A, and methods and constructors with parameters
of type A. You can access this page by first going to the package, class,
or interface, then clicking on the "Use" link in the navigation bar.</para>
</listitem>
<listitem><para>A deprecated <acronym>API</acronym> page (<literal>deprecated-list.html
</literal>) listing all deprecated names. (A deprecated name is not recommended
for use, generally due to improvements, and a replacement name is usually
given. Deprecated <acronym>API</acronym>s might be removed in future implementations.)
</para></listitem>
<listitem><para>A constant field values page (<literal>constant-values.html
</literal>) for the values of static fields. </para></listitem>
<listitem><para>A serialized form page (<literal>serialized-form.html</literal>)
for information about serializable and externalizable classes. Each such class
has a description of its serialization fields and methods. This information
is of interest to re-implementors, not to developers using the <acronym>API
</acronym>. While there is no link in the navigation bar, you can get to this
information by going to any serialized class and clicking "Serialized Form"
in the "See also" section of the class description. The standard doclet automatically
generates a serialized             form page: any class (<literal>public</literal>
or <literal>non-public</literal>) that implements<literal> Serializable</literal>
is included, along with             <literal>readObject</literal> and <literal>
writeObject</literal> methods, the fields that are serialized, and the doc
comments from the             <literal>@serial</literal>, <literal>@serialField
</literal>, and <literal>@serialData</literal> tags. Public serializable classes
can be excluded by marking them (or their package) with<literal> @serial exclude
</literal>, and package-private serializable classes can be included by marking
them (or their package) with <literal>@serial include</literal>. As of 1.4,
you can generate the complete serialized form for public and private classes
by running javadoc without specifying the <option>private</option> option. 
</para></listitem>
<listitem><para>An index (<literal>index-*.html</literal>) of all class, interface,
constructor, field and method names, alphabetically arranged. This is internationalized
for Unicode and can be generated as a single file or as a separate file for
each starting character (such as A-Z for English).</para></listitem>
</itemizedlist>
</refsect2>
<refsect2>
<title>Support Files</title>
<itemizedlist>
<listitem><para>A help page (<literal>help-doc.html</literal>) that describes
the navigation bar and the above pages. You can provide your own custom help
file to override the default using <option>helpfile</option>.</para></listitem>
<listitem><para>One <literal>index.html</literal> file that creates the HTML
frames for display. This is the file you load to display the front page with
frames. This file itself contains no text content.</para></listitem>
<listitem><para>Several frame files (<literal>*-frame.html</literal>) containing
lists of packages, classes and interfaces, used when HTML frames are being
displayed.</para></listitem>
<listitem><para>A package list file (<literal>package-list</literal>), used
by the <option>link</option> and <option>linkoffline</option> options. This
is a text file, not HTML, and is not reachable through any links.</para></listitem>
<listitem><para>A style sheet file (<literal>stylesheet.css</literal>) that
controls a limited amount of color, font family, font size, font style, and
positioning on the generated pages.</para></listitem>
<listitem><para>A doc-files directory that holds any image, example, source
code, or other files that you want copied to the destination directory. These
files are not processed by the Javadoc tool in any manner &mdash; that is,
any <command>javadoc</command> tags in them will be ignored. This directory
is not generated unless it exists in the source tree.</para></listitem>
</itemizedlist>
</refsect2>
<refsect2>
<title>HTML Frames</title>
<para>The Javadoc tool generates either two or three HTML frames, as shown
in the figure below. When you pass source files (*<literal>.java</literal>)
or a single package name as arguments into the <command>javadoc</command>
command, it will create only one frame (C) in the left-hand column, that is,
the list of classes. When you pass into <command>javadoc</command> two or
more package names, it creates a third frame (P) listing all packages, as
well as an overview page (Detail). This overview page has the file name, <literal>
overview-summary.html</literal>. Thus, this file is created only if you pass
in two or more package names. You can bypass frames by clicking on the "No
Frames" link or entering at  <literal>overview-summary.html</literal>.</para>
<para>If you are unfamiliar with HTML frames, you should be aware that frames
can have focus for printing and scrolling. To give a frame focus, click on
it. Then, on many browsers the arrow keys and page keys will scroll that frame,
and the print menu command will print it.</para>
<para><screen>    ------------                  ------------
    |C| Detail |                  |P| Detail |
    | |        |                  | |        |
    | |        |                  |-|        |
    | |        |                  |C|        |
    | |        |                  | |        |
    | |        |                  | |        |
    ------------                  ------------
   javadoc *.java           javadoc java.lang java.awt</screen></para>
<para>Load one of the following two files as the starting page depending on
whether you want HTML frames or not:</para>
<itemizedlist>
<listitem><para><literal>index.html</literal> (for frames)</para></listitem>
<listitem><para><literal>overview-summary.html</literal> (for no frames)</para>
</listitem>
</itemizedlist>
</refsect2>
<refsect2>
<title>Generated File Structure</title>
<para>The generated class and interface files are organized in the same directory
hierarchy as Java source files and class files. This structure is one directory
per subpackage.</para>
<para>For example, the document generated for the class <literal>java.applet.Applet
</literal> would be located at <literal>java/applet/Applet.html</literal>.
The file structure for the <literal>java.applet</literal> package follows,
given that the destination directory is named <literal>apidocs</literal>.
All files that contain the word "frame" appear in the upper-left or lower-left
frames, as noted. All other HTML files appear in the right-hand frame.</para>
<para><emphasis>Note:</emphasis> Directories are shown in bold. The asterisks
(*) indicate the files and directories that are omitted when the arguments
to <command>javadoc</command> are source file names (*<literal>.java</literal>)
rather than package names. Also, when arguments are source file names, <literal>
package-list</literal> is created but is empty. The <literal>doc-files</literal>
directory will not be created in the destination unless it exists in the source
tree.</para>
<para><screen>apidocs                         Top directory
   index.html                   Initial page that sets up HTML frames
 * overview-summary.html        Lists all packages with first sentence summaries
   overview-tree.html           Lists class hierarchy for all packages
   deprecated-list.html         Lists deprecated API for all packages
   serialized-form.html         Lists serialized form for all packages
 * overview-frame.html          Lists all packages, used in upper-left frame
   allclasses-frame.html        Lists all classes for all packages,
                                     used in lower-left frame
   help-doc.html                Lists user help for how these pages are
                                     organized
   index-all.html               Default index created
                                     without -splitindex option
   index-files                  Directory created with -splitindex option
     index-&lt;number>.html        Index files created with -splitindex option
   package-list                 Lists package names, used only for resolving
                                     external refs
   stylesheet.css               HTML style sheet for defining fonts,
                                     colors and positions
   java                         Package directory
     applet                     Subpackage directory
       Applet.html              Page for Applet class
       AppletContext.html       Page for AppletContext interface
       AppletStub.html          Page for AppletStub interface
       AudioClip.html           Page for AudioClip interface
     * package-summary.html     Lists classes with first sentence summaries
                                     for this package
     * package-frame.html       Lists classes in this package, used in lower
                                     left-hand frame
     * package-tree.html        Lists class hierarchy for this package
       package-use              Lists where this package is used
       doc-files                Directory holding image and example files
       class-use                Directory holding pages API is used
            Applet.html         Page for uses of Applet class
            AppletContext.html  Page for uses of AppletContext interface
            AppletStub.html     Page for uses of AppletStub interface
			    AudioClip.html		 Page for uses of AudioClip
	src-html							Source code directory
		java							Package directory
			applet						Subpackage directory
				Applet.html			Page for Applet source code
				AppletContext.html	Page for AppletContext source code
				AppletStub.html		Page for AppletStub source code
				AudioClip.html		Page for AudioClip source code</screen></para>
</refsect2>
<refsect2>
<title>Generated API Declarations</title>
<para>The Javadoc tool generates a declaration at the start of each class,
interface, field, constructor, and method description. This declaration is
the declaration for that <acronym>API</acronym> item. For example, the declaration
for the Boolean class is:<informalexample>
<screen>public final class Boolean
extends Object
implements Serializable </screen>
</informalexample>and the declaration for the <literal>Boolean.valueOfmethod
</literal> is:<informalexample>
<screen>public static Boolean valueOf(String s) </screen>
</informalexample></para>
<para>The Javadoc tool can include the modifiers <literal>public</literal>, <literal>
protected</literal>, <literal>private</literal>, <literal>abstract</literal>, <literal>
final</literal>, <literal>static</literal>, <literal>transient</literal>,
and <literal>volatile</literal>, but not <literal>synchronized</literal> or <literal>
native</literal>. These last two modifiers are considered implementation detail
and not part of the <acronym>API</acronym> specification.</para>
<para>Rather than relying on the keyword <literal>synchronized</literal>, <acronym>
API</acronym>s should document their concurrency semantics in the comment
description, as in "a single <literal>Enumeration</literal> cannot be used
by multiple threads concurrently". The document should not describe how to
achieve these semantics. As another example, while <literal>Hashtable</literal>
should be thread-safe, there's no reason to specify that we achieve this by
synchronizing all of its exported methods. We should reserve the right to
synchronize internally at the bucket level, thus offering higher concurrency.
</para>
</refsect2>
<refsect2>
<title>Documentation Comments</title>
<para>The original "Documentation Comment Specification" can be found under
related documentation. </para>
<para><emphasis>Commenting the Source Code</emphasis></para>
<para>You can include documentation comments (&ldquo;doc comments&rdquo;)
in the source code, ahead of declarations for any classs, interface, method,
constructor, or field. You can also create doc comments for each package and
another one for the overview, though their syntax is slightly different. Doc
comments are also known as Javadoc comments. A doc comment consists of the
characters between the characters <literal>/**</literal> that begin the comment
and the characters <literal>*/</literal> that end it. Leading asterisks are
allowed on each line and are described further below. The text in a comment
can continue onto multiple lines.<informalexample><para><screen>/**
* This is the typical format of a simple documentation comment
* that spans two lines.
*/</screen></para>
</informalexample></para>
<para>To save space you can put a comment on one line:<informalexample><para><screen>
/** This comment takes up only one line. */</screen></para>
</informalexample></para>
<para><emphasis>Placement of Comments</emphasis></para>
<para>Documentation comments are recognized only when placed immediately before
class, interface, constructor, method, or field declarations &mdash; see the
class example, method example, and field example. Documentation comments placed
in the body of a method are ignored. Only one documentation comment per declaration
statement is recognized by the <command>javadoc</command> tool.</para>
<para>A common mistake is to put an import statement between the class comment
and the class declaration. Avoid this, as the Javadoc tool will ignore the
class comment.<informalexample><para><screen>/**
* This is the class comment for the class Whatever.
*/

import com.sun;   // MISTAKE - Important not to put statements here

public class Whatever {
}</screen></para>
</informalexample></para>
<para><emphasis>A comment is a description followed by a tag section</emphasis>.
The <emphasis>description</emphasis> begins after the starting delimiter <literal>
/**</literal> and continues until the tag section. The tag section starts
with the first character <literal>@</literal> that begins a line (ignoring
leading asterisks, white space, and separator /**). It is possible to have
a comment with only tags and no description. The description cannot continue
after the tag section begins. The argument to a tag can span multiple lines.
 There can be any number of tags &mdash; some types of tags can be repeated
while others cannot. This <literal>@see</literal> starts the tag section:<informalexample>
<para><screen> /**
 * This is a doc comment.
 * @see java.lang.Object
 */</screen></para>
</informalexample></para>
<para><emphasis>Standalone and In-line Tags</emphasis></para>
<para>A <emphasis>tag</emphasis> is a special keyword within a doc comment
that the Javadoc tool can process. The Javadoc tool has standalone tags, which
appear as <literal>@tag</literal>, and in-line tags, which appear within braces,
as <literal>{@tag}</literal>. To be interpreted, a standalone tag must appear
at the beginning of a line, ignoring leading asterisks, white space, and separator
(/**). This means you can use the @ character elsewhere in the text and it
will not be interpreted as the start of a tag. If you want to start a line
with the @ character and not have it be interpreted, use the HTML entity <literal>
&amp;#064;</literal>. Each standalone tag has associated text, which includes
any text following the tag up to, but not including, either the next tag,
or the end of the doc comment. This associated text can span multiple lines.
 An in-line tag is allowed and interpreted anywhere that text is allowed.
The following example contains the standalone tag <literal>@deprecated</literal>
and in-line tag <literal>{@link}</literal>.<informalexample>
<screen>/**
 * @deprecated  As of JDK 1.1, replaced \
         by {@link #setBounds(int,int,int,int)}
 */</screen>
</informalexample></para>
<para><emphasis>Comments are written in HTML</emphasis></para>
<para>The text must be written in HTML so that comments can use HTML entities
and HTML tags. You can use whichever version of HTML your browser supports;
we have written the standard doclet to generate HTML 3.2-compliant code elsewhere
(outside of the documentation comments) with the inclusion of cascading style
sheets and frames. (We preface each generated file with "HTML 4.0" because
of the frame sets.)</para>
<para>For example, entities for the less-than (&lt;) and greater-than (>)
symbols should be written <literal>&amp;lt;</literal> and <literal>&amp;gt;
</literal>. Likewise, the ampersand (&amp;) should be written <literal>&amp;amp;
</literal>. The bold HTML tag &lt;b> is shown in the following example:<informalexample>
<para><screen>/**
* This is a &lt;b>doc&lt;/b> comment.
* @see java.lang.Object
*/</screen></para>
</informalexample></para>
<para><emphasis>Leading Asterisks</emphasis></para>
<para>When <command>javadoc</command> parses a doc comment, leading asterisk
(*) characters on each line are discarded. Blanks and tabs preceding the initial
asterisk (*) characters are also discarded. Starting with 1.4, if you omit
the leading asterisk on a line, the leading white space is no longer removed.
This enables you to paste code examples directly into a doc comment inside
a &lt;pre> tag, and its indentation will be honored. Spaces are generally
interpreted by browsers more uniformly than tabs. Indentation is relative
to the left margin (rather than the separator /** or tag). </para>
<para><emphasis>First Sentence</emphasis></para>
<para>The first sentence of each doc comment should be a summary sentence,
containing a concise but complete description of the declared entity. This
sentence ends at the first period that is followed by a blank, tab, or line
terminator, or at the first standalone tag. The Javadoc tool copies this first
sentence to the member summary at the top of the HTML page. </para>
<para><emphasis>Declaration With Multiple Fields</emphasis></para>
<para><command>Java</command> allows declaring multiple fields in a single
statement, but this statement can have only one documentation comment, which
is copied for all fields. Therefore, if you want individual documentation
comments for each field, you must declare each field in a separate statement.
For example, the following documentation comment does not make sense when
written as a single declaration and would be better handled as two declarations:<informalexample>
<para><screen>/**
* The horizontal and vertical distances of point (x,y)
*/
public int x, y;      // Avoid this</screen></para>
</informalexample>The Javadoc tool generates the following documentation from
the above code:<informalexample>
<screen>public int x
     The horizontal and vertical distances of point (x,y).

public int y
     The horizontal and vertical distances of point (x,y).</screen>
</informalexample></para>
<para><emphasis>Use Header Tags Carefully</emphasis></para>
<para>When writing documentation comments for members, it is best not to use
HTML heading tags such as <literal>&lt;H1></literal> and <literal>&lt;H2>
</literal>, because the Javadoc tool creates an entire structured document
and these structural tags can interfere with the formatting of the generated
document. However, it is fine to use these headings in class and package comments
to provide your own structure.</para>
<para><emphasis>Automatic Re-use of Method Comments</emphasis></para>
<para>The Javadoc tool has the ability to automatically reuse or "inherit"
method comments in classes an interfaces. When a description, or <literal>
@return</literal>, <literal>@param</literal>,<literal> @see</literal> or <literal>
@throws</literal> tag is missing from a method comment, the Javadoc tool instead
copies the corresponding description or tag comment from the method it overrides
or implements (if any), according to the algorithm below. </para>
<para>More specifically, when a <literal>@param</literal> tag for a particular
parameter is missing, then the comment for that parameter is copied. When
an<literal> @throws</literal> tag for a particular exception is       missing,
the <literal>@throws</literal> tag is copied only if that exception is declared. 
</para>
<para>This behavior contrasts with version 1.3 and earlier, where the presence
of any description or tag would prevent all comments from being inherited. 
</para>
<para>Also of interest, if the inline tag {<literal>@inheritDoc</literal>}
is present in a description or any tag, the corresponding description or tag
is copied at that spot. </para>
<para>The overridden method must be a member of a documented class, and not
an external referenced class for the doc comment to actually be available
to copy. </para>
<para>Inheriting of comments occurs in three cases: </para>
<itemizedlist>
<listitem><para>When a method in a class overrides a method in a superclass.
</para></listitem>
<listitem><para>When a method in an interface overrides a method in a superinterface.
</para></listitem>
<listitem><para>When a method in a class implements a method in an interface.
</para></listitem>
</itemizedlist>
<para>In the first two cases, for method overrides, the Javadoc tool generates
a subheading "Overrides" in the documentation for the overriding method, with
a link to the method it is overriding.</para>
<para>In the third case,when a method in a given class implements a method
in an interface, the Javadoc tool generates a subheading "Specified by" in
the documentation for the overriding method, with a link to the method it
is implementing.</para>
<para><emphasis>Algorithm for Inheriting Method Descriptions</emphasis></para>
<para> If a method does not have a doc comment, the Javadoc tool searches
for an applicable comment using the following algorithm, which is designed
to find the most specific applicable doc comment, giving preference to interfaces
over superclasses: </para>
<itemizedlist>
<listitem><para>Look in each directly implemented (or extended) interface
in the order they appear following the word implements (or extends) in the
method declaration. Use the first doc comment found for this method. </para>
</listitem>
<listitem><para>If step 1 failed to find a doc comment, recursively apply
this entire algorithm to each directly implemented (or extended) interface,
in the same order they were examined in step 1. </para></listitem>
<listitem><para>f step 2 failed to find a doc comment and this is a class
other than <literal>Object</literal> (not an interface): </para>
<itemizedlist>
<listitem><para>If the superclass has a doc comment for this method, use it. 
</para></listitem>
<listitem><para>If step 3a failed to find a doc comment, recursively apply
this entire algorithm to the                   superclass. </para></listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</refsect2>
<refsect2>
<title>javadoc Tags</title>
<para>The Javadoc tool parses special tags when they are embedded within a
Java doc comment. These doc tags enable you to autogenerate a complete, well-formatted <acronym>
API</acronym> from your source code. The tags start with an "at" sign (<literal>
@</literal>) and are case-sensitive &mdash; they must be typed with the uppercase
and lowercase letters as shown. A tag must start at the beginning of a line
(after any leading spaces and an optional asterisk) or it is treated as normal
text. By convention, tags with the same name are grouped together. For example,
put all <literal>@see</literal> tags together.</para>
<para>Tags come in two types: </para>
<itemizedlist>
<listitem><para><emphasis>Standalone tags</emphasis> - Can be placed only
in the tag section that follows the description. These tags are not set off
with curly braces: <literal>@tag</literal>. </para></listitem>
<listitem><para><emphasis>Inline tags</emphasis> - Can be placed anywhere
in the comment description or in the comments for standalone tags. Inline
tags are set off with curly braces: {<literal>@tag</literal>}. </para></listitem>
</itemizedlist>
<para>For information about tags we might introduce in future releases, see
Proposed Tags. </para>
<para>The current tags are:</para>
<informaltable frame="all" orient="port" remap="center">
<tgroup cols="2" colsep="0" rowsep="0"><colspec colnum="1" colname="col1"
colwidth="1*" colsep="1" align="left"><colspec colnum="2" colname="col2" colwidth="1*"
align="left">
<thead>
<row><entry colname="col1" align="center" valign="top">Tag</entry><entry colname="col2"
align="center" valign="top">Introduced </entry></row>
<row rowsep="1"><entry colname="col1" valign="top"> </entry><entry colname="col2"
align="center" valign="top">in JDK/SDK</entry></row>
</thead>
<tbody>
<row><entry>@author</entry><entry>1.0</entry></row>
<row><entry colname="col1"><para>{@code}</para></entry><entry colname="col2"><para>
1.5</para></entry></row>
<row><entry>{@docRoot}</entry><entry>1.3</entry></row>
<row><entry>@deprecated</entry><entry>1.0</entry></row>
<row><entry>@exception</entry><entry>1.0</entry></row>
<row><entry colname="col1"><para>{<literal>@inheritDoc</literal>}</para></entry>
<entry colname="col2"><para>1.4</para></entry></row>
<row><entry>{@link}</entry><entry>1.2</entry></row>
<row><entry colname="col1"><para>{<literal>@linkplain</literal>}</para></entry>
<entry colname="col2"><para>1.4</para></entry></row>
<row><entry colname="col1"><para>{@literal}</para></entry><entry colname="col2"><para>
1.5</para></entry></row>
<row><entry>@param</entry><entry>1.0</entry></row>
<row><entry>@return</entry><entry>1.0</entry></row>
<row><entry>@see</entry><entry>1.0</entry></row>
<row><entry>@serial</entry><entry>1.2</entry></row>
<row><entry>@serialData</entry><entry>1.2</entry></row>
<row><entry>@serialField</entry><entry>1.2</entry></row>
<row><entry>@since</entry><entry>1.1</entry></row>
<row><entry>@throws</entry><entry>1.2</entry></row>
<row><entry colname="col1"><para>{<literal>@value</literal>}</para></entry>
<entry colname="col2"><para>1.4</para></entry></row>
<row><entry>@version</entry><entry>1.0</entry></row>
</tbody>
</tgroup>
</informaltable>
<para>For custom tags, see the <option>tag</option> option. </para>
<variablelist termlength="wholeline">
<varlistentry><term><literal>@author</literal> <replaceable>name-text</replaceable> 
</term><listitem><para>Adds an "Author" entry with the specified <replaceable>
name-text</replaceable> to the generated docs when the <option>author</option>
option is used. A doc comment can contain multiple <literal>@author</literal>
tags. You can specify one name per  <literal>@author</literal> tag or multiple
names per tag. In the former case, the Javadoc tool inserts a comma (<literal>
,</literal>) and space between names. In the latter case, the entire text
is copied to the generated document without being parsed. Therefore, use multiple
names per line if you want a localized name separator other than a comma.
</para>
</listitem></varlistentry>
<varlistentry><term><literal>@deprecated</literal> <replaceable>deprecated-text
</replaceable></term><listitem><para>Adds a comment indicating that this API
should no longer be used (even though it may continue to work). The Javadoc
tool moves the<replaceable> deprecated-text</replaceable> ahead of the description,
placing it in italics and preceding it with a bold warning: "Deprecated". 
</para>
<para>The first sentence of <replaceable>deprecated-text</replaceable> should
at least tell the user when the API was deprecated and what to use as a replacement.
The Javadoc tool copies just the first sentence to the summary section and
index. Subsequent sentences can also explain why it has been deprecated. You
should include a {<literal>@link</literal>} tag (for Javadoc 1.2 or later)
that points to the replacement API: </para>
<itemizedlist>
<listitem><para>For Javadoc 1.2 and later, use a {<literal>@link</literal>}
tag. This creates the link in-line, where you want it. For example: <screen>
/**
        * @deprecated  As of JDK 1.1, replaced by {@link #setBounds(int,int,int,int)}
        */</screen></para>
</listitem>
<listitem><para>For Javadoc 1.1, the standard format is to create a <literal>
@see</literal> tag (which cannot be in-line) for each <literal>@deprecated
</literal> tag. </para>
</listitem>
</itemizedlist>
<para>For more about deprecation, see The <literal>@deprecated</literal> tag. 
</para>
</listitem></varlistentry>
<varlistentry><term><literal>{@code <replaceable>text</replaceable>}</literal></term>
<listitem><para>Equivalent to &lt;code>{@literal}&lt;/code>.</para>
<para>Displays text in code font without interpreting the text as HTML markup
or nested javadoc tags. This enables you to use regular angle brackets (&lt;
and >) instead of the HTML entities  (&lt; and >) in doc comments, such as
in parameter types (&lt;Object>), inequalities (3 &lt; 4), or arrows (&lt;-).
For example, the doc comment text: </para>
<screen>{@code A&lt;B>C}

</screen>
<para>displays in the generated HTML page unchanged, as: </para>
<screen>A&lt;B>C

</screen>
<para>The noteworthy point is that the &lt;B> is not interpreted as bold and
is in code font. </para>
<para>If you want the same functionality without the code font, use <literal>
{@literal}</literal>. </para>
</listitem></varlistentry>
<varlistentry><term><literal>{@docRoot}</literal> </term><listitem><para>
Represents the relative path to the generated document's (destination) root
directory from any generated page. It is useful when you want to include a
file, such as a copyright page or company logo, that you want to reference
from all generated pages. Linking to the copyright page from the bottom of
each page is common. </para>
<para>This <literal>{@docRoot}</literal> tag can be used both on the command
line and in a doc comment:</para>
<orderedlist>
<listitem><para>On the command line, where the header/footer/bottom are defined: <informalexample>
<screen><userinput>javadoc -bottom '&lt;a href="{@docRoot}/\
        copyright.html">Copyright&lt;/a>'</userinput></screen>
</informalexample></para>
<para>NOTE - When using {<literal>@docRoot</literal>} this way in a make file,
some makefile programs require special escaping for the brace<literal> {}
</literal> characters. For example, the Inprise MAKE version 5.2 running on
Windows requires double braces: {{<literal>@docRoot</literal>}}. It also requires
double (rather than single) quotes to enclose arguments to options such as <option>
bottom</option> (with the quotes            around the href argument omitted). 
</para>
</listitem>
<listitem><para>In a doc comment: <informalexample>
<screen><literal>/**
* See the &lt;a href="{@docRoot}/\
       copyright.html">Copyright&lt;/a>.
*/</literal></screen>
</informalexample></para>
</listitem>
</orderedlist>
<para>The reason this tag is needed is because the generated docs are in hierarchical
directories, as deep as the number of subpackages. This expression:<informalexample>
<screen>&lt;a href="{@docRoot}/copyright.html"></screen>
</informalexample> would resolve to:<informalexample>
<screen>&lt;a href="../../copyright.html">   </screen>
</informalexample>for <literal>java/lang/Object.java</literal>, and it would
resolve to<informalexample>
<screen>&lt;a href="../../../copyright.html"></screen>
</informalexample> for <literal>java/lang/ref/Reference.java</literal></para>
</listitem></varlistentry>
</variablelist>
<variablelist termlength="wholeline">
<varlistentry><term><literal>@exception</literal> <replaceable>class-name
description</replaceable> </term><listitem><para>The <literal>@exception</literal>
tag is a synonym for <literal>@throws</literal>. </para>
</listitem></varlistentry>
<varlistentry><term>{<literal>@inheritDoc</literal>}</term><listitem><para>
Inherits documentation from the nearest superclass into the current doc comment.
This allows comments to be abstracted up the inheritance tree, and enables
developers to write around the copied text. Also see inheriting comments. 
</para>
<para>This tag can be placed in two positions: </para>
<itemizedlist>
<listitem><para>n the comment body (before the first standalone tag), where
it will copy the entire  comment body from its superclass. </para>
</listitem>
<listitem><para>In the text argument of a standalone tag, where it will copy
the text of the tag from its  superclass. </para>
</listitem>
</itemizedlist>
</listitem></varlistentry>
<varlistentry><term>{<literal>@link</literal> <replaceable>package.class#member
label</replaceable>}</term><listitem><para>Inserts an in-line link with visible
text label that points to the documentation for the specified            package,
class or member name of a referenced class. </para>
<para>This tag is very simliar to<literal> @see</literal> -- both require
the same references and accept exactly the same syntax for <replaceable>package.class#member
</replaceable> and <replaceable>label</replaceable>. The main difference is
that {<literal>@link</literal>} generates an in-line link rather than placing
the link in the "See Also" section. Also, the {<literal>@link</literal>} tag
begins and ends with curly braces to separate it from the rest of the in-line
text. If you need to use "}" inside the label, use the HTML entity notation <literal>
&amp;#125;</literal>. </para>
<para>There is no limit to the number of <literal>{@link}</literal> tags allowed
in a sentence. You can use this tag in the description part of a documentation
comment or in the text portion of any tag (such as <literal>@deprecated</literal>, <literal>
@return</literal>, or  <literal>@param</literal>).</para>
<para>For example, here is a comment that refers to the <literal>getComponentAt(int,
int)</literal> method:<informalexample>
<screen>Use the {@link #getComponentAt(int, int) getComponentAt} method.</screen>
</informalexample></para>
<para>From this, the standard doclet would generate the following HTML (assuming
it refers to another class in the same package):<informalexample>
<screen>Use the 
&lt;a href="Component.html#getComponentAt(int, int)">\
               getComponentAt&lt;/a>method.</screen>
</informalexample></para>
<para>which appears on the web page as:<informalexample>
<screen>Use the getComponentAt method.</screen>
</informalexample></para>
<para>You can extend <literal>{@link}</literal> to link to classes not being
documented by using the <option>link</option> option. </para>
</listitem></varlistentry>
<varlistentry><term><literal>{@linkplain</literal> <replaceable>package.class#member
 label</replaceable></term><listitem><para>Identical to<literal> {@link}</literal>,
except the link's label is displayed in plain text than code font. Useful
when the label is plain text. Example: </para>
<informalexample>
<screen> Refer to {@linkplain add() the overridden method}.</screen>
</informalexample>
<para>This would display as: </para>
<informalexample>
<screen>Refer to the overridden method. </screen>
</informalexample>
</listitem></varlistentry>
<varlistentry><term><literal>{@literal<replaceable>text</replaceable>}</literal></term>
<listitem><para>Displays text without interpreting the text as HTML markup
or nested javadoc tags. This enables you to use regular angle brackets ( &lt;
and > ) instead of the HTML entities ( &lt; and > ) in doc comments, such
as in parameter types ( &lt;Object>), inequalities ( 3 &lt; 4 ), or arrows
( &lt;- ). For example, the doc comment  text: </para>
<screen> {@literal A&lt;B>C} 

</screen>
<para>displays unchanged in the generated HTML page in your browser, as: 
</para>
<screen>A&lt;B>C</screen>
<para>The noteworthy point is that the &lt;B> is not interpreted as bold (and
it is not in code font). </para>
<para>If you want the same functionality but with the text in code font, use <literal>
{@code}</literal>. </para>
</listitem></varlistentry>
<varlistentry><term><literal>@param</literal> <replaceable>parameter-name
description</replaceable> </term><listitem><para>Adds a parameter with the
specified parameter-name followed by the specified description to the "Parameters"
section. When writing the doc comment, you may continue the description onto
multiple lines.This tag is valid only in a doc comment for a method, constructor
or class.</para>
<para>The parameter-name can be the name of a parameter in a method or constructor,
or the name of a type parameter of a class. Use angle brackets around this
parametername to specify the use of a type parameter, such as: </para>
<screen>/**
        * @param &lt;E> Type of element stored in a list
        */
       public interface List&lt;E> extends Collection&lt;E> {
       }</screen>
<para>For more details, see writing @param tags. </para>
</listitem></varlistentry>
<varlistentry><term><literal>@return</literal> <replaceable>description</replaceable> 
</term><listitem><para>Adds a "Returns" section with the description text.
This text should describe the return type and permissible range of values.
</para>
</listitem></varlistentry>
<varlistentry><term><literal>@see</literal> <replaceable>reference</replaceable> 
</term><listitem><para>Adds a "See Also" heading with a link or text entry
that points to <replaceable>reference</replaceable>. A doc comment can contain
any number of <literal>@see</literal> tags, which are all grouped under the
same heading. The <literal>@see</literal> tag has three variations; the third
form below is the most common. For inserting an in-line link within a sentence
to a package, class or member, see<literal> {@link}</literal>. </para>
</listitem></varlistentry>
<varlistentry><term><literal>@see</literal> <replaceable>string</replaceable> 
</term><listitem><para>Adds a text entry for <replaceable>string</replaceable>.
No link is generated. The <replaceable>string</replaceable> is a book or other
reference to information not available by URL. The Javadoc tool distinguishes
this from the previous cases by looking for a double-quote (") as the first
character. For example:<informalexample>
<screen>@see "The Java Programming Language"</screen>
</informalexample></para>
<para>This generates text such as:<informalexample>
<screen>See Also:
          "The Java Programming Language"</screen>
</informalexample></para>
</listitem></varlistentry>
<varlistentry><term><literal>@see &lt;a href="</literal><replaceable>URL#value
</replaceable><literal>"></literal><replaceable>label</replaceable><literal>
&lt;/a></literal></term><listitem><para>Adds a link as defined by <replaceable>
URL#value</replaceable>. The <replaceable>URL#value</replaceable> is a relative
or absolute URL. The Javadoc tool distinguishes this from other cases by looking
for a less-than symbol (&lt;) as the first character. For example: <informalexample>
<screen>@see &lt;a href="spec.html#section">Java Spec&lt;/a></screen>
</informalexample>This generates a link such as:<informalexample>
<screen>See Also:
       Java Spec</screen>
</informalexample></para>
</listitem></varlistentry>
<varlistentry><term><literal>@see</literal> <replaceable>package.class#member
label</replaceable> </term><listitem><para>Adds a link, with visible text<replaceable>
 label</replaceable>, that points to the documentation for the specified name
in the Java Language. The<replaceable> label</replaceable> is optional; if
omitted, the name appears instead as the visible text, suitably shortened &mdash;
see <literal>How a Name Is Displayed</literal>. Use the label when you want
the visible text to be abbreviated or different from the name.</para>
</listitem></varlistentry>
</variablelist><para>In only version 1.2, just the name but not the label
would automatically appear in <literal>&lt;code></literal> HTML tags. Starting
with 1.2.2, the <literal>&lt;code></literal> is always included around the
visible text, whether or not a label is used.</para>
<itemizedlist>
<listitem><para><replaceable>package.class#member</replaceable> is any valid
name in the Java Language that is referenced &mdash; a package, class, interface,
constructor, method, or field name &mdash; except that you replace the dot
ahead of the member name with a hash character (#). If this name is in the
documented classes, the Javadoc tool will automatically create a link to it.
To create links to external referenced classes, use the <option>link</option>
option. Use either of the other two <literal>@see</literal> forms for referring
to documentation of a name that does not belong to a referenced class. This
argument is described at greater length below under <literal>Specifying a
Name</literal>.</para></listitem>
<listitem><para><replaceable>label</replaceable> is optional text that is
visible as the link's label. The<replaceable> label</replaceable> can contain
white space. If a<replaceable> label</replaceable> is omitted, then <replaceable>
package.class.member</replaceable> will appear, suitably shortened relative
to the current class and package &mdash; see <literal>How a Name Is Displayed
</literal>.</para></listitem>
<listitem><para>A space is the delimiter between <replaceable>package.class#member
</replaceable> and <replaceable>label</replaceable>. A space inside parentheses
does not indicate the start of a label, so spaces can be used between parameters
in a method.</para></listitem>
</itemizedlist>
<para>In this example, an <literal>@see</literal> tag (in the Character class)
refers to the equals method in the String class. The tag includes both arguments,
that is, the name "<literal>String#equals(Object)</literal>" and the label
"<literal>equals</literal>":<informalexample>
<screen>      /**
      * @see String#equals(Object) equals
      */</screen>
</informalexample></para>
<para>The standard doclet produces HTML something like this:<informalexample>
<screen>    &lt;dl>
    &lt;dt>&lt;b>See Also:&lt;/b>
    &lt;dd>&lt;a href="../../java/lang/String#equals\
                 (java.lang.Object)">&lt;code>equals&lt;/code>&lt;/a>
    &lt;/dl></screen>
</informalexample></para>
<para>The above looks something like this in a browser, where the label is
the visible link text:<informalexample>
<screen>See Also:
     equals</screen>
</informalexample></para>
<para><emphasis>Specifying a Name:</emphasis> This <replaceable>package.class#member
</replaceable> name can be either fully qualified, such as <literal>java.lang.String#toUpperCase()
</literal>, or not, such as <literal>String#toUpperCase()</literal> or <literal>
#toUpperCase()</literal>. If less than fully-qualified, <command>javadoc</command>
uses the normal Java compiler search order to find it, further described below
in <literal>Search Order for @see</literal>. The name can contain whitespace
within parentheses, such as between method arguments.</para>
<para>The advantage to providing shorter, "partially-qualified" names is that
they require are less to type and less clutter in the source code. The following
table shows the different forms of the name, where Class can be a class or
interface, Type can be a class, interface, array, or primitive, and method
can be a method or constructor.</para>
<informaltable frame="all" orient="port">
<tgroup cols="1" colsep="0" rowsep="0"><colspec colnum="1" colname="col1"
colwidth="1*" align="left">
<thead>
<row valign="top"><entry colname="col1" rowsep="1" align="left">Typical forms
for @see <replaceable>package.class#member</replaceable></entry></row>
</thead>
<tbody>
<row><entry><para> </para></entry></row>
<row><entry>Referencing a member of the current class</entry></row>
<row><entry><literal>@see</literal> <replaceable>#field</replaceable></entry>
</row>
<row><entry><literal>@see</literal> <replaceable>#method(Type, Type,...)</replaceable></entry>
</row>
<row><entry>@see <replaceable>#method(Type argname, Type argname,...)</replaceable></entry>
</row>
<row><entry><para> </para></entry></row>
<row><entry>Referencing another class in the current or imported packages
</entry></row>
<row><entry><literal>@see</literal> <replaceable>Class#field</replaceable></entry>
</row>
<row><entry><literal>@see</literal> <replaceable>Class#method(Type, Type,...)
</replaceable></entry></row>
<row><entry><literal>@see</literal> <replaceable>Class#method(Type argname, Type argname,...)
</replaceable></entry></row>
<row><entry><literal>@see</literal> <replaceable>Class</replaceable></entry>
</row>
<row><entry><para> </para></entry></row>
<row><entry>Referencing another package (fully qualified)</entry></row>
<row><entry><literal>@see</literal> <replaceable>package.Class#field</replaceable></entry>
</row>
<row><entry><literal>@see</literal> <replaceable>package.Class#method(Type, Type,...)
</replaceable></entry></row>
<row><entry><literal>@see</literal> <replaceable>package.Class#method(Type argname, Type argname,...)
</replaceable></entry></row>
<row><entry><literal>@see</literal> <replaceable>package.Class</replaceable></entry>
</row>
<row><entry><literal>@see</literal> <replaceable>package</replaceable></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>The following notes apply to the above table:</para>
<itemizedlist>
<listitem><para>The first set of forms (with no class or package) will cause
the Javadoc tool to search only through the current class's hierarchy. It
will find a member of the current class or interface, one of its superclasses
or superinterfaces, or one of its enclosing classes or interfaces (search
steps 1-3). It will not search the rest of the current package or other packages
(search steps 4-5).</para></listitem>
<listitem><para>If any method or constructor is entered as a name with no
parentheses, such as <literal>getValue</literal>, and if no field with the
same name exists, the Javadoc tool will correctly create a link to it, but
will print a warning message reminding you to add the parentheses and arguments.
If this method is overloaded, the Javadoc tool will link to the first method
that its search encounters, which is unspecified.</para></listitem>
<listitem><para>Nested classes must be specified as <literal>outer.inner</literal>,
not simply <literal>inner</literal>, for all forms.</para></listitem>
<listitem><para>As stated, the hash character (<literal>#</literal>), rather
than a dot (<literal>.</literal>), separates a member from its class. This
enables the Javadoc tool to resolve ambiguities, since the dot also separates
classes, inner classes, packages, and subpackages. However, the Javadoc tool
is generally lenient and will properly parse a dot if you know there is no
ambiguity, though it will print a warning.</para></listitem>
</itemizedlist>
<para><emphasis>Search Order for @see:</emphasis> the Javadoc tool will process
an <literal>@see</literal> tag that appears in a source file (<literal>.java
</literal>), package file (<literal>package.html</literal>), or overview file
(<literal>overview.html</literal>). In the latter two files, you must fully
qualify the name you supply with <literal>@see</literal>. In a source file,
you can specify a name that is fully qualified or partially qualified.</para>
<para>When the Javadoc tool encounters an  <literal>@see</literal> tag in
a <literal>.java</literal> file that is not fully qualified, it searches for
the specified name in the same order as the Java compiler would (except the
Javadoc tool will not detect certain namespace ambiguities, since it assumes
the source code is free of these errors). This search order is formally defined
in Chapter 6, "Names" of the <citetitle>Java Language Specification</citetitle>,
Second Edition. The Javadoc tool searches for that name through all related
and imported classes and packages. In particular, it searches in this order:
</para>
<orderedlist>
<listitem><para>The current class or interface</para></listitem>
<listitem><para>Any enclosing classes and interfaces, searching closest first
</para></listitem>
<listitem><para>Any superclasses and superinterfaces, searching closest first
</para></listitem>
<listitem><para>The current package</para></listitem>
<listitem><para>Any imported packages, classes and interfaces, searching in
the order of the import statement</para></listitem>
</orderedlist>
<para>The Javadoc tool continues to search recursively through steps 1-3 for
each class it encounters until it finds a match. That is, after it searches
through the current class and its enclosing class E, it searches through E's
superclasses before E's enclosing classes. In steps 4 and 5, the Javadoc tool
does not search classes or interfaces within a package in any specified order
(that order depends on the particular compiler). In step 5, the Javadoc tool
will look in <literal>java.lang</literal>, since that is automatically imported
by all programs.</para>
<para>The Javadoc tool will not necessarily look in subclasses, nor will it
look in other packages even if their documentation is being generated in the
same run. For example, if the <literal>@see</literal> tag is in the <literal>
java.awt.event.KeyEvent</literal> class and refers to a name in the <literal>
java.awt</literal> package, <command>javadoc</command> will not look in that
package unless that class imports it.</para>
<para><emphasis>How a Name is Displayed</emphasis>: If <replaceable>label
</replaceable> is omitted, then <replaceable>package.class.member</replaceable>
will appear. In general, it will be suitably shortened relative to the current
class and package. By "shortened", we mean the Javadoc tool will display only
the minimum name necessary. For example, if the <literal>String.toUpperCase()
</literal> method contains references to a member of the same class and to
a member of a different class, the class name will be displayed only in the
latter case:</para>
<para><screen><replaceable>Type of Ref-</replaceable>         <replaceable>
Example</replaceable>                           <replaceable>Displays As</replaceable>
   <replaceable>erence</replaceable>

@see tag refers to   @see String#toLowerCase()         toLowerCase()
member of the                                          (omits the class
same class                                              name)

@see tag refers to   @see Character#toLowerCase(char)  Character.to\
member of a                                             LowerCase(char)
different class                                        (includes the class
                                                        name)</screen></para>
<para><emphasis>Examples of @see:</emphasis> The comment to the right shows
how the name would be displayed if the <literal>@see</literal> tag is in a
class in another package, such as <literal>java.applet.Applet</literal>:</para>
<informaltable orient="port">
<tgroup cols="2" colsep="0" rowsep="0"><colspec colnum="1" colname="col1"
colwidth="1*" align="left"><colspec colnum="2" colname="col2" colwidth="1*"
align="left">
<tbody>
<row><entry><replaceable>Example</replaceable></entry><entry><replaceable>
See also:</replaceable></entry></row>
<row><entry></entry><entry></entry></row>
<row><entry><literal>@see java.lang.String</literal></entry><entry>// String
</entry></row>
<row><entry><literal>@see java.lang.String The String class</literal></entry>
<entry>// The String class</entry></row>
<row><entry><literal>@see String</literal></entry><entry>// String</entry>
</row>
<row><entry><literal>@see String#equals(Object)</literal></entry><entry>// String.equals(Object)
</entry></row>
<row><entry><literal>@see String#equals</literal></entry><entry>// String.equals\
      (java.lang.Object)</entry></row>
<row><entry><literal>@see java.lang.Object#wait(long)</literal></entry><entry>
// java.lang.Object.\
      wait(long)</entry></row>
<row><entry><literal>@see Character#MAX_RADIX</literal></entry><entry>// Character.MAX_RADIX
</entry></row>
<row><entry><literal>@see &lt;a href="spec.html">Java Spec&lt;/a></literal></entry>
<entry>// Java Spec</entry></row>
<row><entry><literal>@see "The Java Programming Language"</literal></entry>
<entry>// "The Java Programming \
      Language"</entry></row>
</tbody>
</tgroup>
</informaltable>
<para>You can extend <literal>@see</literal> to link to classes not being
documented by using the <option>link</option> option. Notice that this works
only for classes that are referenced in a particular way as described at <literal>
How an Excluded Class Must Be Referenced for a Link to Appear</literal>.</para>
<variablelist termlength="wholeline">
<varlistentry><term><literal>@since</literal> <replaceable>since-text</replaceable> 
</term><listitem><para>Adds a "Since" heading with the specified <replaceable>
since-text</replaceable> to the generated documentation. The text has no special
internal structure. This tag means that this change or feature has existed
since the software release specified by the <replaceable>since-text</replaceable>.
For example: <informalexample><para><screen>@since 1.4</screen></para>
</informalexample></para>
<para>For source code in the Java platform, this tag indicates the version
of the Java platform <acronym>API</acronym> specification (not necessarily
when it was added to             the reference implementation). </para>
</listitem></varlistentry>
<varlistentry><term><literal>@serial</literal> <replaceable>field-description
</replaceable> | <literal>include</literal> | <literal>exclude</literal></term>
<listitem><para>Used in the doc comment for a default serializable field.
</para>
<para>An optional <replaceable>field-description</replaceable> should explain
the meaning of the field and list the acceptable values. If needed, the description
can span multiple lines. The standard doclet adds this information to the <literal>
serialized form page</literal>.</para>
<para>If a serializable field was added to a class some time after the class
was made serializable, a statement should be added to its description to identify
at which version it was added. </para>
<para>The <literal>include</literal> and <literal>exclude</literal> arguments
identify whether a class or package should be included or excluded from the
serialized form page. They work as follows:<itemizedlist>
<listitem><para>A public or protected class that implements <literal>Serializable
</literal> is included unless that class (or its package) is marked <literal>
@serial exclude</literal>.</para>
</listitem>
<listitem><para>A private or package-private class that implements <literal>
Serializable</literal> is excluded unless that class (or its package) is marked <literal>
@serial include</literal>.</para>
</listitem>
</itemizedlist></para>
<para><emphasis>Examples:</emphasis> The <literal>javax.swing</literal> package
is marked <literal>@serial exclude</literal> (in <literal>package.html</literal>).
The public class <literal>java.security.BasicPermission</literal> is marked <literal>
@serial exclude</literal>. The package-private class <literal>java.util.PropertyPermissionCollection
</literal> is marked <literal>@serial include</literal>.</para>
<para>The tag <literal>@serial</literal> at a class level overrides <literal>
@serial</literal> at a package level.</para>
<para>The <literal>@since</literal> tag should be added to each serializable
field that has been added since the initial version of a <literal>Serializable
</literal> class to identify when it was added.</para>
<para>For more information about how to use these tags, along with an example,
see "Documenting Serializable Fields and Data for a Class," Section 1.6 of
the <citetitle>Java Object Serialization Specification</citetitle>. Also see
the <citetitle>Serialization FAQ</citetitle>, which covers the questions,
such as "Why do I see <command>javadoc</command> warnings stating that I am
missing <literal>@serial</literal> tags for private fields if I am not running <command>
javadoc</command> with the <option>private</option> switch?".</para>
</listitem></varlistentry>
<varlistentry><term><literal>@serialField</literal> <replaceable>field-name
 field-type  field-description</replaceable> </term><listitem><para>Documents
an <literal>ObjectStreamField</literal> component of a <literal>Serializable
</literal> class's <literal>serialPersistentFields</literal> member. One <literal>
@serialField</literal> tag should be used for each <literal>ObjectStreamField
</literal> component.</para>
</listitem></varlistentry>
<varlistentry><term><literal>@serialData</literal> <replaceable>data-description
</replaceable> </term><listitem><para>A <replaceable>data-description</replaceable>
documents the types and order of datain the serialized form. Specifically,
this data includes the optional data written by the <literal>writeObject</literal>
method and all data (including base classes) written by the <literal>Externalizable.writeExternal
</literal> method.</para>
<para>The <literal>@serialData</literal> tag can be used in the doc comment
for the <literal>writeObject</literal>, <literal>readObject</literal>, <literal>
writeExternal</literal>, and <literal>readExternal</literal> methods.</para>
</listitem></varlistentry>
</variablelist>
<variablelist termlength="wholeline">
<varlistentry><term><literal>@throws</literal> <replaceable>class-name  description
</replaceable> </term><listitem><para>The <literal>@throws</literal> and <literal>
@exception</literal> tags are synonyms. Adds a "Throws" subheading to the
generated documentation, with the <replaceable>class-name</replaceable> and <replaceable>
description</replaceable> text. The <replaceable>class-name</replaceable>
is the name of the exception that can be thrown by the method. If this class
is not fully specified, the Javadoc tool uses the search order to look up
this class. A <literal>@throws </literal>tag's comment documented in a superclass
or interface is inherited             in two cases: (1) for a corresponding
exception declared in a throws clause of the subclass and (2) for all runtime
exceptions. If neither is the case and you want to force the documentation
to be inherited, then use <literal>{@inheritDoc}</literal>. </para>
</listitem></varlistentry>
<varlistentry><term><literal>{@value <replaceable>package.class#field</replaceable>} 
</literal></term><listitem><para>When <literal>{@value}</literal> is used
(without any argument) in the doc comment of a static field, it displays the
value of that constant: </para>
<screen>  /**
          * The value of this constant is {@value}.
          */
         public static final String SCRIPT_START = "&lt;script>"</screen>
<para>When used with argument <literal>package.class#field</literal> in any
doc comment, it displays the value of the specified constant: </para>
<screen> /**
         * Evaluates the script starting with {@value #SCRIPT_START}.
         */
        public String evalScript(String script) {
        }</screen>
<para>The argument <literal>package.class#field</literal> takes a form identical
to that of the <literal>@see</literal> argument, except that the member must
be a static field. </para>
<para>These values of these constants are also displayed on the Constant Field
Values page. </para>
</listitem></varlistentry>
<varlistentry><term><literal>@version</literal> <replaceable>version-text
</replaceable> </term><listitem><para>Adds a "Version" subheading with the
specified <replaceable>version-text</replaceable> to the generated docs when
the <option>version</option> option is used. The text has no special internal
structure. A doc comment can contain at most one <literal>@version</literal>
tag. Version normally refers to the version of the software (such as the Java
2 SDK) that contains this class or member.</para>
</listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title>Where Tags Can Be Used</title>
<para>The following sections describe where the tags can be used. Notice that
these four tags can be used in all doc comments: <literal>@see</literal>, <literal>
@link</literal>, <literal>@since</literal>, <literal>@deprecated</literal>. 
</para>
</refsect2>
<refsect2>
<title>Overview Documentation Tags</title>
<para>Overview tags are tags that can appear in the documentation comment
for the overview page (which resides in the source file typically named <literal>
overview.html</literal>). Like in any other documentation comments, these
tags must appear after the description.</para>
<para><emphasis>Note:</emphasis> The <literal>{@link}</literal> tag has a
bug in overview documents in version 1.2 &mdash; the text appears properly
but has no link. The<literal> {@docRoot}</literal> tag does not currently
work in overview documents. <informalexample>
<screen><emphasis>Overview Tags</emphasis>

@see
@since
@author
@version
{@link}
{@linkplain}
{@docRoot}</screen>
</informalexample></para>
</refsect2>
<refsect2>
<title>Package Documentation Tags</title>
<para>Package tags are tags that can appear in the documentation comment for
a package (which resides in the source file named <literal>package.html</literal>).
The <literal>@serial</literal> tag can only be used here with the <literal>
include</literal> or <literal>exclude</literal> argument.<informalexample>
<screen><emphasis>Package Tags</emphasis>

@see
@since
@deprecated
@serial
@author
@version
{@link}
{@linkplain}
{@docRoot}</screen>
</informalexample></para>
</refsect2>
<refsect2>
<title>Class and Interface Documentation Tags</title>
<para>The following are tags that can appear in the documentation comment
for a class or interface. The <literal>@serial</literal> tag can only be used
here with the <literal>include</literal> or <literal>exclude</literal> argument. <informalexample>
<screen><emphasis>Class/Interface Tags</emphasis>

@see
@since
@deprecated
@serial
@author
@version
{@link}
{@linkplain}
{@docRoot}</screen>
</informalexample></para>
<para>An example of a class comment:<informalexample><para><screen>/**
* A class representing a window on the screen.
* For example:
* &lt;pre>
*    Window win = new Window(parent);
*    win.show();
* &lt;/pre>
*
* @author  Sami Shaio
* @version 1.8, 04/02/04
* @see     java.awt.BaseWindow
* @see     java.awt.Button
*/
class Window extends BaseWindow {
}</screen></para>
</informalexample></para>
</refsect2>
<refsect2>
<title>Field Documentation Tags</title>
<para>The following are the tags that can appear in the documentation comment
for a field.<informalexample>
<screen><emphasis>Field Tags</emphasis>

@see
@since
@deprecated
@serial
@serialField
{@link}
{@linkplain}
{@docRoot}
{@value}</screen>
</informalexample></para>
<para>An example of a field comment:<informalexample><para><screen>/**
* The X-coordinate of the component.
*
* @see #getLocation()
*/
int x = 1263732;</screen></para>
</informalexample></para>
</refsect2>
<refsect2>
<title>Constructor and Method Documentation Tags</title>
<para>The following are the tags that can appear in the documentation comment
for a constructor or method, except for <literal>{@inheritDoc}</literal>,
which cannot appear in a constructor..<informalexample>
<screen><emphasis>Method/Constructor Tags</emphasis>

@see
@since
@deprecated
@param
@return
@throws (@exception)
@serialData
{@link}
{@linkplain}
{@inheritDoc}
{@docRoot}</screen>
</informalexample></para>
<para>An example of a method doc comment:<informalexample><para><screen>/**
* Returns the character at the specified index. An index
* ranges from &lt;code>0&lt;/code> to &lt;code>length() - 1&lt;/code>.
*
* @param     index  the index of the desired character.
* @return    the desired character.
* @exception StringIndexOutOfRangeException
*              if the index is not in the range &lt;code>0&lt;/code>
*              to &lt;code>length()-1&lt;/code>.
* @see       java.lang.Character#charValue()
*/
public char charAt(int index) {
}</screen></para>
</informalexample></para>
</refsect2>
</refsect1>
<refsect1><title>&opts-tt;</title>
<para>The <command>javadoc</command> tool uses doclets to determine its output.
The Javadoc tool uses the default standard doclet unless a custom doclet is
specified with the <option>doclet</option> option. The Javadoc tool provides
a set of command-line options that can be used with any doclet. These options
are described below under the sub-heading <literal>javadoc Options</literal>.
The standard doclet provides an additional set of command-line options that
are described below, under the sub-heading <literal>Options Provided by the
Standard Doclet</literal>. All option names are case-insensitive, though their
arguments can be case-sensitive.</para>
<para>The options are:</para>
<para><screen>        -1.1                   -header            -private
        -author                -help              -protected
        -bootclasspath         -helpfile          -public
        -bottom                -J                 -quiet
			-breakiterator         -link              -serialwarn 
        -charset               -linkoffline       -source
        -classpath             -linksource        -sourcepath
        -d                     -locale            -splitindex
        -docencoding           -nocomment         -stylesheetfile
        -docfilessubedir       -nodeprecated      -subpackages
			-doclet                -nodeprecatedlist  -tag
        -docletpath            -nohelp            -taglet
        -doctitle              -noindex           -tagletpath
        -encoding              -nonavbar          -title
        -exclude					-noqualifier       -use
			-excludedocfilessubdir -nosince           -verbose
			-extdirs               -notree            -version
        -footer                -overview          -windowtitle
        -group                 -package 			  -notimestamp 
			-keywords                                                                                   
</screen></para>
<refsect2>
<title>javadoc Options</title>
<variablelist termlength="wholeline">
<varlistentry><term><option>overview</option> <replaceable>path/filename</replaceable> 
</term><listitem><para>Specifies that <command>javadoc</command> should retrieve
the text for the overview documentation from the "source" file specified by <replaceable>
path/filename</replaceable> and place it on the Overview page (<literal>overview-summary.html
</literal>). The <replaceable>path/filename</replaceable> is relative to the <option>
sourcepath</option>.</para>
<para>While you can use any name you want for <replaceable>filename</replaceable>
and place it anywhere you want for <replaceable>path</replaceable>, a typical
thing to do is to name it <literal>overview.html</literal> and place it in
the source tree at the directory that contains the topmost package directories.
In this location, no path is needed when documenting packages, since <option>
sourcepath</option> will point to this file. For example, if the source tree
for the <literal>java.lang</literal> package is <literal>/src/classes/java/lang/
</literal>, then you could place the overview file at  <literal>/src/classes/overview.html
</literal>. See <literal>Real World Example</literal>.</para>
<para>For information about the file specified by <replaceable>path/filename
</replaceable>, see overview comment file.</para>
<para>Note that the overview page is created only if you pass into <command>
javadoc</command> two or more package names. For further explanation, see <literal>
HTML Frames</literal>.</para>
<para>The title on the overview page is set by <option>doctitle</option>.
</para>
</listitem></varlistentry>
<varlistentry><term><option>public</option> </term><listitem><para>Shows only
public classes and members.</para>
</listitem></varlistentry>
<varlistentry><term><option>protected</option> </term><listitem><para>Shows
only protected and public classes and members. This is the default.</para>
</listitem></varlistentry>
<varlistentry><term><option>package</option> </term><listitem><para>Shows
only package, protected, and public classes and members.</para>
</listitem></varlistentry>
<varlistentry><term><option>private</option> </term><listitem><para>Shows
all classes and members.</para>
</listitem></varlistentry>
<varlistentry><term><option>help</option> </term><listitem><para>Displays
the online help, which lists these <command>javadoc</command> and doclet command
line options.</para>
</listitem></varlistentry>
<varlistentry><term><option>doclet</option> <replaceable>class</replaceable> 
</term><listitem><para>Specifies the class file that starts the doclet used
in generating the documentation. Use the fully-qualified name. This doclet
defines the content and formats the output. If the <option>doclet</option>
option is not used, <command>javadoc</command> uses the standard doclet for
generating the default HTML format. This class must contain the <literal>
start(Root)</literal> method. The path to this starting class is defined by
the <option>docletpath</option> option.</para>
<para>For example, to call the MIF doclet, use:<informalexample>
<screen>-doclet com.sun.tools.doclets.mif.MIFDoclet</screen>
</informalexample></para>
</listitem></varlistentry>
<varlistentry><term><option>docletpath</option> <replaceable>classpathlist
</replaceable> </term><listitem><para>Specifies the path to the doclet starting
class file (specified with the <option>doclet</option> option) and any <acronym>
JAR</acronym> files it depends on .If the starting class file is in a jar
file, then this specifies the path to that jar file, as shown in the example
below. You can specify an absolute path or a path relative to the current
directory. If <replaceable>classpathlist</replaceable> contains multiple paths
or <acronym>JAR</acronym> files, they should be separated with a colon (:)
on Solaris and a semi-colon (;) on Windows. This option is not necessary if
the doclet is already in the search path. </para>
<para>Example of path to jar file that contains the starting doclet class
file. Notice the jar filename is included. <informalexample>
<screen> -docletpath /home/user/mifdoclet/lib/mifdoclet.jar</screen>
</informalexample></para>
<para>Example of path to starting doclet class file. Notice the class filename
is omitted. <informalexample>
<screen>-docletpath /home/user/mifdoclet/classes/com/sun/tools/doclets/mif/
</screen>
</informalexample></para>
</listitem></varlistentry>
<varlistentry><term><option>1.1</option> </term><listitem><para> This feature
has been removed from <command>javadoc</command> 1.4. There is no replacement
for it. This option created documentation with the appearance and functionality
of documentation generated by <command>javadoc</command> 1.1 (including never
supporting nested classes). If you need this option, use <command>javadoc
</command> 1.2 or 1.3 instead.</para>
</listitem></varlistentry>
<varlistentry><term><option>sourcepath</option> <replaceable>sourcepathlist
</replaceable> </term><listitem><para>Specifies the search paths for finding
source files (<literal>.java</literal>) when passing package names into the <command>
javadoc</command> command. The sourcepathlist can contain multiple paths by
separating them with a colon (:). The Javadoc tool will search in all subdirectories
of the specified paths. Note that this option is not only used to locate 
           the source files being documented, but also to find source files
that are not being documented but whose comments are inherited by the source
files being documented.</para>
<para> Notice that you can use the <option>sourcepath</option> option only
when passing package names into the <command>javadoc</command> command &mdash;
it will not locate <literal>.java</literal> files passed into the <command>
javadoc</command> command. (To locate <literal>.java</literal> files, cd to
that directory or include the path ahead of each file, as shown at <literal>
Documenting One or More Classes</literal>.)  If <option>sourcepath</option>
is omitted, <command>javadoc</command> uses the class path to find the source
files (see <option>classpath</option>). Therefore, the default <option>sourcepath
</option> is the value of class path. If  <option>classpath</option> is omitted
and you are passing package names into <command>javadoc</command>, it looks
in the current directory (and subdirectories) for the source files.</para>
<para>Set <replaceable>sourcepathlist</replaceable> to the root directory
of the source tree for the package you are documenting. For example, suppose
you want to document a package called <literal>com.mypackage</literal> whose
source files are located at:<informalexample><para><screen>/home/user/src/com/mypackage/*.java
</screen></para>
</informalexample>In this case, you would specify the source path to <literal>
/home/user/src</literal>, the directory that contains <literal>com/mypackage
</literal>, and then supply the package name <literal>com.mypackage</literal>:<informalexample>
<para><screen>example% <userinput>javadoc &ndash;sourcepath /home/user/src/ com.mypackage
</userinput></screen></para>
</informalexample>This is easy to remember by noticing that if you concatenate
the value of the source path and the package name together and change the
dot to a slash "/", you end up with the full path to the package:<informalexample>
<para><literal>/home/user/src/com/mypackage</literal></para>
</informalexample></para>
<para>To point to two source paths:<informalexample>
<screen>example% <userinput>javadoc -sourcepath /home/user1/src:/home/user2/src\
         com.mypackage</userinput></screen>
</informalexample></para>
</listitem></varlistentry>
<varlistentry><term><option>classpath</option> <replaceable>classpathlist
</replaceable> </term><listitem><para>Specifies the paths where <command>
javadoc</command> will look for referenced classes (<literal>.class</literal>) &mdash;
these are the documented classes plus any classes referenced by those classes.
 The Javadoc tool searches in all subdirectories of the specified paths. The
class path list can contain multiple paths by separating them with a colon.
The Javadoc tool will search in all subdirectories of the specified paths.
Follow the instructions in class path documentation for specifying <replaceable>
classpathlist</replaceable>.</para>
<para>If <option>sourcepath</option> is omitted, the Javadoc tool uses <option>
classpath</option> to find the source files as well as class files (for backward
compatibility). Therefore, if you want to search for source and class files
in separate paths, use both <option>sourcepath</option> and <option>classpath
</option>.</para>
<para>For example, if you want to document <literal>com.mypackage</literal>,
whose source files reside in the directory <literal>/home/user/src/com/mypackage
</literal>, and if this package relies on a library in <literal>/home/user/lib
</literal>, you would specify:<informalexample><para><screen>example% <userinput>
javadoc &ndash;classpath /home/user/lib &ndash;sourcepath \
               /home/user/src com.mypackage</userinput></screen></para>
</informalexample></para>
<para>As with other tools, if you do not specify <option>classpath</option>,
the Javadoc tool uses the <envar>CLASSPATH</envar> environment variable, if
it is set. If both are not set, the Javadoc tool searches for classes from
the current directory.</para>
<para>For an in-depth description of how the Javadoc tool uses <option>classpath
</option> to find user classes as it relates to extension classes and bootstrap
classes, see <literal>How Classes Are Found</literal>.</para>
</listitem></varlistentry>
<varlistentry><term><option>bootclasspath</option> <replaceable>classpathlist
</replaceable> </term><listitem><para>Specifies the paths where the boot classes
reside. These are nominally the Java platform classes. The <literal>bootclasspath
</literal> is part of the search path the Javadoc tool will use to look up
source and class files. See How Classes Are Found for more details. Separate
directories in <replaceable>dirlist</replaceable> with colons (:).</para>
</listitem></varlistentry>
<varlistentry><term><option>extdirs</option> <replaceable>dirlist</replaceable> 
</term><listitem><para>Specifies the directories where extension classes reside.
These are any classes that use the Java Extension mechanism. The <literal>
extdirs</literal> is part of the search path the Javadoc tool uses to look
up source and class files. See <option>classpath</option> (above) for more
details. Separate directories in <replaceable>dirlist</replaceable> with colons
(:).</para>
</listitem></varlistentry>
<varlistentry><term><option>verbose</option> </term><listitem><para>Provides
more detailed messages while <command>javadoc</command> is running. Without
the <option>verbose</option> option, messages appear for loading the source
files, generating the documentation (one message per source file), and sorting.
The <option>verbose</option> option causes the printing of additional messages
specifying the number of milliseconds to parse each Java source file.</para>
</listitem></varlistentry>
<varlistentry><term>quiet</term><listitem><para>Shuts off non-error and non-warning
messages, leaving only the warnings and errors appear, making them easier
to view. Also suppresses the version             string. </para>
</listitem></varlistentry>
<varlistentry><term><option>breakiterator</option></term><listitem><para>
Uses the internationalized sentence boundary of <literal>java.text.BreakIterator
</literal> to determine the end of the first sentence for English (all other
locales already use BreakIterator), rather than an English language, locale-specific
algorithm. By first sentence, we mean the             first sentence in the
main description of a package, class or member. This sentence is copied to
the package, class or member summary, and to the alphabetic index. </para>
<para>From JDK 1.2 forward, the BreakIterator class is already used to determine
the end of  sentence for all languages but English. Therefore, the -breakiterator
option has no effect except for English from 1.2 forward. English has its
own default algorithm: </para>
<simplelist>
<member>English default sentence-break algorithm - Stops at a period followed
by a space or a HTML block tag, such as &lt;P>. </member>
<member>Breakiterator sentence-break algorithm - In general, stops at a period,
question mark or exclamation mark followed by a space if the next word starts
with a capital letter. This is meant to handle most abbreviations (such as
"The serial no. is valid",                but won't handle "Mr. Smith"). Doesn't
stop at HTML tags or sentences that begin with numbers or symbols. Stops at
the last period in "../filename", even if embedded in an HTML tag. </member>
</simplelist>
<note><para>NOTE: We have removed from 1.5.0 the breakiterator warning messages
that were in 1.4.x and have left the default sentence-break algorithm unchanged.
That is, the <option>-breakiterator</option> option is not the default in
1.5.0, nor do we expect it to become the default. This is a reversal from
our former intention that the default would change in the "next major release"
(1.5.0). This means if you have not modified your source code to eliminate
the breakiterator warnings in 1.4.x, then you don't have to do anything, and
the warnings go away starting with 1.5.0. The reason for this reversal is
because any benefit to having breakiterator become the default would be outweighed
by the incompatible source change it would require. We regret any extra work
and confusion this  has caused. </para>
</note>
</listitem></varlistentry>
<varlistentry><term><option>locale</option> <replaceable>language_country_variant
</replaceable> </term><listitem><para><emphasis>Important:</emphasis> The <option>
locale</option> option must be placed ahead (to the left) of any options provided
by the standard doclet or any other doclet. Otherwise, the navigation bars
will appear in English. This is the only command-line option that is order-dependent.
</para>
<para>Specifies the locale that <command>javadoc</command> uses when generating
documentation. The argument is the name of the locale, as described in <literal>
java.util.Locale</literal> documentation, such as <literal>en_US</literal>
(English, United States) or <literal>en_US_WIN</literal> (Windows variant).
</para>
<para>Specifying a locale causes <command>javadoc</command> to choose the
resource files of that locale for messages (strings in the navigation bar,
headings for lists and tables, help file contents, comments in <literal>stylesheet.css
</literal>, and so forth). It also specifies the sorting order for lists sorted
alphabetically, and the sentence separator to determine the end of the first
sentence. It does not determine the locale of the doc comment text specified
in the source files of the documented classes.</para>
</listitem></varlistentry>
<varlistentry><term><option>encoding</option> <replaceable>name</replaceable> 
</term><listitem><para>Specifies the source file encoding name, such as EUCJIS/SJIS.
If this option is not specified, the platform default converter is used.</para>
</listitem></varlistentry>
<varlistentry><term><option>J</option><replaceable>flag</replaceable> </term>
<listitem><para>Passes flag directly to the runtime system java that runs <command>
javadoc</command>. Notice there must be no space between the <option>J</option>
and the flag. For example, if you need to ensure that the system sets aside
32 megabytes of memory in which to process the generated documentation, then
you would call the <option>Xmx</option> option of <command>java</command>
as follows (<option>Xms</option> is optional, as it only sets the size of
initial memory, which is useful if you know the minimum amount of memory required):<informalexample>
<para><screen>example% <userinput>javadoc &ndash;J&ndash;Xmx32m &ndash;J&ndash;Xms32m com.mypackage
</userinput></screen></para>
</informalexample></para>
<para>To tell what version of javadoc you are using, call the <option>version
</option> option of java: <informalexample>
<screen>% javadoc -J-version
               java version "1.2"
               Classic VM (build JDK-1.2-V, green threads, sunwjit)</screen>
</informalexample></para>
<para>(The version number of the standard doclet appears in its output stream.) 
</para>
</listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title>Options Provided by the Standard Doclet</title>
<variablelist termlength="wholeline">
<varlistentry><term><option>d</option> <replaceable>directory</replaceable> 
</term><listitem><para>Specifies the destination directory where <command>
javadoc</command> saves the generated HTML files. (The "d" means "destination.")
 Omitting this option causes the files to be saved to the current directory.
The value <replaceable>directory</replaceable> can be absolute or relative
to the current working directory. As of 1.4, the destination directory is
automatically created when javadoc is run. </para>
<para> For example, the following generates the documentation for the <literal>
com.mypackage</literal> package and saves the results in the <literal>/home/user/doc/
</literal> directory:<informalexample><para><screen>example% <userinput>javadoc &ndash;d /home/user/doc com.mypackage
</userinput></screen></para>
</informalexample></para>
</listitem></varlistentry>
<varlistentry><term><option>use</option> </term><listitem><para>Includes one
"Use" page for each documented class and package. The page describes what
packages, classes, methods, constructors, and fields use any API of the given
class or package. Given class C, things that use class C would include subclasses
of C, fields declared as C, methods that return C, and methods and constructors
with parameters of type C.</para>
<para>For example, let's look at what might appear on the "Use" page for <literal>
String</literal>. The <literal>getName()</literal> method in the <literal>
java.awt.Font</literal> class returns type <literal>String</literal>. Therefore, <literal>
getName()</literal> uses <literal>String</literal>, and you will find that
method on the "Use" page for <literal>String</literal>.</para>
<para>Notice that this page documents only uses of the <acronym>API</acronym>,
not the implementation. If a method uses <literal>String</literal> in its
implementation but does not take a string as an argument or return a string,
that is not considered a "use" of <literal>String</literal>.</para>
<para>You can access the generated "Use" page by first going to the class
or package, then clicking on the "Use" link in the navigation bar.</para>
</listitem></varlistentry>
<varlistentry><term><option>version</option> </term><listitem><para>Includes
the <literal>@version</literal> text in the generated docs. This text is omitted
by default.To tell what version of the Javadoc tool you are using, use the<option>
 J-version</option> option. </para>
</listitem></varlistentry>
<varlistentry><term><option>author</option> </term><listitem><para>Includes
the <literal>@author</literal> text in the generated docs.</para>
</listitem></varlistentry>
<varlistentry><term><option>splitindex</option> </term><listitem><para>Splits
the index file into multiple files, alphabetically, one file per letter, plus
a file for any index entries that start with non-alphabetical characters.
</para>
</listitem></varlistentry>
<varlistentry><term><option>windowtitle</option> <replaceable>title</replaceable> 
</term><listitem><para>Specifies the title to be placed in the HTML <literal>
&lt;title></literal> tag. This appears in the window title and in any browser
bookmarks (favorite places) that someone creates for this page. This title
should not contain any HTML tags, as the browser cannot properly interpret
them. Any internal quotation marks within <replaceable>title</replaceable>
might have to be escaped. If <option>windowtitle</option> is omitted, the
Javadoc tool uses the value of <option>doctitle</option> for this option.
</para>
<informalexample>
<screen> % javadoc -windowtitle "Java 2 Platform" com.mypackage

</screen>
</informalexample>
</listitem></varlistentry>
<varlistentry><term><option>doctitle</option> <replaceable>title</replaceable> 
</term><listitem><para>Specifies the title to be placed near the top of the
overview summary file. The title is placed as a centered, level-one heading
directly beneath the upper navigation bar. The <replaceable>title</replaceable>
can contain HTML tags and white space, though if it does, it must be enclosed
in quotes. Any internal quotation marks within <replaceable>title</replaceable>
might have to be escaped.</para>
<informalexample>
<screen> % javadoc -doctitle "Java &lt;sup>&lt;font size=\"-2\">TM&lt;/font>&lt;/sup>" com.mypackage
</screen>
</informalexample>
</listitem></varlistentry>
<varlistentry><term><option>title</option> <replaceable>title</replaceable> 
</term><listitem><para>This option no longer exists. It existed only in Beta
versions of <command>javadoc</command> 1.2. It has been renamed to <option>
doctitle</option>. This option was renamed to make it clear that it defines
the document title rather than the window title.</para>
</listitem></varlistentry>
<varlistentry><term><option>header</option> <replaceable>header</replaceable> 
</term><listitem><para>Specifies the header text to be placed at the top of
each output file. The header is placed to the right of the upper navigation
bar. <replaceable>header</replaceable> can contain HTML tags and white space,
though if it does, it must be enclosed in quotes. Any internal quotation marks
within <replaceable>header</replaceable> may have to be escaped.</para>
<informalexample>
<screen> % javadoc -header "&lt;b>Java 2 Platform&lt;/b>&lt;br>v1.4" com.mypackage

</screen>
</informalexample>
</listitem></varlistentry>
<varlistentry><term><option>footer</option> <replaceable>footer</replaceable> 
</term><listitem><para>Specifies the footer text to be placed at the bottom
of each output file. The footer is placed to the right of the lower navigation
bar. <replaceable>footer</replaceable> can contain HTML tags and white space,
though if it does, it must be enclosed in quotes. Any internal quotation marks
within <replaceable>footer</replaceable> may have to be escaped.</para>
</listitem></varlistentry>
<varlistentry><term><option>bottom</option> <replaceable>text</replaceable> 
</term><listitem><para>Specifies the text to be placed at the bottom of each
output file. The text is placed at the bottom of the page, below the lower
navigation bar. <replaceable>text</replaceable> can contain HTML tags and
white space, though if it does, it must be enclosed in quotes. Any internal
quotation marks within <replaceable>text</replaceable> may have to be escaped.
</para>
</listitem></varlistentry>
<varlistentry><term><option>link</option> <replaceable>extdocURL</replaceable> 
</term><listitem><para>Creates links to existing <command>javadoc</command>-generated
documentation of external referenced classes. It takes one argument:</para>
<itemizedlist>
<listitem><para><replaceable>extdocURL</replaceable> is the absolute or relative
URL of the directory containing the external javadoc-generated documentation
you want  to link to. Examples are shown below. The package-list file must
be found in this directory (otherwise, use <literal>linkoffline</literal>).
The Javadoc tool reads the package names from the package-list file and then
links to those packages at that URL. When the Javadoc tool is run, the <replaceable>
extdocURL</replaceable> value is copied literally into the into the &lt;A
HREF> links that are created. Therefore,<replaceable> extdocURL</replaceable>
must be the URL to the directory, not to a file. </para>
<para>You can use an absolute link for <replaceable>extdocURL</replaceable>
to enable your docs to link to a document on any website, or can use a relative
link to link only                   to a relative location. If relative, the
value you pass in should be the relative path from the destination directory
(specified with <option>d</option>) to the directory containing the packages
being linked to. </para>
<para>When specifying an absolute link you normally use an <literal>http:
</literal> link. However, if you want to link to a file system that has no
web server, you                   can use a <literal>file:</literal> link
-- however, do this only if everyone wanting to access the generated documentation
shares the same file system. </para>
</listitem>
</itemizedlist>
<para><emphasis>Choosing between</emphasis> <option>linkoffline</option><emphasis>
 and</emphasis> <option>link</option> </para>
<para>One or the other option is appropriate when linking to an <acronym>
API</acronym> document that is external to the current javadoc run. </para>
<para>Use <option>link</option>: </para>
<para><itemizedlist>
<listitem><para>when using a relative path to the external <acronym>API</acronym>
document, or </para>
</listitem>
<listitem><para>when using an absolute URL to the external <acronym>API</acronym>
document, if your shell allows a program to open a connection to that URL
for reading. </para>
</listitem>
</itemizedlist></para>
<para>Use <option>linkoffline</option>: </para>
<itemizedlist>
<listitem><para>when using an absolute URL to the external <acronym>API</acronym>
document, if your shell does not allow a program to open a connection to that
URL for  reading. This can occur if you are behind a firewall and the document
you want to link to is on the other side. </para>
</listitem>
</itemizedlist>
<para><emphasis>Example using absolute links to the external docs</emphasis></para>
<para>Let's say you want to link to the<literal> java.lang</literal>, <literal>
java.io</literal> and other Java 2 Platform packages at http://java.sun.com/j2se/1.4/docs/api,
The             following command generates documentation for the package <literal>
com.mypackage</literal> with links to the Java 2 Platform packages. The generated
documentation             will contain links to the <literal>Object</literal>
class, for example, in the class trees. (Other options, such as <option>sourcepath
</option> and <option>d</option>, are not shown.) </para>
<informalexample>
<screen>% javadoc -link http://java.sun.com/j2se/1.4/docs/api com.mypackage

</screen>
</informalexample>
<para><emphasis>Example using relative links to the external docs </emphasis></para>
<para>Let's say you have two packages whose docs are generated in different
runs of the Javadoc tool, and those docs are separated by a relative path.
In this example, the packages are <literal>com.apipackage</literal>, an <acronym>
API</acronym>, and<literal> com.spipackage</literal>, an <acronym>SPI</acronym>
(Service Provide Interface). You want the documentation to reside in <literal>
docs/api/com/apipackage</literal> and             <literal>docs/spi/com/spipackage
</literal>. Assuming the <acronym>API</acronym> package documentation is already
generated, and that docs is the current directory, you would document the <acronym>
SPI</acronym> package with links to the <acronym>API</acronym> documentation
by running: </para>
<informalexample>
<screen>% javadoc -d ./spi -link ../api com.spipackage

</screen>
</informalexample>
<para>Notice the <option>link</option> argument is relative to the destination
directory (<literal>docs/spi</literal>).</para>
<para><emphasis>Details</emphasis> </para>
<para>The <option>link</option> option enables you to link to classes referenced
to by your code but not documented in the current javadoc run. For these links
to go to valid pages, you must know where those HTML pages are located, and
specify that location with <replaceable>extdocURL</replaceable>. This allows,
for instance, third party documentation to link to<literal> java.*</literal>
documentation on http://java.sun.com. </para>
<para>Omit the <option>link</option> option for javadoc to create links only
to <acronym>API</acronym> within the documentation it is generating in the
current run. (Without the <option>link</option> option, the Javadoc tool does
not create links to documentation             for external references, because
it does not know if or where that documentation exists.) </para>
<para>You can specify multiple <option>link</option> options in a given javadoc
run to link to multiple documents. </para>
<para>Another use is for cross-links between sets of packages: Execute <command>
javadoc</command> on one set of packages, then run <command>javadoc</command>
again on another set of packages, creating links both ways between both sets.
A third use is as a "hack" to update docs: Execute <command>javadoc</command>
on a full set of packages, then run <command>javadoc</command> again on only
the smaller set of changed packages, so that the updated files can be inserted
back into the original set.</para>
<para><emphasis>Bug Fix for Referenced Classes</emphasis> </para>
<para>In 1.4 the following bug has been fixed: <itemizedlist>
<listitem><para>Link bug in 1.2 and 1.3 - When <literal>@see</literal> or <literal>
{@link}</literal> references an excluded class and <option>link</option> is
used, an                    and <option>link</option> is used, an &lt;A HREF>
hyperlink is created only if the class is referenced either in an import statement
or in a declaration.                   References in the body of methods,
alone, are inadequate. A workaround                   was to include an explicit
(not wildcard) import statement for the referenced class. </para>
</listitem>
</itemizedlist></para>
<para>An <literal>@see</literal> or <literal>{@link}</literal> reference with <option>
link</option> is now enough to load the referenced class and enable a link
to it. You can remove any import statements you had added as workarounds,
which we had suggested you comment as follows: </para>
<informalexample>
<screen> import java.lang.SecurityManager; // workaround to force @see/@link hyperlink

</screen>
</informalexample>
<para><emphasis>Package List:</emphasis> The <option>link</option> option
requires that a file named <literal>package-list</literal>, which is generated
by  <command>javadoc</command>the Javadoc tool, exist at the URL you specify
with <option>link</option>. The  <literal>package-list</literal> file is a
simple text file that lists the names of packages documented at that location.
In the earlier example, the Javadoc tool looks for a file named <literal>
package-list</literal> at the given URL, reads in the package names and then
links to those packages at that URL. </para>
<para>For example, the package list for the Java 2 Platform v1.4 API is located
at<informalexample><para><ulink url="http://java.sun.com/products/jdk/1.2/docs/api/package-list">
http://java.sun.com/products/jdk/1.2/docs/api/package-list</ulink></para>
</informalexample></para>
<para>and starts out as follows:<informalexample><para><screen>java.applet
java.awt
java.awt.color
java.awt.datatransfer
java.awt.dnd
java.awt.event
java.awt.font
etc.</screen></para>
</informalexample></para>
<para>When <command>javadoc</command> is run without the <option>link</option>
option, when it encounters a name that belongs to an external referenced class,
it prints the name with no link. However, when the <option>link</option> option
is used, <command>javadoc</command> searches the <literal>package-list</literal>
file at the specified <replaceable>extdocURL</replaceable> location for that
package name. If it finds the package name, it prefixes the name with that
URL. </para>
<para>In order for there to be no broken links, all of the documentation for
the external references must exist at the specified URLs. The Javadoc tool
does not check that these pages exist &mdash; only that the <literal>package-list
</literal> exists.</para>
<para>The <literal>package-list</literal> file is created but is empty if
the argument to <command>javadoc</command> is source files rather than packages.
</para>
<para><emphasis>Multiple Links:</emphasis> You can supply multiple <option>
link</option> options to link to any number of external generated documents.
Javadoc 1.2 has a known bug that prevents you from supplying more than one <option>
link</option> command. This was fixed in 1.2.2.</para>
<para>Specify a different link option for each external document to link to:<informalexample>
<para><screen>example% <userinput>javadoc &ndash;link extdocURL1 &ndash;link extdocURL2 ...\
                 &ndash;link extdocURLn com.mypackage</userinput></screen></para>
</informalexample>where <literal>extdocURL1</literal>, <literal>extdocURL2
</literal>, <literal>... extdocURLn</literal> point respectively to the roots
of external documents, each of which contains a file named <literal>package-list
</literal>.</para>
<para><emphasis>Cross Links:</emphasis> Notice that "bootstrapping" might
be required when cross-linking two or more documents that have not been previously
generated. In other words, if  <literal>package-list</literal> does not exist
for either document, when you run the Javadoc tool on the first document,
the <literal>package-list</literal> does not yet exist for the second document.
Therefore, to create the external links, you must re-generate the first document
after generating the second document.</para>
<para>In this case, the purpose of first generating a document is to create
its <literal>package-list</literal> (or you can create it by hand if you are
certain of the package names). Then generate the second document with its
external links. The Javadoc tool prints a warning if a needed external  <literal>
package-list</literal> file does not exist.</para>
</listitem></varlistentry>
<varlistentry><term><option>linkoffline</option> <replaceable>extdocURL  packagelistLoc
</replaceable> </term><listitem><para>This option is a variation of <option>
link</option>; they both create links to documentation for external referenced
classes. Use the <option>linkoffline</option>  option when linking to a document
on the web when the Javadoc tool itself is "offline" -- that is, it cannot
access the document through a web connection.</para>
<para>More specifically, use <option>linkoffline</option> if the external
document's <literal>package-list</literal> file is not accessible or does
not exist at the <replaceable>extdocURL</replaceable> location but does exist
at a different location, which can be specified by <replaceable>packageListLoc
</replaceable> (typically local). Thus, if<replaceable> extdocURL</replaceable>
is accessible only on the World Wide Web, <option>linkoffline</option> removes
the constraint that the Javadoc tool have a web connection when generating
the documentation. Examples are given below. </para>
<para>The <option>linkoffline</option> option takes two arguments --  the
first for the string to be embedded in the the first for the string to be
embedded in the &lt;a href> links, the second telling it where to find <literal>
package-list</literal>:  </para>
<para><variablelist termlength="narrow">
<varlistentry><term><replaceable>extdocURL</replaceable></term><listitem>
<para>is the absolute or relative URL of the directory containing the external <command>
javadoc</command>-generated documentation you want to link to. If relative,
the value should be the relative path from the destination directory     
             (specified with <option>d</option>) to the root of the packages
                  being linked to. For more details, see  <replaceable>extdocURL
</replaceable> in the <option>link</option> option.</para>
</listitem></varlistentry>
<varlistentry><term><replaceable>packagelistLoc</replaceable></term><listitem>
<para>is the path or URL to the directory containing the <literal>package-list
</literal> file for                 the external documentation. This can be
a URL  (http: or file:) or file path, and can be absolute or relative. If
relative, make it relative to the current directory from where javadoc was
run. Do not include the<literal> package-list</literal> filename. </para>
</listitem></varlistentry>
</variablelist></para>
<para>You can specify multiple <option>linkoffline</option> options in a 
given javadoc run. (Prior to 1.2.2, it could be specified only once.) </para>
<para><emphasis>Example using absolute links to the external docs </emphasis></para>
<para> Let's say you want to link to the <literal>java.lang</literal>, <literal>
java.io</literal> and other Java 2 Platform packages at http://java.sun.com/j2se/1.4/docs/api,
but your             shell does not have web access. You could open the <literal>
package-list</literal> file in a browser at http://java.sun.com/j2se/1.4/docs/api/package-list,
save it to a local directory, and point to this local copy with the second
argument, <replaceable>packagelistLoc</replaceable>. In this example, the
package list file has been saved to the current directory "." . The following
command generates documentation for the package<literal> com.mypackage </literal>with
links to the Java 2 Platform packages. The generated documentation will contain
links to the <literal>Object</literal> class, for example, in the class trees.
(Other necessary options, such as <option>sourcepath</option>, are not shown.) <informalexample>
<screen>% javadoc -linkoffline http://java.sun.com/j2se/1.4/docs/api . com.mypackage

</screen>
</informalexample></para>
<para><emphasis>Example using relative links to the external docs</emphasis> 
</para>
<para>It's not very common to use <option>linkoffline</option> with relative
paths, for the simple reason that <option>link</option> usually suffices.
When using <option>linkoffline</option>, the <literal>package-list</literal>
file is generally local, and when using             relative links, the file
you are linking to is also generally local. So it is usually unnecessary to
give a different path for the two arguments to <option>linkoffline</option>.
When the two arguments are identical, you can use <option>link</option>. See
the <option>link</option> relative example. </para>
<para><emphasis>Manually Creating A</emphasis> <literal>package-list</literal><emphasis>
 File</emphasis></para>
<para>If a <literal>package-list</literal> file does not yet exist, but you
know what package names your document will link to, you can create your own
copy of this file by hand and specify its path with <replaceable>packagelistLoc
</replaceable>. An example would be the previous case where the package list
for <literal>com.spipackage</literal> did not exist when <literal>com.apipackage
</literal> was first generated. This technique is useful when you need to
generate documentation that links to new external documentation whose package
names you know, but which is not yet published. This is also a way of creating
a <literal>package-list</literal> file for linking to documentation generated
with <command>Javadoc</command> 1.0 or 1.1, earlier versions where <literal>
package-list</literal> files were not generated. Likewise, two companies can
share their unpublished <literal>package-list</literal> files, enabling them
to release their cross-linked documentation simultaneously. </para>
<para><emphasis>Linking to Multiple Documents</emphasis></para>
<para>You can include <option>linkoffline</option> once for each generated
document you want to refer to (each option is shown on a separate line for
clarity):<informalexample>
<screen>example% <userinput>javadoc -linkoffline extdocURL1 packagelistLoc1\
                 -linkoffline extdocURL2 packagelistLoc2\
              ...</userinput></screen>
</informalexample></para>
<para><emphasis>Updating Docs:</emphasis> The third use for the  <option>
linkoffline</option> option is useful if your project has dozens or hundreds
of packages; if you have already run <command>javadoc</command> on the entire
tree; and now, in a separate run, you want to quickly make some small changes
and re-run <command>javadoc</command> on just a small portion of the source
tree. This is somewhat of a hack in that it works properly only if your changes
are only to doc comments and not to signatures. If you were to add, remove,
or change any signatures from the source code, then broken links could show
up in the index, package tree, inherited member lists, use page, or other
places.</para>
<para>First, you create a new destination directory (call it update) for this
new small run. Set the first argument of <option>linkoffline</option> to the
current directory &rdquo;.&rdquo; and set the second argument to the relative
path to the original docs (call it html), where it can find package-list:<informalexample>
<para><screen>example% <userinput>javadoc &ndash;d update &ndash;linkoffline . html com.mypackage
</userinput></screen></para>
</informalexample></para>
<para>When <command>javadoc</command> is done, copy these generated class
pages (not the overview or index) in <literal>update</literal> over the original
files in <literal>html</literal>.</para>
</listitem></varlistentry>
</variablelist>
<variablelist>
<varlistentry><term>linksource</term><listitem><para>Creates an HTML version
of each source file (with line numbers) and adds links to them from the standard
HTML documentation. This option exposes all private implementation details
in the included source files, including private classes, private fields, and
the bodies of private methods, regardless of the <option>public</option>, <option>
package</option>, <option>protected</option> and <option>private</option>
options. Unless you also use the <option>private</option> option, not all
private classes or interfaces will necessarily be accessible via links. </para>
</listitem></varlistentry>
</variablelist>
<variablelist termlength="wholeline">
<varlistentry><term><option>group</option> <replaceable>groupheading  packagepattern:packagepattern:..
</replaceable> </term><listitem><para>Separates packages on the overview page
into whatever groups you specify, one group per table. You specify each group
with a different <option>group</option> option. The groups appear on the page
in the order specified on the command line; packages are alphabetized within
a group. For a given <option>group</option> option, the packages matching
the list of <replaceable>packagepattern</replaceable> expressions appear in
a table with the heading <replaceable>groupheading</replaceable>.<itemizedlist>
<listitem><para><replaceable>groupheading</replaceable> can be any text, and
can include white space. This text is placed in the table heading for the
group.</para>
</listitem>
<listitem><para><replaceable>packagepattern</replaceable> can be any package
name, or can be the start of any package name followed by an asterisk (*).
The asterisk is a wildcard meaning "match any characters". This is the only
wildcard allowed. Multiple patterns can be included in a group by separating
them with colons (:).</para>
</listitem>
</itemizedlist><emphasis>Note:</emphasis> If using an asterisk in a pattern
or pattern list, the pattern list must be inside quotes, such as "java.lang*:java.util".
</para>
<para>If you do not supply any <option>group</option> option, all packages
are placed in one group with the heading "Packages". If the all groups do
not include all documented packages, any leftover packages appear in a separate
group with the heading "Other Packages".</para>
<para>For example, the following option separates the four documented packages
into core, extension, and other packages. Notice the trailing "dot" does not
appear in "<literal>java.lang*</literal>". Including the dot, such as "<literal>
java.lang.*</literal>", would omit the <literal>java.lang</literal> package:<informalexample>
<para><screen>example% <userinput>javadoc &ndash;group "Core Packages" "java.lang*:java.util" \
    &ndash;group "Extension Packages" "javax.*" \
    java.lang java.lang.reflect java.util javax.servlet java.new</userinput></screen></para>
</informalexample></para>
<para>This results in the groupings:</para>
<informalexample><para><screen>Core Packages
  java.lang
  java.lang.reflect
  java.util
Extension Packages
  javax.servlet
Other Packages
  java.new</screen></para>
</informalexample>
</listitem></varlistentry>
<varlistentry><term><option>nodeprecated</option> </term><listitem><para>
Prevents the generation of any deprecated <acronym>API</acronym> at all in
the documentation. This does what <option>nodeprecatedlist</option> does,
plus it does not generate any deprecated <acronym>API</acronym> throughout
the rest of the documentation. This is useful when writing code and you do
not want to be distracted by the deprecated code.</para>
</listitem></varlistentry>
<varlistentry><term><option>nodeprecatedlist</option> </term><listitem><para>
Prevents the generation of the file containing the list of deprecated <acronym>
API</acronym>s (<literal>deprecated-list.html</literal>) and the link in the
navigation bar to that page. (However, <command>javadoc</command> continues
to generate the deprecated <acronym>API</acronym> throughout the rest of the
document.)  This is useful if your source code contains no deprecated <acronym>
API</acronym>, and you want to make the navigation bar cleaner.</para>
</listitem></varlistentry>
<varlistentry><term><option>nosince</option></term><listitem><para>Omits from
the generated docs the "Since" sections associated with the <literal>@since
</literal> tags. </para>
</listitem></varlistentry>
<varlistentry><term><option>notree</option> </term><listitem><para>Omits the
class/interface hierarchy from the generated docs. The hierarchy is produced
by default.</para>
</listitem></varlistentry>
<varlistentry><term><option>noindex</option> </term><listitem><para>Omits
the index from the generated docs. The index is produced by default.</para>
</listitem></varlistentry>
<varlistentry><term><option>nohelp</option> </term><listitem><para>Omits the
HELP link in the navigation bars at the top and bottom of each page of output.
</para>
</listitem></varlistentry>
<varlistentry><term><option>nonavbar</option> </term><listitem><para>Prevents
the generation of the navigation bar, header and footer, otherwise found at
the top and bottom of the generated pages. Has no effect on the "bottom" option.
The <option>nonavbar</option> option is useful when you are interested only
in the content and have no need for navigation, such as converting the files
to PostScript or PDF for print only.</para>
</listitem></varlistentry>
<varlistentry><term><option>helpfile</option> <replaceable>path/filename</replaceable> 
</term><listitem><para>Specifies the path of an alternate help file <replaceable>
path/filename</replaceable> that the HELP link in the top and bottom navigation
bars link to. Without this option, the Javadoc tool automatically creates
a help file <literal>help-doc.html</literal> that is hard-coded in the Javadoc
tool. This option enables you to override this default. The file name can
be any name and is not restricted to <literal>help-doc.html</literal>. The
Javadoc tool will adjust the links in the navigation bar accordingly. For
example:<informalexample><para><screen>example% <userinput>javadoc &ndash;helpfile /home/doc/myhelp.html java.awt
</userinput></screen></para>
</informalexample></para>
</listitem></varlistentry>
<varlistentry><term><command>stylesheetfile</command> <replaceable>path/filename
</replaceable> </term><listitem><para>Specifies the path of an alternate HTML
stylesheet file. Without this option, the Javadoc tool automatically creates
a stylesheet file, <literal>stylesheet.css</literal>, that is hard-coded in
the Javadoc tool. This option enables you to override this default. The file
name can be any name and is not restricted to <literal>stylesheet.css</literal>.
For example:<informalexample><para><screen>example% <userinput>javadoc &ndash;stylesheetfile \
            /home/doc/mystylesheet.css java.awt</userinput></screen></para>
</informalexample></para>
</listitem></varlistentry>
<varlistentry><term><option>serialwarn</option> </term><listitem><para>Generates
compile-time warnings for missing <literal>@serial</literal> tags. By default, <command>
Javadoc</command> 1.2.2 (and later versions) generates no serial warnings.
(This is a reversal from earlier versions.)  Use this option to display the
serial warnings, which helps to properly document default serializable fields
and writeExternal methods.</para>
</listitem></varlistentry>
<varlistentry><term><option>charset</option> <replaceable>name</replaceable> 
</term><listitem><para>Specifies the HTML character set for this document.
For example:<informalexample><para><screen>example% <userinput>javadoc &ndash;charset "iso-8859-1" mypackage
</userinput></screen></para>
</informalexample>would insert the following line in the head of every generated
page:<informalexample>
<screen>&lt;META http-equiv="Content-Type" content="text/html; charset=iso-885 9-1">
</screen>
</informalexample>This META tag is described in the HTML standard (4197265
and 4137321).</para>
</listitem></varlistentry>
<varlistentry><term><option>docencoding</option> <replaceable>name</replaceable> 
</term><listitem><para>Specifies the encoding of the generated HTML files.
</para>
</listitem></varlistentry>
<varlistentry><term>keywords</term><listitem><para>Adds HTML meta keyword
tags to the generated file for each class. These tags can help the page be
found by search engines that look for meta tags. (Most search engines that
search the entire Internet do not look at meta tags, because pages can misuse
them; but search engines offered by companies that confine their search to
their own website can benefit by looking at meta tags.) </para>
<para>The meta tags include the fully qualified name of the class and the
unqualified names of the fields and methods. Constructors are not included
because they are identical to the class name. For example, the class <literal>
String</literal> starts with these keywords: </para>
<screen>&lt;META NAME="keywords" CONTENT="java.lang.String class">
		 &lt;META NAME="keywords" CONTENT="CASE_INSENSITIVE_ORDER">
 		 &lt;META NAME="keywords" CONTENT="length()">
		 &lt;META NAME="keywords" CONTENT="charAt()"></screen>
</listitem></varlistentry>
<varlistentry><term><option>tag</option><replaceable>tagname:Xaoptcmf:"taghead"
</replaceable></term><listitem><para>Enables javadoc to interpret a simple,
one-argument custom standalone tag <literal>@tagname</literal> in doc comments.
So the Javadoc tool can "spell-check" tag names, it is important to include
a <option>tag</option> option for every custom tag that is present in the
source code, disabling (with X) those that are not being output in the current
run.</para>
<para>The colon (:) is always the separator. To use a colon in tagname, see
Use of Colon in Tag Name. </para>
<para>The <option>tag</option> option outputs the tag's heading taghead in
bold, followed on the next line by the text from its single argument, as shown
in the example below. Like any standalone tag, this argument's text can contain
inline tags, which are also interpreted. The output is similar to standard
one-argument tags, such as <literal>@return</literal> and <literal>@author
</literal>. </para>
<para><emphasis>Placement of tags</emphasis> </para>
<para>The <replaceable>Xaoptcmf</replaceable> part of the argument determines
where in the source code the tag is allowed to be placed, and whether the
tag can be disabled (using X). You can supply either a, to allow the tag in
all places, or any combination of theother letters: </para>
<screen>X (disable tag)
                  a (all)
                  o (overview)
                  p (packages)
                  t (types, that is classes and interfaces)
                  c (constructors)
                  m (methods)
                  f (fields) </screen>
<para><emphasis>Examples of single tags</emphasis> - An example of a tag option
for a tag that that can be used anywhere in the source code is: </para>
<informalexample>
<screen> -tag todo:a:"To Do:"</screen>
</informalexample>
<para>If you wanted <literal>@todo</literal> to be used only with constructors,
methods and fields, you would use: </para>
<informalexample>
<screen> -tag todo:cmf:"To Do:"</screen>
</informalexample>
<para>Notice the last colon (:) above is not a parameter separator, but is
part of the heading text (as shown below). You would use either tag option
for source code that contains the tag <literal>@todo</literal>, such as: 
</para>
<informalexample>
<screen>@todo The documentation for this method needs work.</screen>
</informalexample>
<para>This line would produce output something like: </para>
<informalexample>
<screen>To Do: 
                       The documentation for this
                       method needs work. </screen>
</informalexample>
<para><emphasis>Use of Colon in Tag Name</emphasis> - A colon can be used
in a tag name if it is escaped with a backslash. For this doc comment: </para>
<screen>/**
        * @ejb:bean
        */</screen>
<para>use this tag option: </para>
<screen> -tag ejb\\:bean:a:"EJB Bean:"</screen>
<para><emphasis>Spell-checking tag names (Disabling tags)</emphasis> -  Some
developers put custom tags in the source code that they don't always want
to output. In these cases, it is important to list all tags that are present
in the source code, enabling the ones you want to output and disabling the
ones you don't want to output. The presence of X disables the tag, while its
absence enables the tag. This gives the Javadoc tool  enough information to
know if a tag it encounters is  unknown, probably the results of a typo or
a misspelling. It prints a warning in these cases. </para>
<para>You can add X to the placement values already present, so that when
you want to enable the tag, you can simply delete the X. For example, if <literal>
@todo</literal> is  a tag that you want to suppress on output, you would use: 
</para>
<informalexample>
<screen>   -tag todo:Xcmf:"To Do:"</screen>
</informalexample>
<para>or, if you'd rather keep it simple: </para>
<informalexample>
<screen> -tag todo:X</screen>
</informalexample>
<para>The syntax <option>tag todo:X</option> works even if <literal>@todo
</literal> is defined by a taglet. </para>
<para><emphasis>Order of tags</emphasis> - The order of the <option>tag</option>
(and <option>taglet</option>) options determine the order the tags are output.
You can mix the custom tags with the standard tags to intersperse them. The
tag options for standard tags are placeholders only for determining the order
--  they take only the standard tag's name. (Subheadings for standard    
        tags cannot be altered.) This is illustrated in the following example.
</para>
<para>If <option>tag</option> is missing, then the position of <option>taglet
</option> determines its             order. If they are both present, then
whichever appears last on the command line determines its order. (This happens
because the tags and taglets are processed in the order that they appear on
the             command line. For example, if <option>taglet</option> and <option>
tag</option> both have the name "todo", the one that appears last on the command
line will determine its order. </para>
<para><emphasis>Example of a complete set of tags</emphasis> - This example
inserts "To Do" after "Parameters" and before "Throws" in the output. By using
"X", it also specifies that <literal>@example</literal> is a tag that might
be encountered in the source code that should not be output during       
     this run. Notice that if you use<literal> @argfile</literal>, you can
put the tags on separate lines in an argument file like this (no line continuation
characters needed): </para>
<informalexample>
<screen>-tag param
               -tag return
               -tag todo:a:"To Do:"
               -tag throws
               -tag see
               -tag example:X</screen>
</informalexample>
<para>When javadoc parses the doc comments, any tag encountered that is neither
a standard tag nor passed in with <option>tag</option> or <option>taglet</option>
is considered unknown, and a warning is thrown.</para>
<para>The standard tags are initially stored internally in a list in their
default order. Whenever <option>tag</option> options are used, those tags
get appended to this list -- standard tags are moved from their default position.
Therefore, if a <option>tag</option> option is omitted for a standard tag,
it remains in its default position. </para>
<para><emphasis>Avoiding Conflicts</emphasis> - If you want to slice out your
own namespace, you can use a dot-separated naming convention similar to that
used for packages: <literal>com.mycompany.todo</literal>. Sun will continue
to create standard tags whose names do not contain dots. Any tag you create
will override the behavior of a tag by the same name defined by Sun. In other
words, if you create a tag or taglet <literal>@todo</literal>, it will always
have the same behavior you define, even if Sun later creates a standard tag
of the same name. </para>
<para>You can also create more complex standalone tags, or custom inline tags
with the <option>taglet</option> option. </para>
</listitem></varlistentry>
<varlistentry><term><option>taglet</option>  <replaceable>class</replaceable> 
</term><listitem><para>Specifies the class file that starts the taglet used
in generating the documentation for that tag. Use the fully-qualified name
for class. This taglet also defines the number of text arguments that the
custom tag has. The taglet accepts those arguments, processes them, and generates
the output. For extensive documentation with example taglets, see Taglet Overview.
</para>
<para>Taglets are useful for standalone or inline tags. They can have any
number of arguments and implement custom behavior, such as making text bold,
formatting bullets, writing out the text to a file, or starting other processes. 
</para>
<para>Taglets can only determine where a tag should appear and in what form.
All other decisions are made by the doclet. So a taglet cannot do things such
as remove a class name from the list of included classes. However, it can
execute side effects, such as printing the tag's text to a file or triggering
another process. </para>
<para>Use the <option>tagletpath</option> option to specify the path to the
taglet. Here is an example that inserts the "To Do" taglet after "Parameters"
and ahead of "Throws" in the generated pages: </para>
<informalexample>
<screen> -taglet com.sun.tools.doclets.ToDoTaglet
                -tagletpath /home/taglets 
                -tag return
                -tag param
                -tag todo
                -tag throws
                -tag see</screen>
</informalexample>
<para>Alternatively, you can use the <option>taglet</option> option in place
of its <option>tag</option> option, but that may be harder to read. </para>
</listitem></varlistentry>
<varlistentry><term><option>tagletpath</option>  <replaceable>tagletpathlist
</replaceable></term><listitem><para>Specifies the search paths for finding
taglet class files (.class). The <replaceable>tagletpathlist</replaceable>
can contain multiple paths by separating them with a colon (:). The Javadoc
tool will search in all subdirectories of the specified paths. </para>
</listitem></varlistentry>
<varlistentry><term><option>subpackages</option>  <replaceable>package1:package2:...
</replaceable> </term><listitem><para>Generates documentation from source
files in the specified packages and recursively in their subpackages. This
option is useful when adding new subpackages to the source code, as they are
            automatically included. Each package is any top-level package
(<literal>java</literal>) or fully qualified subpackage (<literal>javax.swing
</literal>), and does not need to contain source files. Wildcards are not
needed or allowed. Use <option>sourcepath</option> to specify where to find
the packages. For example: </para>
<informalexample>
<screen> % javadoc -sourcepath /home/user/src -subpackages java -exclude java.net:java.lang
</screen>
</informalexample>
<para>This command generates documentation for packages named "java" and "javax.swing"
and all their subpackages. </para>
<para>There is also an option to exclude subpackages as it traverses the subpackages. 
</para>
</listitem></varlistentry>
<varlistentry><term><option>exclude</option>  <replaceable>packagename1:packagename2:...
</replaceable> </term><listitem><para>Unconditionally excludes the specified
packages and their subpackages from the list formed by <option>subpackages
</option>. It excludes those packages even if they would otherwise be included
by some             previous or later -subpackages option. For example: </para>
<informalexample>
<screen>% javadoc -sourcepath /home/user/src -subpackages java -exclude java.net:java.lang

</screen>
</informalexample>
<para>would include<literal> java.io</literal>,<literal> java.util</literal>,
and<literal> java.math</literal> (among others), but would exclude packages
rooted at<literal> java.net</literal> and <literal>java.lang</literal>. Notice
this excludes<literal> java.lang.ref</literal>, a subpackage of <literal>
java.lang</literal>). </para>
</listitem></varlistentry>
<varlistentry><term><option>docfilessubdirs</option>  </term><listitem><para>
Enables deep copying of "doc-files" directories. In other words, subdirectories
and all contents are recursively copied to the             destination. For
example, the directory <literal>doc-files/example/images</literal> and all
its contents would now be copied. There is also an option to exclude subdirectories. 
</para>
</listitem></varlistentry>
<varlistentry><term><option>excludedocfilessubdir</option> <replaceable>name1:name2...
</replaceable> </term><listitem><para>Excludes any "doc-files" subdirectories
with the given names. This prevents the copying of SCCS and other source-code-control
subdirectories. </para>
</listitem></varlistentry>
<varlistentry><term><option>noqualifier</option>  <literal>all</literal> 
|  <replaceable>packagename1:packagename2:...</replaceable> </term><listitem>
<para>Omits qualifying package name from ahead of class names in output. The
argument to <option>noqualifier</option> is either "all" (all package qualifiers
are omitted) or a colon-separate list of packages, with wildcards, to be removed
as qualifiers. The package name is          removed from places where class
or interface names appear. </para>
<para>The following example omits all package qualifiers: </para>
<informalexample>
<screen>  -noqualifier all</screen>
</informalexample>
<para>The following example omits "java.lang" and "java.io" package qualifiers: 
</para>
<informalexample>
<screen>  -noqualifier java.lang:java.io</screen>
</informalexample>
<para>The following example omits package qualifiers starting with       
     "java", and "com.sun" subpackages (but not "javax"): </para>
<informalexample>
<screen>  -noqualifier java.*:com.sun.*</screen>
</informalexample>
<para>Where a package qualifier would appear due to the above behavior, the
following behavior (present in 1.3) also takes effect to further omit qualifiers:
On the page for class <literal>p.C</literal>, remove the package qualifier
for classes belonging to package <literal>p</literal>. This rule is present
whether or not <option>noqualifier</option> is used. </para>
</listitem></varlistentry>
<varlistentry><term><option>notimestamp</option></term><listitem><para>Suppresses
the timestamp, which is hidden in an HTML comment in the generated HTML near
the top of each page. Useful when you want to run javadoc on two source bases
and diff them, as it prevents timestamps from causing a diff (which would
otherwise be a diff on every page). The timestamp includes the javadoc version
number, and currently looks like this: </para>
<screen>&lt;!-- Generated by javadoc (build 1.5.0-internal) on Tue Jun 22 09:57:24 PDT 2004 --><?Pub Caret>
</screen>
</listitem></varlistentry>
<varlistentry><term><option>nocomment</option> </term><listitem><para> Suppress
the entire comment body, including the description and all tags, generating
only declarations. This option enables re-using source files originally intended
for a different purpose, to produce a skeleton perhaps for a new project. 
</para>
</listitem></varlistentry>
</variablelist></refsect2>
</refsect1>
<refsect1><title>COMMAND LINE ARGUMENT FILES</title>
<para>To shorten or simplify the <command>javadoc</command> command, you can
specify one or more files that themselves contain arguments to the <command>
javadoc</command> command (except <option>J</option> options). This enables
you to create javadoc commands of any length on any operating system.</para>
<para>An argument file can include Javadoc options, source filenames and package
names in any combination, or just arguments to Javadoc options. The arguments
within a file can be space-separated or newline-separated. Filenames within
an argument file are relative to the current directory, not the location of
the argument file. Wildcards (*) are not allowed in these lists (such as for
specifying *.java). Use of the '@' character to recursively interpret files
is not supported. The <option>J</option> options are not supported because
they are passed to the launcher, which does not support argument files. </para>
<para> When executing <command>javadoc</command>, pass in the path and name
of each argument file with the '<literal>@</literal>' leading character. When <command>
javadoc</command> encounters an argument beginning with the character '@',
it expands the contents of that file into the argument list.</para>
<example>
<title>Example - Single Arg File</title>
<para>You could use a single argument file named "argfile" to hold all Javadoc
arguments: </para>
<informalexample>
<screen> % javadoc @argfile

</screen>
</informalexample>
<para>This argument file could contain the contents of both files shown in
the next example. </para>
</example>
<example>
<title>Example - Two Arg Files</title>
<para>You can create two argument files -- one for the Javadoc options and
the other for the package names or source filenames: (Notice the following
lists have no line-continuation characters.) </para>
<para>Create a file named "options" containing: </para>
<informalexample>
<screen>  -d docs-filelist 
           -use 
           -splitindex
           -windowtitle 'Java 2 Platform v1.3 API Specification'
           -doctitle 'Java&lt;sup>&lt;font size="-2>TM&lt;/font>&lt;/sup> 2 Platform v1.4 API Specification'
           -header '&lt;b>Java 2 Platform &lt;/b>&lt;br>&lt;font size="-1">v1.4&lt;/font>'
           -bottom 'Copyright 1993-2000 Sun Microsystems, Inc. All Rights Reserved.'
           -group "Core Packages" "java.*"
           -overview /java/pubs/ws/1.3/src/share/classes/overview-core.html
           -sourcepath /java/pubs/ws/1.3/src/share/classes</screen>
</informalexample>
<para>Create a file named "packages" containing: </para>
<informalexample>
<screen> com.mypackage1
           com.mypackage2
           com.mypackage3</screen>
</informalexample>
<para>You would then run javadoc with: </para>
<informalexample>
<screen>  % javadoc @options @packages

</screen>
</informalexample>
</example>
<example>
<title>Example - Arg Files with Paths</title>
<para>The argument files can have paths, but any filenames inside the files
are relative to the current working directory (not path1 or path2): </para>
<informalexample>
<screen>  % javadoc @path1/options @path2/packages

</screen>
</informalexample>
</example>
<example>
<title>Example - Option Arguments</title>
<para>Here's an example of saving just an argument to a javadoc option in
an argument file. We'll use the <option>bottom</option> option, since it can
have a lengthy argument. You could create a file named "bottom" containing
its text argument: </para>
<informalexample>
<screen>'&lt;font size="-1">&lt;a href="http://java.sun.com/cgi-bin/bugreport.cgi">Submit a 
bug or feature&lt;/a>&lt;/br>&lt;/br>Java is a trademark or registered trademark of 
Microsystems, Inc. 901 San Antonio Road,&lt;br>Palo Alto, California, 94303, U.S.A. 
All Rights Reserved.&lt;/font>'</screen>
</informalexample>
<para>Then run the Javadoc tool with: </para>
<informalexample>
<screen>  % javadoc -bottom @bottom @packages

</screen>
</informalexample>
<para>Or you could include the <option>bottom</option> option at the start
of the argument file, and then just run it as: </para>
<informalexample>
<screen>% javadoc @bottom @packages</screen>
</informalexample>
</example>
</refsect1>
<refsect1><title>Running Javadoc</title>
<para><emphasis>Version Numbers</emphasis> - The version number of <command>
javadoc</command> can be determined using <command>javadoc</command><option>
 J-version</option>. The version number of the standard doclet appears in
its output stream. It can be turned off with <option>quiet</option>. </para>
<para><emphasis>Public programmatic interface</emphasis> - To invoke the Javadoc
tool from within programs written in the Java language. This interface is
in <literal>com.sun.tools.javadoc.Main</literal> (and javadoc is re-entrant).
For more details, see Standard Doclet. </para>
</refsect1>
<refsect1><title>Simple Examples</title>
<para>You can run <command>javadoc</command> on entire packages or individual
classes. Each package name has a corresponding directory name. In the following
examples, the source files are located at <literal>/home/src/java/awt/*java
</literal>. The destination directory is <literal>/home/html</literal>.</para>
<example role="example">
<title>Documenting One or More Packages</title>
<para>To document a package, the source files (*<literal>.java</literal>)
for that package must be located in a directory having the same name as the
package. If a package name is made up of several identifiers (separated by
dots such as <literal>java.awt.color</literal>), each subsequent identifier
must correspond to a deeper subdirectory (such as <literal>java/awt/color
</literal>) . You may split the source files for a single package among two
such directory trees located at different places, as long as <option>sourcepath
</option> points to them both -- for example <literal>src1/java/awt/color
</literal> and <literal>src2/java/awt/color</literal>. </para>
<para>You can run <command>javadoc</command> either by changing directories
(with cd) or by using <option>sourcepath</option> option. The examples below
illustrate both alternatives. </para>
<itemizedlist>
<listitem><para><emphasis>Case 1 - Run recursively starting from one or more
packages - </emphasis> This example uses <option>sourcepath</option> so javadoc
can be run from any directory. It traverses the subpackages of java excluding
            packages rooted at<literal> java.net</literal> and <literal>java.lang
</literal>. Notice this excludes <literal>java.lang.ref</literal>, a subpackage
of <literal>java.lang</literal>). <informalexample><para><screen>  % javadoc  -d /home/html -sourcepath /home/src -subpackages java -exclude java.net:java.lang

</screen></para>
</informalexample></para>
<para>To also traverse down other package trees, append their names to the <option>
subpackages</option> argument, such as<literal> java:javax:org.xml.sax</literal>. 
</para></listitem>
<listitem><para><emphasis>Case 2 - Run on explicit packages after changing
to the "root" source directory -</emphasis>Change to the parent directory
of the fully-qualified package. Then run <command>javadoc</command>, supplying
names of one or more packages you want to document:  <informalexample><para><screen>
% cd /home/src/
              % javadoc -d /home/html java.awt java.awt.event

</screen></para>
</informalexample></para></listitem>
<listitem><para><emphasis>Case 3 - Run from any directory on explicit packages
in a single directory tree -</emphasis> In this case, it doesn't matter what
the current directory is. Run <command>javadoc</command> supplying <option>
sourcepath</option> with the parent directory of the top-level package, and
supplying names of one or more packages you want to document: </para>
<informalexample>
<screen> % javadoc -d /home/html -sourcepath /home/src java.awt java.awt.event

</screen>
</informalexample>
</listitem>
<listitem><para><emphasis>Case 4 - Run from any directory on explicit packages
in multiple directory trees -</emphasis> This is the same as case 3, but for
packages in separate directory trees. Run <command>javadoc</command> supplying <option>
sourcepath</option> with the path to each tree's root (colon-separated) and
supply names of one or more packages you want to document. All source files
for a given package do not need to be located under  a single root directory
-- they just need to be found somewhere along the sourcepath. </para></listitem>
</itemizedlist>
<para>Result: All cases generate HTML-formatted documentation for the public
and protected classes and interfaces in packages <literal>java.awt</literal>
and <literal>java.awt.event</literal> and save the HTML files in the specified
destination directory (<literal>/home/html</literal>). Because two or more
packages are being generated, the document has three frames &mdash; for the
list of packages, the list of classes, and the main page.</para>
</example>
<example role="example">
<title>Documenting One or More Classes</title>
<para>The second way to run the Javadoc tool is by passing in one or more
source files (<literal>.java</literal>). You can run <command>javadoc</command>
either of the following two ways: by changing directories (with cd) or by
fully specifying the path to the <literal>.java</literal> files. Relative
paths are relative to the current directory. The <option>sourcepath</option>
option is ignored when passing in source files. You can use command line wildcards,
such as asterisk (*), to specify groups of classes.</para>
<itemizedlist>
<listitem><para><emphasis>Case 1 &mdash; Changing to the source directory:
</emphasis> Change to the directory holding the <literal>.java</literal> files.
Then run <command>javadoc</command>, supplying names of one or more source
files you want to document.<informalexample><para><screen>example% <userinput>
cd /home/src/java/awt</userinput>
example% <userinput>javadoc &ndash;d /home/html Button.java Canvas.java \
               Graphics*.java</userinput></screen></para>
</informalexample></para>
<para>This example generates HTML-formatted documentation for the classes <literal>
Button</literal>, <literal>Canvas</literal>, and classes beginning with <literal>
Graphics</literal>. Because source files rather than package names were passed
in as arguments to <command>javadoc</command>, the document has two frames &mdash;
for the list of classes and the main page.</para></listitem>
<listitem><para><emphasis>Case 2 - Changing to the package:</emphasis> <literal>
2</literal> This is useful for documenting individual source files from different
subpackages off the same root. Change to the package root directory, and supply
the source files with paths from the root.<informalexample><para><screen>
example% <userinput>cd /home/src/</userinput>
example% <userinput>javadoc &ndash;d /home/html java/awt/Button.java \
                 java/applet/Applet.java</userinput></screen></para>
</informalexample></para>
<para>This example generates HTML-formatted documentation for the classes <literal>
Button</literal> and <literal>Applet</literal>.</para></listitem>
<listitem><para><emphasis>Case 3 - From any directory:</emphasis> In this
case, it does not matter what the current directory is. Run <command>javadoc
</command>, supplying the absolute path (or path relative to the current directory)
to the <literal>.java</literal> files you want to document:<informalexample>
<para><screen>example% <userinput>javadoc &ndash;d /home/html /home/src/java/awt/Button.java \
               /home/src/java/awt/Graphics*.java</userinput></screen></para>
</informalexample></para>
<para>This example generates HTML-formatted documentation for the class <literal>
Button</literal> and classes beginning with <literal>Graphics</literal>.</para>
</listitem>
</itemizedlist>
</example>
<example role="example">
<title>Documenting Both Packages and Classes</title>
<para>You can document entire packages and individual classes at the same
time. Here is an example that mixes the two previous examples. You can use <option>
sourcepath</option> for the path to the packages but not for the path to the
individual classes:<informalexample><para><screen>example% <userinput>javadoc &ndash;d /home/html &ndash;sourcepath /home/src java.awt \
               /home/src/java/applet/Applet.java</userinput></screen></para>
</informalexample></para>
<para>This example generates HTML-formatted documentation for the package <literal>
java.awt</literal> and <literal>class Applet</literal> (<command>javadoc</command>
determines the package name for <literal>Applet</literal> from the package
declaration, if any, in the <literal>Applet.java</literal> source file.)</para>
</example>
<example role="example">
<title>Real World Example</title>
<para>The Javadoc tool has many useful options, some of which are more commonly
used than others. Here is effectively the command we use to run the Javadoc
tool on the Java platform <acronym>API</acronym>. We use 180MB of memory to
generate the documentation for the 1500 (approx.) public and protected classes
in the Java 2 Platform, Standard Edition, v1.2.</para>
<para>The same example is shown twice &mdash; first as executed on the <emphasis>
command line</emphasis>, then as executed from a <emphasis>makefile</emphasis>.
It uses absolute paths in the option arguments, which enables the same <command>
javadoc</command> command to be run from any directory.</para>
<para><emphasis>Command Line Example</emphasis></para>
<para>This command line example is over 900 characters, which is too long
for some shells, such as <acronym>DOS</acronym>. You can use a command line
argument file (or write a shell script) to workaround this limitation.</para>
<informalexample>
<screen>example% <userinput>javadoc &ndash;sourcepath /jdk/src/share/classes	         \
      -overview /java/jdk/src/share/classes/overview.html              \
      -d /java/jdk/build.api                                           \
      -use                                                             \
      -splitIndex                                                      \
      -windowtitle 'Java 2 Platform v1.2 API Specification'            \
      -doctitle 'Java&lt;sup>&lt;font size="-2">TM&lt;/font>&lt;/sup> 2\
                Platform v1.2 API Specification'                       \
      -header '&lt;b>Java 2 Platform &lt;/b>&lt;br>&lt;font size="-1">v1.2&lt;/font>' \
      -bottom '&lt;font size="-1">&lt;a href="http://java.sun.com/cgi-bin/   \
bugreport.cgi">Submit a bug or feature&lt;/a>&lt;br>&lt;br>Java is a trademark  \
or registered trademark of Sun Microsystems, Inc. in the US and other  \
countries.&lt;br>Copyright 1993-1999 Sun Microsystems, Inc. 901 San Antonio \
Road,&lt;br>Palo Alto, California, 94303, U.S.A. All Rights Reserved.&lt;/font>'                                     \
      -group "Core Packages" "java.*:com.sun.java.*:org.omg.*"         \
      -group "Extension Packages" "javax.*"                            \
      -J-Xmx180m                                                       \
      @packages</userinput></screen>
</informalexample>
<para>where <literal>packages</literal> is the name of a file containing the
packages to process, such as <literal>java.applet</literal> <literal>java.lang
</literal>. None of the options should contain any newline characters between
the single quotes. (For example, if you copy and paste this example, delete
the newline characters from the <option>bottom</option> option.) See the other
notes listed below.</para>
<para><emphasis>Makefile Example</emphasis></para>
<para>This is an example of a GNU makefile. For an example of a Windows makefile,
see <literal>Creating a Makefile for Windows</literal>.</para>
<informalexample>
<screen><userinput>javadoc &ndash;sourcepath $(SRCDIR)        /* Sets path for source files      */
  &ndash;overview $(SCRDIR)/overview.html  /* Sets file for overview text     */
  -d /jdk/build/api	     /* Sets destination directory      */
  &ndash;use	     /* Adds "Use" files                */
  &ndash;splitIndex	     /* Splits index A-Z                */
  &ndash;windowtitle $(WINDOWTITLE)	     /* Adds a window title             */
  &ndash;doctitle $(DOCTITLE)	     /* Adds a doc title                */
  &ndash;header $(HEADER)	     /* Adds running header text        */
  &ndash;bottom $(BOTTOM)	     /* Adds text at bottom             */
  &ndash;group $(GROUPCORE)	     /* First subhead on overview page  */
  &ndash;group $(GROUPEXT)	     /* Second subhead on overview page */
  &ndash;J&ndash;Xmx180m	     /* Sets memory to 180MB            */
  java.lang java.lang.reflect	     /* Sets packages to document       */
  java.util java.io java.net
  java.applet

WINDOWTITLE = 'Java 2 Platform v1.2 API Specification'
DOCTITLE = 'Java&lt;sup>&lt;font size="-2">TM&lt;/font>&lt;/sup> 2 Platform v1.2  \
                 API Specification'
HEADER = '&lt;b>Java 2 Platform&lt;/b>&lt;br>&lt;font size="-1">v1.2&lt;/font>'
BOTTOM = '&lt;font size="-1">&lt;a href="http://java.sun.com/cgi-bin/       \
              bugreport.cgi">Submit a bug or feature&lt;/a>&lt;br>&lt;br>Java  \
              is a trademark or registered trademark of Sun           \
              Microsystems, Inc. in the US and other countries.&lt;br>   \
              Copyright 1993-1999 Sun Microsystems, Inc. 901 San      \
              Antonio Road,&lt;br>Palo Alto, California, 94303, U.S.A.   \
              All Rights Reserved.&lt;/font>'
GROUPCORE = '"Core Packages" "java.*:com.sun.java.*:org.omg.*"'
GROUPEXT  = '"Extension Packages" "javax.*"'
SRCDIR = '/java/jdk/1.2/src/share/classes'</userinput>

</screen>
</informalexample>
<para>Single quotes are used to surround makefile arguments.</para>
<para><emphasis>Notes:</emphasis><itemizedlist>
<listitem><para>If you omit the <option>windowtitle</option> option, the Javadoc
tool copies the doc title to the window title. The <option>windowtitle</option>
text is basically the same as the <option>doctitle</option> but without HTML
tags, to prevent those tags from appearing as raw text in the window title. 
</para></listitem>
<listitem><para>If you omit the <option>footer</option> option, as done here,
the Javadoc tool copies the header text to the footer.</para></listitem>
<listitem><para>Other important options not needed in this example are <option>
classpath</option> and <option>link</option>.</para></listitem>
</itemizedlist></para>
</example>
</refsect1>
<refsect1><title>TROUBLESHOOTING</title>
<para><emphasis>General Troubleshooting</emphasis></para>
<itemizedlist>
<listitem><para>Javadoc FAQ - Commonly-encountered bugs and troubleshooting
 tips can be found on the <citetitle>Javadoc FAQ </citetitle></para></listitem>
<listitem><para>Bugs and Limitations - You can also see some bugs listed at <citetitle>
Important Bug Fixes and Changes</citetitle>. </para></listitem>
<listitem><para>Version number - See <literal>version numbers</literal>. 
</para></listitem>
<listitem><para>Documents only legal classes - When documenting a package, <command>
javadoc</command> only reads files whose names are composed of legal class
names. You can prevent <command>javadoc</command> from parsing a file by including,
 for example, a hyphen "-" in its filename. </para></listitem>
</itemizedlist>
<para><emphasis>Errors and Warnings</emphasis></para>
<para>Error and warning messages contain the filename and line number to the
declaration line rather than to the particular line in the doc comment. </para>
<itemizedlist>
<listitem><para>"<literal>error: cannot read: Class1.java</literal>" the Javadoc
tool is trying to load the class <literal>Class1.java</literal> in the current
directory. The class name is shown with its path (absolute or relative), which
in this case is the same as <literal>./Class1.java</literal>. </para></listitem>
</itemizedlist>
</refsect1>
<refsect1><title>&envr-tt;</title>
<variablelist termlength="medium">
<varlistentry><term remap="20"><envar>CLASSPATH</envar> </term><listitem>
<para>Environment variable that provides the path that <command>javadoc</command>
uses to find user class files. This environment variable is overridden by
the <option>classpath</option> option. Separate your directories with a colon,
as for example:<informalexample><para><screen>.:/home/classes:/usr/local/java/classes
</screen> </para>
</informalexample></para>
</listitem></varlistentry>
</variablelist></refsect1>
<refsect1><title>&also-tt;</title>
<para><citerefentry><refentrytitle>javac</refentrytitle><manvolnum>1</manvolnum>
</citerefentry>, <citerefentry><refentrytitle>java</refentrytitle><manvolnum>
1</manvolnum></citerefentry>, <citerefentry><refentrytitle>jdb</refentrytitle>
<manvolnum>1</manvolnum></citerefentry>, <citerefentry><refentrytitle>javah
</refentrytitle><manvolnum>1</manvolnum></citerefentry>, <citerefentry><refentrytitle>
javap</refentrytitle><manvolnum>1</manvolnum></citerefentry>, <citerefentry>
<refentrytitle>attributes</refentrytitle><manvolnum>5</manvolnum></citerefentry> 
</para>
<para>See (or search <literal>java.sun.com</literal>) for the following:</para>
<variablelist termlength="wholeline">
<varlistentry><term remap="10"><citetitle>The Javadoc Home Page</citetitle>
@</term><listitem><para><ulink url="http://java.sun.com/products/jdk/javadoc/index.html">
http://java.sun.com/products/jdk/javadoc/index.html</ulink></para>
</listitem></varlistentry>
<varlistentry><term remap="10"><citetitle>Javadoc Enhancements</citetitle>
@</term><listitem><para><ulink url="http://java.sun.com/j2se/1.4/docs/tooldocs/javadoc/index.html">
http://java.sun.com/j2se/1.4/docs/tooldocs/javadoc/index.html</ulink></para>
</listitem></varlistentry>
<varlistentry><term remap="10"><citetitle>Javadoc FAQ</citetitle> @</term>
<listitem><para><ulink url="http://java.sun.com/products/jdk/javadoc/faq.html">
http://java.sun.com/products/jdk/javadoc/faq.html</ulink></para>
</listitem></varlistentry>
<varlistentry><term remap="10"><citetitle>How to Write Doc Comments</citetitle>
@</term><listitem><para><ulink url="http://java.sun.com/products/jdk/javadoc/writingdoccomments.html">
http://java.sun.com/products/jdk/javadoc/writingdoccomments.html</ulink></para>
</listitem></varlistentry>
</variablelist></refsect1>
<!--+ 08/03/00 16:09:09
    | tagMorph:  $Id: tagMorph-engine 1.54 1998/01/19 05:44:48 $
    | tagMorph library:  $Id: libtagMorph.a 1.50 1998/01/19 22:02:51 $
    | sunman-to-solbook 1.17
    +-->
</refentry>
<?Pub *0000180248>
