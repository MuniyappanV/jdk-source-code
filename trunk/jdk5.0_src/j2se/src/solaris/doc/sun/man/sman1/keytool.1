<!DOCTYPE REFENTRY PUBLIC "-//Sun Microsystems//DTD DocBook V3.0-Based SolBook Subset V2.0//EN" [
<!--ArborText, Inc., 1988-1999, v.4002-->
<!ENTITY % javaents SYSTEM "javaman.ent">
%javaents;
]>
<REFENTRY ID="keytool-1">
<!--@(#)keytool.1 1.12 01/03/14 SMI;-->
<REFMETA><REFENTRYTITLE>keytool</REFENTRYTITLE><MANVOLNUM>1</MANVOLNUM>
<REFMISCINFO CLASS="date">22 Jun 2004</REFMISCINFO>
<REFMISCINFO CLASS="sectdesc">&man1;</REFMISCINFO>
<REFMISCINFO CLASS="software">&java-release;</REFMISCINFO>
<REFMISCINFO CLASS="arch">generic</REFMISCINFO>
<REFMISCINFO CLASS="copyright"> Copyright 2004 Sun Microsystems, Inc. All
rights reserved.  Copyright 2004 Sun Microsystems, Inc. Tous droits r&eacute;serv&eacute;s.
</REFMISCINFO>
</REFMETA>
<REFNAMEDIV><REFNAME>keytool</REFNAME><REFPURPOSE>key and certificate management
tool</REFPURPOSE></REFNAMEDIV>
<REFSYNOPSISDIV><TITLE>&synp-tt;</TITLE>
<CMDSYNOPSIS><COMMAND>keytool</COMMAND><ARG CHOICE="opt"><REPLACEABLE>subcommands
</REPLACEABLE></ARG>
</CMDSYNOPSIS></REFSYNOPSISDIV>
<REFSECT1><TITLE>&desc-tt;</TITLE>
<INDEXTERM ID="keytool-1-indx-1"><PRIMARY SORTAS="key and certificate management tool">
key and certificate management tool &mdash; keytool</PRIMARY></INDEXTERM>
<INDEXTERM ID="keytool-1-indx-2"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY></INDEXTERM><PARA><COMMAND>keytool
</COMMAND> is a key and certificate management utility. It enables users to
administer their own public/private key pairs and associated certificates
for use in self-authentication (where the user authenticates himself/herself
to other users/services) or data integrity and authentication services, using
digital signatures. It also allows users to cache the public keys (in the
form of certificates) of their communicating peers.</PARA>
<PARA>A certificate is a digitally signed statement from one entity (person,
company, and so forth), saying that the public key (and some other information)
of some other entity has a particular value. (See <LITERAL>Certificates</LITERAL>
below.) When data is digitally signed, the signature can be verified to check
the data integrity and authenticity. Integrity means that the data has not
been modified or tampered with, and authenticity means the data indeed comes
from whoever claims to have created and signed it.</PARA>
<PARA><COMMAND>keytool</COMMAND> stores the keys and certificates in a so-called
keystore. The <COMMAND>keytool</COMMAND> default keystore implementation implements
the keystore as a file. It protects private keys with a password.</PARA>
<PARA>The <CITEREFENTRY><REFENTRYTITLE>jarsigner</REFENTRYTITLE><MANVOLNUM>
1</MANVOLNUM></CITEREFENTRY> tool uses information from a keystore to generate
or verify digital signatures for Java ARchive (<ACRONYM>JAR</ACRONYM>) files.
(A <ACRONYM>JAR</ACRONYM> file packages class files, images, sounds, and/or
other digital data in a single file).  <CITEREFENTRY><REFENTRYTITLE>jarsigner
</REFENTRYTITLE><MANVOLNUM>1</MANVOLNUM></CITEREFENTRY> verifies the digital
signature of a <ACRONYM>JAR</ACRONYM> file, using the certificate that comes
with it (it is included in the signature block file of the <ACRONYM>JAR</ACRONYM>
file), and then checks whether or not the public key of that certificate is
"trusted", that is, is contained in the specified keystore.</PARA>
<PARA><EMPHASIS>Note:</EMPHASIS> The  <COMMAND>keytool</COMMAND> and  <CITEREFENTRY>
<REFENTRYTITLE>jarsigner</REFENTRYTITLE><MANVOLNUM>1</MANVOLNUM></CITEREFENTRY>
tools completely replace the <COMMAND>javakey</COMMAND> tool provided in JDK
1.1. These new tools provide more features than <COMMAND>javakey</COMMAND>,
including the ability to protect the keystore and private keys with passwords,
and the ability to verify signatures in addition to generating them. The new
keystore architecture replaces the identity database that javakey created
and managed. It is possible to import the information from an identity database
into a keystore, via the <OPTION>identitydb</OPTION> subcommand.</PARA>
<REFSECT2>
<TITLE>Keystore Entries</TITLE>
<INDEXTERM ID="keytool-1-indx-3"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Keystore Entries</SECONDARY>
</INDEXTERM><PARA>There are two different types of entries in a keystore:
</PARA>
<ORDEREDLIST>
<LISTITEM><PARA><LITERAL>key entries</LITERAL></PARA>
<PARA>Each holds very sensitive cryptographic key information, which is stored
in a protected format to prevent unauthorized access. Typically, a key stored
in this type of entry is a secret key, or a private key accompanied by the
certificate "chain" for the corresponding public key. The <COMMAND>keytool
</COMMAND> and  <CITEREFENTRY><REFENTRYTITLE>jarsigner</REFENTRYTITLE><MANVOLNUM>
1</MANVOLNUM></CITEREFENTRY> tools only handle the latter type of entry, that
is, private keys and their associated certificate chains.</PARA></LISTITEM>
<LISTITEM><PARA><LITERAL>trusted certificate entries</LITERAL></PARA>
<PARA>Each contains a single public key certificate belonging to another party.
It is called a "trusted certificate" because the keystore owner trusts that
the public key in the certificate indeed belongs to the identity identified
by the "subject" (owner) of the certificate. The issuer of the certificate
vouches for this, by signing the certificate.</PARA></LISTITEM>
</ORDEREDLIST>
</REFSECT2>
<REFSECT2>
<TITLE>Keystore Aliases</TITLE>
<INDEXTERM ID="keytool-1-indx-4"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Keystore Aliases</SECONDARY>
</INDEXTERM><PARA>All keystore entries (key and trusted certificate entries)
are accessed via unique aliases. Aliases are case-insensitive; the aliases
Hugo and hugo would refer to the same keystore entry.</PARA>
<PARA>An alias is specified when you add an entity to the keystore using the <OPTION>
genkey</OPTION> subcommand to generate a key pair (public and private key)
or the <OPTION>import</OPTION> subcommand to add a certificate or certificate
chain to the list of trusted certificates. Subsequent <COMMAND>keytool</COMMAND>
commands must use this same alias to refer to the entity.</PARA>
<PARA>For example, suppose you use the alias <LITERAL>duke</LITERAL> to generate
a new public/private key pair and wrap the public key into a self-signed certificate
(see <LITERAL>Certificate Chains</LITERAL> below) via the following command:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;genkey &ndash;alias duke &ndash;keypass dukekeypasswd
</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>This specifies an inital password of <LITERAL>dukekeypasswd</LITERAL>
required by subsequent commands to access the private key assocated with the
alias <LITERAL>duke</LITERAL>. If you later want to change <LITERAL>duke</LITERAL>'s
private key password, you use a command like the following:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;keypasswd &ndash;alias duke &ndash;keypass \
      dukekeypasswd &ndash;new newpass</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>This changes the password from "<LITERAL>dukekeypasswd"</LITERAL> to
"<LITERAL>newpass</LITERAL>".</PARA>
<PARA><EMPHASIS>Note:</EMPHASIS> A password should not actually be specified
on a command line or in a script unless it is for testing purposes, or you
are on a secure system. If you don't specify a required password option on
a command line, you will be prompted for it. When typing in a password at
the password prompt, the password is currently echoed (displayed exactly as
typed), so be careful not to type it in front of anyone.</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Keystore Location</TITLE>
<INDEXTERM ID="keytool-1-indx-5"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Keystore Location
</SECONDARY></INDEXTERM><PARA>Each <COMMAND>keytool</COMMAND> command has
a <OPTION>keystore</OPTION> option for specifying the name and location of
the persistent keystore file for the keystore managed by <COMMAND>keytool
</COMMAND>. The keystore is by default stored in a file named <FILENAME>.keystore
</FILENAME> in the user's home directory, as determined by the "user.home"
system property. On Solaris systems, "user.home" defaults to the user's home
directory.</PARA>
<PARA>Note that the input stream from the<OPTION> -keystore</OPTION> option
is passed to the  <LITERAL>KeyStore.load</LITERAL> method. If <LITERAL>NONE
</LITERAL> is specified as the URL, then a null stream is passed to the <LITERAL>
KeyStore.load</LITERAL> method. <LITERAL>NONE</LITERAL> should be specified
if the KeyStore is not file-based, for example, if it resides on a hardware
token device. </PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Keystore Creation</TITLE>
<INDEXTERM ID="keytool-1-indx-6"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Keystore Creation
</SECONDARY></INDEXTERM><PARA>A keystore is created whenever you use a <OPTION>
genkey</OPTION>, <OPTION>import</OPTION>, or <OPTION>identitydb</OPTION> subcommand
to add data to a keystore that doesn't yet exist.</PARA>
<PARA>More specifically, if you specify, in the <OPTION>keystore</OPTION>
option, a keystore that doesn't yet exist, that keystore will be created.
</PARA>
<PARA>If you don't specify a <OPTION>keystore</OPTION> option, the default
keystore is a file named <FILENAME>.keystore</FILENAME> in your home directory.
If that file does not yet exist, it will be created.</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Keystore Implementation</TITLE>
<INDEXTERM ID="keytool-1-indx-7"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Keystore Implementation
</SECONDARY></INDEXTERM><PARA>The <LITERAL>KeyStore</LITERAL> class provided
in the java.security package supplies well-defined interfaces to access and
modify the information in a keystore. It is possible for there to be multiple
different concrete implementations, where each implementation is that for
a particular type of keystore.</PARA>
<PARA>Currently, there are two command-line tools (<COMMAND>keytool</COMMAND>
and  <CITEREFENTRY><REFENTRYTITLE>jarsigner</REFENTRYTITLE><MANVOLNUM>1</MANVOLNUM>
</CITEREFENTRY>) and also a <ACRONYM>GUI</ACRONYM>-based tool named <LITERAL>
policytool</LITERAL>. Since <LITERAL>KeyStore</LITERAL> is publicly available,
JDK users can write additional security applications that use it.</PARA>
<PARA>There is a built-in default implementation, provided by Sun Microsystems.
It implements the keystore as a file, utilizing a proprietary keystore type
(format) named "JKS". It protects each private key with its individual password,
and also protects the integrity of the entire keystore with a (possibly different)
password.</PARA>
<PARA>Keystore implementations are provider-based. More specifically, the
application interfaces supplied by <LITERAL>KeyStore</LITERAL> are implemented
in terms of a "Service Provider Interface" (<ACRONYM>SPI</ACRONYM>). That
is, there is a corresponding abstract <LITERAL>KeystoreSpi</LITERAL> class,
also in the <LITERAL>java.security</LITERAL> package, which defines the Service
Provider Interface methods that "providers" must implement. (The term "provider"
refers to a package or a set of packages that supply a concrete implementation
of a subset of services that can be accessed by the Java Security <ACRONYM>
API</ACRONYM>.) Thus, to provide a keystore implementation, clients must implement
a "provider" and supply a <LITERAL>KeystoreSpi</LITERAL> subclass implementation,
as described in <CITETITLE>How to Implement a Provider for the Java Cryptography
Architecture</CITETITLE>.</PARA>
<PARA>Applications can choose different types of keystore implementations
from different providers, using the "getInstance" factory method supplied
in the <LITERAL>KeyStore</LITERAL> class. A keystore type defines the storage
and data format of the keystore information, and the algorithms used to protect
private keys in the keystore and the integrity of the keystore itself. Keystore
implementations of different types are not compatible.</PARA>
<PARA><COMMAND>keytool</COMMAND> works on any file-based keystore implementation.
(It treats the keytore location that is passed to it at the command line as
a filename and converts it to a <LITERAL>FileInputStream</LITERAL>, from which
it loads the keystore information.) The <CITEREFENTRY><REFENTRYTITLE>jarsigner
</REFENTRYTITLE><MANVOLNUM>1</MANVOLNUM></CITEREFENTRY> and policytool tools,
on the other hand, can read a keystore from any location that can be specified
using a <ACRONYM>URL</ACRONYM>.</PARA>
<PARA>For <COMMAND>keytool</COMMAND> and  <CITEREFENTRY><REFENTRYTITLE>jarsigner
</REFENTRYTITLE><MANVOLNUM>1</MANVOLNUM></CITEREFENTRY>, you can specify a
keystore type at the command line, via the <OPTION>storetype</OPTION> option.
For <LITERAL>Policy Tool</LITERAL>, you can specify a keystore type via the
"Change Keystore" command in the Edit menu.</PARA>
<PARA>If you don't explicitly specify a keystore type, the tools choose a
keystore implementation based simply on the value of the <LITERAL>keystore.type
</LITERAL> property specified in the security properties file. The security
properties file is called  <FILENAME>java.security</FILENAME>, and it resides
in the JDK security properties directory, <FILENAME>java.home/lib/security
</FILENAME>, where <FILENAME>java.home</FILENAME> is the JDK installation
directory.</PARA>
<PARA>Each tool gets the <LITERAL>keystore.type</LITERAL> value and then examines
all the currently-installed providers until it finds one that implements keystores
of that type. It then uses the keystore implementation from that provider.
</PARA>
<PARA>The <LITERAL>KeyStore</LITERAL> class defines a static method named <LITERAL>
getDefaultType</LITERAL> that lets applications and applets retrieve the value
of the <LITERAL>keystore.type</LITERAL> property. The following line of code
creates an instance of the default keystore type (as specified in the <LITERAL>
keystore.type</LITERAL> property):<INFORMALEXAMPLE>
<PROGRAMLISTING>KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
</PROGRAMLISTING>
</INFORMALEXAMPLE></PARA>
<PARA>The default keystore type is "jks" (the proprietary type of the keystore
implementation provided by Sun). This is specified by the following line in
the security properties file:<INFORMALEXAMPLE>
<PROGRAMLISTING>keystore.type=jks</PROGRAMLISTING>
</INFORMALEXAMPLE></PARA>
<PARA>To have the tools utilize a keystore implementation other than the default,
you can change that line to specify a different keystore type.</PARA>
<PARA>For example, if you have a provider package that supplies a keystore
implementation for a keystore type called <LITERAL>pkcs12</LITERAL>, change
the line to<INFORMALEXAMPLE>
<PROGRAMLISTING>keystore.type=pkcs12</PROGRAMLISTING>
</INFORMALEXAMPLE></PARA>
<PARA><EMPHASIS>Note:</EMPHASIS> Case doesn't matter in keystore type designations.
For example, "JKS" would be considered the same as "jks".</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Supported Algorithms and Key Sizes</TITLE>
<INDEXTERM ID="keytool-1-indx-8"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Supported Algorithms
and Key Sizes</SECONDARY></INDEXTERM><PARA><COMMAND>keytool</COMMAND> allows
users to specify any key pair generation and signature algorithm supplied
by any of the registered cryptographic service providers. That is, the <OPTION>
keyalg</OPTION> and <OPTION>sigalg</OPTION> options for various subcommands
must be supported by a provider implementation. The default key pair generation
algorithm is "DSA". The signature algorithm is derived from the algorithm
of the underlying private key: If the underlying private key is of type <LITERAL>
DSA</LITERAL>, the default signature algorithm is <LITERAL>SHA1withDSA</LITERAL>,
and if the underlying private key is of type <LITERAL>RSA</LITERAL>, the default
signature algorithm is <LITERAL>MD5withRSA</LITERAL>.</PARA>
<PARA>When generating a <LITERAL>DSA</LITERAL> key pair, the key size must
be in the range from 512 to 1024 bits, and must be a multiple of 64. The default
key size for any algorithm is 1024 bits.</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Certificates</TITLE>
<INDEXTERM ID="keytool-1-indx-9"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Certificates</SECONDARY>
</INDEXTERM><PARA>A certificate (also known as a public-key certificate) is
a digitally signed statement from one entity (the issuer), saying that the
public key (and some other information) of another entity (the subject) has
some</PARA>
<PARA>Let us expand on some of the key terms used in this sentence:</PARA>
<VARIABLELIST TERMLENGTH="medium">
<VARLISTENTRY><TERM REMAP="20"><LITERAL>Public Keys</LITERAL></TERM><LISTITEM>
<PARA>These are numbers associated with a particular entity, and are intended
to be known to everyone who needs to have trusted interactions with that entity.
Public keys are used to verify signatures.</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><LITERAL>Digitally Signed</LITERAL></TERM><LISTITEM><PARA>
If some data is digitally signed, it has been stored with the "identity" of
an entity, and a signature that proves that entity knows about the data. The
data is rendered unforgeable by signing with the entity's private key.</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><LITERAL>Identity</LITERAL></TERM><LISTITEM><PARA>A known
way of addressing an entity. In some systems the identity is the public key,
in others it can be anything from a Unix <ACRONYM>UID</ACRONYM> to an Email
address to an X.509 Distinguished Name.</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><LITERAL>Signature</LITERAL></TERM><LISTITEM><PARA>A signature
is computed over some data using the private key of an entity (the signer,
which in the case of a certificate is also known as the issuer).</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><LITERAL>Private Keys</LITERAL></TERM><LISTITEM><PARA>
These are numbers, each of which is supposed to be known only to the particular
entity whose private key it is (that is, it is supposed to be kept secret).
Private and public keys exist in pairs in all public key cryptography systems
(also referred to as "public key crypto systems"). In a typical public key
crypto system, such as <ACRONYM>DSA</ACRONYM>, a private key corresponds to
exactly one public key. Private keys are used to compute signatures.</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><LITERAL>Entity</LITERAL></TERM><LISTITEM><PARA>An entity
is a person, organization, program, computer, business, bank, or something
else you are trusting to some degree.</PARA>
</LISTITEM></VARLISTENTRY>
</VARIABLELIST><PARA>Basically, public key cryptography requires access to
users' public keys. In a large-scale networked environment it is impossible
to guarantee that prior relationships between communicating entities have
been established or that a trusted repository exists with all used public
keys. Certificates were invented as a solution to this public key distribution
problem. Now a Certification Authority (<ACRONYM>CA</ACRONYM>) can act as
a trusted third party. CAs are entities (for example, businesses) that are
trusted to sign (issue) certificates for other entities. It is assumed that <ACRONYM>
CA</ACRONYM>s will only create valid and reliable certificates, as they are
bound by legal agreements. There are many public Certification Authorities,
such as VeriSign, Thawte, Entrust, and so on. You can also run your own Certification
Authority using products such as the Netscape/Microsoft Certificate Servers
or the Entrust <ACRONYM>CA</ACRONYM> product for your organization.</PARA>
<PARA>Using <COMMAND>keytool</COMMAND>, it is possible to display, import,
and export certificates. It is also possible to generate self-signed certificates.
</PARA>
<PARA><COMMAND>keytool</COMMAND> currently handles X.509 certificates.</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>X.509 Certificates</TITLE>
<INDEXTERM ID="keytool-1-indx-10"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>X.509 Certificates
</SECONDARY></INDEXTERM><PARA>The X.509 standard defines what information
can go into a certificate, and describes how to write it down (the data format).
All X.509 certificates have the following data, in addition to the signature:
</PARA>
<VARIABLELIST TERMLENGTH="wholeline">
<VARLISTENTRY><TERM>Version</TERM><LISTITEM><PARA>This identifies which version
of the X.509 standard applies to this certificate, which affects what information
can be specified in it. Thus far, three versions are defined. <COMMAND>keytool
</COMMAND> can import and export v1, v2, and v3 certificates. It generates
v1 certificates.</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Serial Number</TERM><LISTITEM><PARA>The entity that created
the certificate is responsible for assigning it a serial number to distinguish
it from other certificates it issues. This information is used in numerous
ways. For example, when a certificate is revoked, its serial number is placed
in a Certificate Revocation List (<ACRONYM>CRL</ACRONYM>).</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Signature Algorithm Identifier</TERM><LISTITEM><PARA>
This identifies the algorithm used by the <ACRONYM>CA</ACRONYM> to sign the
certificate.</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Issuer Name</TERM><LISTITEM><PARA>The X.500 Distinguished
Name of the entity that signed the certificate. This is normally a <ACRONYM>
CA</ACRONYM>. Using this certificate implies trusting the entity that signed
this certificate. (Notice that in some cases, such as root or top-level <ACRONYM>
CA</ACRONYM> certificates, the issuer signs its own certificate.)</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Validity Period</TERM><LISTITEM><PARA>Each certificate
is valid only for a limited amount of time. This period is described by a
start date and time and an end date and time, and can be as short as a few
seconds or almost as long as a century. The validity period chosen depends
on a number of factors, such as the strength of the private key used to sign
the certificate or the amount one is willing to pay for a certificate. This
is the expected period that entities can rely on the public value, if the
associated private key has not been compromised.</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Subject Name</TERM><LISTITEM><PARA>The name of the entity
whose public key the certificate identifies. This name uses the X.500 standard,
so it is intended to be unique across the Internet. This is the X.500 Distinguished
Name (<ACRONYM>DN</ACRONYM>) of the entity, for example:<INFORMALEXAMPLE>
<PROGRAMLISTING>CN=Java Duke, OU=Java Software Division, O=Sun Microsystems Inc, C=US
</PROGRAMLISTING>
</INFORMALEXAMPLE>(These refer to the subject's Common Name, Organizational
Unit, Organization, and Country.)</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM>Subject Public Key Information</TERM><LISTITEM><PARA>
This is the public key of the entity being named, together with an algorithm
identifier which specifies which public key crypto system this key belongs
to and any associated key parameters.</PARA>
</LISTITEM></VARLISTENTRY>
</VARIABLELIST><PARA><REPLACEABLE>X.509 Version 1</REPLACEABLE> has been available
since 1988, is widely deployed, and is the most generic.</PARA>
<PARA><REPLACEABLE>X.509 Version 2</REPLACEABLE> introduced the concept of
subject and issuer unique identifiers to handle the possibility of reuse of
subject and/or issuer names over time. Most certificate profile documents
strongly recommend that names not be reused, and that certificates should
not make use of unique identifiers. Version 2 certificates are not widely
used.</PARA>
<PARA><REPLACEABLE>X.509 Version 3</REPLACEABLE> is the most recent (1996)
and supports the notion of extensions, whereby anyone can define an extension
and include it in the certificate. Some common extensions in use today are: <LITERAL>
KeyUsage</LITERAL> (limits the use of the keys to particular purposes such
as "signing-only") and <LITERAL>AlternativeNames</LITERAL> (allows other identities
to also be associated with this public key, for example, <ACRONYM>DNS</ACRONYM>
names, Email addresses, IP addresses). Extensions can be marked critical to
indicate that the extension should be checked and enforced/used. For example,
if a certificate has the <LITERAL>KeyUsage</LITERAL> extension marked critical
and set to "<LITERAL>keyCertSign</LITERAL>", then if this certificate is presented
during <ACRONYM>SSL</ACRONYM> communication, it should be rejected, as the
certificate extension indicates that the associated private key should only
be used for signing certificates and not for <ACRONYM>SSL</ACRONYM> use.</PARA>
<PARA>All the data in a certificate is encoded using two related standards
called ASN.1/DER. <CITETITLE>Abstract Syntax Notation 1</CITETITLE> describes
data. The <CITETITLE>Definite Encoding Rules</CITETITLE> describe a single
way to store and transfer that data.</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>X.500 Distinguished Names</TITLE>
<INDEXTERM ID="keytool-1-indx-11"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>X.500 Distinguished
Names</SECONDARY></INDEXTERM><PARA>X.500 Distinguished Names are used to identify
entities, such as those which are named by the subject and issuer (signer)
fields of X.509 certificates. <COMMAND>keytool</COMMAND> supports the following
subparts:<VARIABLELIST TERMLENGTH="medium">
<VARLISTENTRY><TERM><LITERAL>commonName</LITERAL></TERM><LISTITEM><PARA>Common
name of a person, for example, "Susan Jones".</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><LITERAL>organizationUnit</LITERAL></TERM><LISTITEM><PARA>
Small organization; for example, department or division name, such as "Purchasing".
</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><LITERAL>name</LITERAL></TERM><LISTITEM><PARA>For example,
"ABCSystems, Inc."</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><LITERAL>localityName</LITERAL></TERM><LISTITEM><PARA>
Locality (city) name; for example, "Palo Alto".</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><LITERAL>stateName</LITERAL></TERM><LISTITEM><PARA>State
or province name; for example, "California".</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><LITERAL>country</LITERAL></TERM><LISTITEM><PARA>Two-letter
country code; for example, "CH".</PARA>
</LISTITEM></VARLISTENTRY>
</VARIABLELIST></PARA>
<PARA>When supplying a distinguished name string as the value of a <OPTION>
dname</OPTION> option, as for the <OPTION>genkey</OPTION> or <OPTION>selfcert
</OPTION> subcommands, the string must be in the following format:<INFORMALEXAMPLE>
<SCREEN>CN=cName, OU=orgUnit, O=org, L=city, S=state, C=countryCode</SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>where all the italicized items represent actual values and the above
keywords are abbreviations for the following:<INFORMALEXAMPLE>
<SCREEN>CN=commonName
OU=organizationUnit
O=organizationName
L=localityName
S=stateName
C=country</SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>A sample distinguished name string is<INFORMALEXAMPLE>
<SCREEN>CN=Mark Smith, OU=Java, O=Sun, L=Cupertino, S=California, C=US</SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>and a sample command using such a string is<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;genkey &ndash;dname "CN=Mark Smith, OU=Java, 
O=Sun, L=Cupertino, S=California, C=US" &ndash;alias mark</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>Case does not matter for the keyword abbreviations. For example, <LITERAL>
CN</LITERAL>, <LITERAL>cn</LITERAL>, and <LITERAL>Cn</LITERAL>  are all treated
the same.</PARA>
<PARA>Order matters. Each subcomponent must appear in the designated order.
However, it is not necessary to have all the subcomponents. You may use a
subset. For example:<INFORMALEXAMPLE>
<SCREEN>CN=Steve Meier, OU=SunSoft, O=Sun, C=US</SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>If a distinguished name string value contains a comma, it must be escaped
by a "\" character when you specify the string on a command line, as in<INFORMALEXAMPLE>
<SCREEN>cn=peter schuster, o=Sun Microsystems\, Inc., o=sun, c=us</SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>It is never necessary to specify a distinguished name string on a command
line. If it is needed for a command, but not supplied on the command line,
the user is prompted for each of the subcomponents. In this case, a comma
does not need to be escaped by a "\"</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>The Internet RFC 1421 Certificate Encoding</TITLE>
<INDEXTERM ID="keytool-1-indx-12"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>The Internet RFC 1421
Certificate Encoding Standard</SECONDARY></INDEXTERM><PARA>Certificates are
often stored using the printable encoding format defined by the Internet RFC
1421 standard, instead of their binary encoding. This certificate format,
also known as "Base 64 encoding", facilitates exporting certificates to other
applications by email or through some other mechanism.</PARA>
<PARA>Certificates read by the <OPTION>import</OPTION> and <OPTION>printcert
</OPTION> subcommands can be in either this format or binary encoded.</PARA>
<PARA>The <OPTION>export</OPTION> subcommand by default outputs a certificate
in binary encoding, but will instead output a certificate in the printable
encoding format, if the <OPTION>rfc</OPTION> option is specified.</PARA>
<PARA>The <OPTION>list</OPTION> subcommand by default prints the MD5 fingerprint
of a certificate. If the <OPTION>v</OPTION> option is specified, the certificate
is printed in human-readable format, while if the <OPTION>rfc</OPTION> option
is specified, the certificate is output in the printable encoding format.
</PARA>
<PARA>In its printable encoding format, the encoded certificate is bounded
at the beginning by</PARA>
<PARA><SCREEN>-----BEGIN CERTIFICATE-----</SCREEN></PARA>
<PARA>and at the end by</PARA>
<PARA><SCREEN>-----END CERTIFICATE-----</SCREEN></PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Certificate Chains</TITLE>
<INDEXTERM ID="keytool-1-indx-13"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Certificate Chains
</SECONDARY></INDEXTERM><PARA><COMMAND>keytool</COMMAND> can create and manage
keystore "key" entries that each contain a private key and an associated certificate
"chain". The first certificate in the chain contains the public key corresponding
to the private key.</PARA>
<PARA>When keys are first generated (see the <OPTION>genkey</OPTION> subcommand),
the chain starts off containing a single element, a self-signed certificate.
A self-signed certificate is one for which the issuer (signer) is the same
as the subject (the entity whose public key is being authenticated by the
certificate). Whenever the <OPTION>genkey</OPTION> subcommand is called to
generate a new public/private key pair, it also wraps the public key into
a self-signed certificate.</PARA>
<PARA>Later, after a Certificate Signing Request (<ACRONYM>CSR</ACRONYM>)
has been generated (see the <OPTION>certreq</OPTION> subcommand) and sent
to a Certification Authority (<ACRONYM>CA</ACRONYM>), the response from the <ACRONYM>
CA</ACRONYM> is imported (see <OPTION>import</OPTION>), and the self-signed
certificate is replaced by a chain of certificates. At the bottom of the chain
is the certificate (reply) issued by the <ACRONYM>CA</ACRONYM> authenticating
the subject's public key. The next certificate in the chain is one that authenticates
the <ACRONYM>CA</ACRONYM>'s public key.</PARA>
<PARA>In many cases, this is a self-signed certificate (that is, a certificate
from the <ACRONYM>CA</ACRONYM> authenticating its own public key) and the
last certificate in the chain. In other cases, the <ACRONYM>CA</ACRONYM> may
return a chain of certificates. In this case, the bottom certificate in the
chain is the same (a certificate signed by the <ACRONYM>CA</ACRONYM>, authenticating
the public key of the key entry), but the second certificate in the chain
is a certificate signed by a different <ACRONYM>CA</ACRONYM>, authenticating
the public key of the <ACRONYM>CA</ACRONYM> to which you sent the <ACRONYM>
CSR</ACRONYM>. Then, the next certificate in the chain will be a certificate
authenticating the second <ACRONYM>CA</ACRONYM>'s key, and so on, until a
self-signed "root" certificate is reached. Each certificate in the chain (after
the first) thus authenticates the public key of the signer of the previous
certificate in the chain.</PARA>
<PARA>Many <ACRONYM>CA</ACRONYM>s only return the issued certificate, with
no supporting chain, especially when there is a flat hierarchy (no intermediates <ACRONYM>
CA</ACRONYM>s). In this case, the certificate chain must be established from
trusted certificate information already stored in the keystore.</PARA>
<PARA>A different reply format (defined by the PKCS#7 standard) also includes
the supporting certificate chain, in addition to the issued certificate. Both
reply formats can be handled by <COMMAND>keytool</COMMAND>. </PARA>
<PARA>The top-level (root) <ACRONYM>CA</ACRONYM> certificate is self-signed.
However, the trust into the root's public key does not come from the root
certificate itself (anybody could generate a self-signed certificate with
the distinguished name of say, the VeriSign root <ACRONYM>CA</ACRONYM>), but
from other sources like a newspaper. The root <ACRONYM>CA</ACRONYM> public
key is widely known. The only reason it is stored in a certificate is because
this is the format understood by most tools, so the certificate in this case
is only used as a "vehicle" to transport the root <ACRONYM>CA</ACRONYM>'s
public key. Before you add the root <ACRONYM>CA</ACRONYM> certificate to your
keystore, you should view it (using the <OPTION>printcert</OPTION> option)
and compare the displayed fingerprint with the well-known fingerprint (obtained
from a newspaper, the root <ACRONYM>CA</ACRONYM>'s webpage, and so forth).
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Importing Certificates</TITLE>
<INDEXTERM ID="keytool-1-indx-14"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Importing Certificates
</SECONDARY></INDEXTERM><PARA>To import a certificate from a file, use the <OPTION>
import</OPTION> subcommand, as in<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;import &ndash;alias joe &ndash;file jcertfile.cer
</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>This sample command imports the certificate(s) in the file <LITERAL>
jcertfile.cer</LITERAL> and stores it in the keystore entry identified by
the alias <LITERAL>joe</LITERAL>. </PARA>
<PARA>You import a certificate for two reasons:</PARA>
<ORDEREDLIST>
<LISTITEM><PARA>to add it to the list of trusted certificates, or</PARA></LISTITEM>
<LISTITEM><PARA>to import a certificate reply received from a <ACRONYM>CA
</ACRONYM> as the result of submitting a Certificate Signing Request (see
the <OPTION>certreq</OPTION> subcommand) to that <ACRONYM>CA</ACRONYM>.</PARA>
</LISTITEM>
</ORDEREDLIST>
<PARA>Which type of import is intended is indicated by the value of the <OPTION>
alias</OPTION> option. If the alias exists in the database, and identifies
an entry with a private key, then it is assumed you want to import a certificate
reply. <COMMAND>keytool</COMMAND> checks whether the public key in the certificate
reply matches the public key stored with the alias, and exits if they are
different. If the alias identifies the other type of keystore entry, the certificate
will not be imported. If the alias does not exist, then it will be created
and associated with the imported certificate.</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Warning Regarding Importing Trusted Certificates</TITLE>
<PARA>IMPORTANT: Be sure to check a certificate very carefully before importing
it as a trusted certificate.</PARA>
<ITEMIZEDLIST>
<LISTITEM><PARA>View it first (using the <OPTION>printcert</OPTION> subcommand,
or the <OPTION>import</OPTION> subcommand without the <OPTION>noprompt</OPTION>
option), and make sure that the displayed certificate fingerprint(s) match
the expected ones. For example, suppose someone sends or emails you a certificate,
and you put it in a file named <LITERAL>/tmp/cert</LITERAL>.<EMPHASIS>Before
</EMPHASIS> you consider adding the certificate to your list of trusted certificates,
you can execute a  <OPTION>printcert</OPTION> subcommand to view its fingerprints,
as in<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool -printcert -file /tmp/cert
Owner: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
Issuer: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
Serial Number: 59092b34
Valid from: Thu Sep 25 18:01:13 PDT 1997 until: Wed Dec 24 17:01:13 PST 1997
Certificate Fingerprints:
MD5:  11:81:AD:92:C8:E5:0E:A2:01:2E:D4:7A:D7:5F:07:6F
SHA1: 20:B6:17:FA:EF:E5:55:8A:D0:71:1F:E8:D6:9D:C0:37:13:0E:5E:FE</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA></LISTITEM>
<LISTITEM><PARA>Then call or otherwise contact the person who sent the certificate,
and compare the fingerprint(s) that you see with the ones that they show.
Only if the fingerprints are equal is it guaranteed that the certificate has
not been replaced in transit with somebody else's (for example, an attacker's)
certificate. If such an attack took place, and you did not check the certificate
before you imported it, you would end up trusting anything the attacker has
signed (for example, a <ACRONYM>JAR</ACRONYM> file with malicious class files
inside).</PARA>
<PARA><EMPHASIS>Note:</EMPHASIS> It is not required that you execute a <OPTION>
printcert</OPTION> subcommand prior to importing a certificate, since before
adding a certificate to the list of trusted certificates in the keystore,
the <OPTION>import</OPTION> subcommand prints out the certificate information
and prompts you to verify it. You then have the option of aborting the import
operation. Be aware, however, that this is only the case if you invoke the <OPTION>
import</OPTION> subcommand without the <OPTION>noprompt</OPTION> option. If
the <OPTION>noprompt</OPTION> option is given, there is no interaction with
the user.</PARA></LISTITEM>
</ITEMIZEDLIST>
</REFSECT2>
<REFSECT2>
<TITLE>Exporting Certificates</TITLE>
<INDEXTERM ID="keytool-1-indx-15"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Exporting Certificates
</SECONDARY></INDEXTERM><PARA>To export a certificate to a file, use the <OPTION>
export</OPTION> subcommand, as in<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;export &ndash;alias jane &ndash;file janecertfile.cer
</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>This sample command exports <LITERAL>jane</LITERAL>'s certificate to
the file <LITERAL>janecertfile.cer</LITERAL>. That is, if  <LITERAL>jane</LITERAL>
is the alias for a key entry, the command exports the certificate at the bottom
of the certificate chain in that keystore entry. This is the certificate that
authenticates jane's public key.</PARA>
<PARA>If, instead, <LITERAL>jane</LITERAL> is the alias for a trusted certificate
entry, then that trusted certificate is exported.</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Displaying Certificates</TITLE>
<INDEXTERM ID="keytool-1-indx-16"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Displaying Certificates
</SECONDARY></INDEXTERM><PARA>To print out the contents of a keystore entry,
use the <OPTION>list</OPTION> subcommand, as in<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;list &ndash;alias joe</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>If you don't specify an alias, as in<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;list</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>the contents of the entire keystore are printed.</PARA>
<PARA>To display the contents of a certificate stored in a file, use the <OPTION>
printcert</OPTION> subcommand, as in<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;printcert &ndash;file certfile.cer
</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>This displays information about the certificate stored in the file <LITERAL>
certfile.cer</LITERAL>.</PARA>
<PARA><EMPHASIS>Note:</EMPHASIS> This works independently of a keystore, that
is, you do not need a keystore in order to display a certificate that's stored
in a file.</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Generating a Self-signed Certificate</TITLE>
<INDEXTERM ID="keytool-1-indx-17"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Generating a Self-signed
Certificate</SECONDARY></INDEXTERM><PARA>A self-signed certificate is one
for which the issuer (signer) is the same as the subject (the entity whose
public key is being authenticated by the certificate). Whenever the <OPTION>
genkey</OPTION> subcommand is called to generate a new public/private key
pair, it also wraps the public key into a self-signed certificate.</PARA>
<PARA>You may occasionally wish to generate a new self-signed certificate.
For example, you may want to use the same key pair under a different identity
(distinguished name). For example, suppose you change departments. You can
then:</PARA>
<ORDEREDLIST>
<LISTITEM><PARA>Copy (clone) the original key entry. See <OPTION>keyclone
</OPTION>.</PARA></LISTITEM>
<LISTITEM><PARA>Generate a new self-signed certificate for the cloned entry,
using your new distinguished name. See below.</PARA></LISTITEM>
<LISTITEM><PARA>Generate a Certificate Signing Request for the cloned entry,
and import the reply certificate or certificate chain. See the <OPTION>certreq
</OPTION> and <OPTION>import</OPTION> subcommands.</PARA></LISTITEM>
<LISTITEM><PARA>Delete the original (now obsolete) entry. See <OPTION>delete
</OPTION>.</PARA></LISTITEM>
</ORDEREDLIST>
<PARA>To generate a self-signed certificate, use the <OPTION>selfcert</OPTION>
subcommand, as in<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;selfcert &ndash;alias dukeNew &ndash;keypass 92kqmp
-dname "cn=Duke Smith, ou=Purchasing, o=BlueSoft, c=US"</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>The generated certificate is stored as a single-element certificate
chain in the keystore entry identified by the specified alias (in this case <LITERAL>
dukeNew</LITERAL>) where it replaces the existing certificate chain.</PARA>
</REFSECT2>
</REFSECT1>
<REFSECT1><TITLE>&usge-tt;</TITLE>
<PARA>The various subcommands and their options are listed and described below.
</PARA>
<PARA><EMPHASIS>Note:</EMPHASIS></PARA>
<ITEMIZEDLIST>
<LISTITEM><PARA>All subcommand and option names are preceded by a minus sign
(-).</PARA></LISTITEM>
<LISTITEM><PARA>The options for each subcommand may be provided in any order.
</PARA></LISTITEM>
<LISTITEM><PARA>All items not italicized or in braces (<LITERAL>{ }</LITERAL>)
or square brackets (<LITERAL>[ ]</LITERAL>) are required to appear as is.
</PARA></LISTITEM>
<LISTITEM><PARA>Braces surrounding an option generally signify that a default
value will be used if the option is not specified on the command line. Braces
are also used around the <OPTION>v</OPTION>, <OPTION>rfc</OPTION>, and <OPTION>
J</OPTION> options, which only have meaning if they appear on the command
line (that is, they don't have any "default" values other than not existing).
</PARA></LISTITEM>
<LISTITEM><PARA>Brackets surrounding an option signify that the user is prompted
for the value(s) if the option is not specified on the command line. (For
a <OPTION>keypass</OPTION> option, if you do not specify the option on the
command line, <COMMAND>keytool</COMMAND> will first attempt to use the keystore
password to recover the private key, and if this fails, will then prompt you
for the private key password.)</PARA></LISTITEM>
<LISTITEM><PARA>Items in italics (option values) represent the actual values
that must be supplied. For example, here is the format of the <OPTION>printcert
</OPTION> subcommand:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;printcert [&ndash;file <REPLACEABLE>
cert_file</REPLACEABLE>] [&ndash;v]</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>When specifying a <OPTION>printcert</OPTION> subcommand, replace <REPLACEABLE>
cert_file</REPLACEABLE> with the actual file name, as in:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;printcert &ndash;file VScert.cer
</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA></LISTITEM>
<LISTITEM><PARA>Option values must be quoted if they contain a blank (space).
</PARA></LISTITEM>
<LISTITEM><PARA>The <OPTION>help</OPTION> subcommand is the default. Thus,
the command line<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool</USERINPUT></SCREEN>
</INFORMALEXAMPLE>is equivalent to<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;help</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA></LISTITEM>
</ITEMIZEDLIST>
<REFSECT2>
<TITLE>Option Defaults</TITLE>
<INDEXTERM ID="keytool-1-indx-18"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Option Defaults</SECONDARY>
</INDEXTERM><PARA>Below are the defaults for various option values.<VARIABLELIST TERMLENGTH="narrow">
<VARLISTENTRY><TERM><OPTION>alias</OPTION></TERM><LISTITEM><PARA>&ldquo;mykey&rdquo;
</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>keyalg</OPTION></TERM><LISTITEM><PARA>&ldquo;DSA&rdquo;
</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>keysize</OPTION></TERM><LISTITEM><PARA>1024</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>validity</OPTION></TERM><LISTITEM><PARA>90</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>keystore</OPTION></TERM><LISTITEM><PARA>The file
named .keystore in the user's home directory.</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>file</OPTION></TERM><LISTITEM><PARA>stdin if reading,
stdout if writing.</PARA>
</LISTITEM></VARLISTENTRY>
</VARIABLELIST></PARA>
<PARA>The signature algorithm (<OPTION>sigalg</OPTION> option) is derived
from the algorithm of the underlying private key. If the underlying private
key is of type "DSA", the <OPTION>sigalg</OPTION> private key is of type "RSA", <OPTION>
sigalg</OPTION> defaults to "MD5withRSA".</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Options that Appear for Most Subcommands</TITLE>
<INDEXTERM ID="keytool-1-indx-19"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Options that Appear
for Most Subcommands</SECONDARY></INDEXTERM><PARA>The <OPTION>v</OPTION> option
can appear for all subcommands except  <OPTION>help</OPTION>. If it appears,
it signifies "verbose" mode; detailed certificate information will be output.
</PARA>
<PARA>There is also a <OPTION>J</OPTION><REPLACEABLE>javaoption</REPLACEABLE>
option that may appear for any subcommand. If it appears, the specified &mdash;<REPLACEABLE>
javaoption</REPLACEABLE> string is passed through directly to the Java interpreter.
(<COMMAND>keytool</COMMAND> is actually a "wrapper" around the interpreter.)
This option should not contain any spaces. It is useful for adjusting the
execution environment or memory usage. For a list of possible interpreter
options, enter <COMMAND>java</COMMAND> <OPTION>h</OPTION> or <COMMAND>java
</COMMAND> <OPTION>X</OPTION> at the command line.</PARA>
<PARA>There are three options that may appear for all subcommands operating
on a keystore:</PARA>
<VARIABLELIST TERMLENGTH="wholeline">
<VARLISTENTRY><TERM><OPTION>storetype</OPTION> <REPLACEABLE>storetype</REPLACEABLE> 
</TERM><LISTITEM><PARA>This qualifier specifies the type of keystore to be
instantiated. The default keystore type is the one that is specified as the
value of the "keystore.type" property in the security properties file, which
is returned by the static <LITERAL>getDefaultType</LITERAL> method in  <LITERAL>
java.security.KeyStore</LITERAL>.</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>keystore</OPTION> <REPLACEABLE>keystore</REPLACEABLE> 
</TERM><LISTITEM><PARA>The keystore (database file) location. Defaults to
the file <LITERAL>.keystore</LITERAL> in the user's home directory, as determined
by the <LITERAL>user.home</LITERAL> system property. On Solaris systems, <LITERAL>
user.home</LITERAL> defaults to the user's home directory.</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>storepass</OPTION> <REPLACEABLE>storepass</REPLACEABLE> 
</TERM><LISTITEM><PARA>The password which is used to protect the integrity
of the keystore. <REPLACEABLE>storepass</REPLACEABLE> must be at least 6 characters
long. It must be provided to all subcommands that access the keystore contents.
For such subcommands, if a <OPTION>storepass</OPTION> option is not provided
at the command line, the user is prompted for it.</PARA>
</LISTITEM></VARLISTENTRY>
<VARLISTENTRY><TERM><OPTION>provider</OPTION> <REPLACEABLE>provider_class_name
</REPLACEABLE> </TERM><LISTITEM><PARA>Used to specify the name of the cryptographic
service provider's master class file when the service provider is not listed
in the security properties file.</PARA>
</LISTITEM></VARLISTENTRY>
</VARIABLELIST><PARA>When retrieving information from the keystore, the password
is optional. If no password is given, the integrity of the retrieved information
cannot be checked and a warning is displayed.</PARA>
<PARA>Be careful with passwords: See <LITERAL>Warning Regarding Passwords
</LITERAL> below.</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Warning Regarding Passwords</TITLE>
<INDEXTERM ID="keytool-1-indx-20"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Warning Regarding
Passwords</SECONDARY></INDEXTERM><PARA>Most subcommands operating on a keystore
require the store password. Some subcommands require a private key password.
</PARA>
<PARA>Passwords can be specified on the command line (in the <OPTION>storepass
</OPTION> and <OPTION>keypass</OPTION> options, respectively). However, a
password should not be specified on a command line or in a script unless it
is for testing purposes, or you are on a secure system.</PARA>
<PARA>If you don't specify a required password option on a command line, you
will be prompted for it. When typing in a password at the password prompt,
the password is currently echoed (displayed exactly as typed), so be careful
not to type it in front of anyone.</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>SUBCOMMANDS</TITLE>
<INDEXTERM ID="keytool-1-indx-21"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>SUBCOMMANDS</SECONDARY>
</INDEXTERM><PARA>See also &usge-tt;.</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Adding Data to the Keystore</TITLE>
<INDEXTERM ID="keytool-1-indx-22"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Adding Data to the
Keystore</SECONDARY></INDEXTERM>
<CMDSYNOPSIS><COMMAND><OPTION>genkey</OPTION></COMMAND><ARG CHOICE="req"><OPTION>
alias</OPTION> <REPLACEABLE>alias</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
keyalg</OPTION> <REPLACEABLE>keyalg</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
keysize</OPTION> <REPLACEABLE>keysize</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
sigalg</OPTION> <REPLACEABLE>sigalg</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
dname</OPTION> <REPLACEABLE>dname</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
keypass</OPTION> <REPLACEABLE>keypass</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
validity</OPTION> <REPLACEABLE>valDays</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
storetype</OPTION> <REPLACEABLE>storetype</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
keystore</OPTION> <REPLACEABLE>keystore</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
storepass</OPTION> <REPLACEABLE>storepass</REPLACEABLE></ARG><ARG><OPTION>
provider</OPTION> <REPLACEABLE>provider_class_name</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>v</OPTION></ARG><ARG CHOICE="req"><OPTION>J</OPTION><REPLACEABLE>
javaoption</REPLACEABLE></ARG>
</CMDSYNOPSIS><PARA>Generates a key pair (a public key and associated private
key). Wraps the public key into an X.509 v1 self-signed certificate, which
is stored as a single-element certificate chain. This certificate chain and
the private key are stored in a new keystore entry identified by <REPLACEABLE>
alias</REPLACEABLE>.</PARA>
<PARA><REPLACEABLE>keyalg</REPLACEABLE> specifies the algorithm to be used
to generate the key pair, and <REPLACEABLE>keysize</REPLACEABLE> specifies
the size of each key to be generated. <REPLACEABLE>sigalg</REPLACEABLE> specifies
the algorithm that should be used to sign the self-signed certificate. This
algorithm must be compatible with <REPLACEABLE>keyalg</REPLACEABLE>. See <LITERAL>
Supported Algorithms and Key Sizes</LITERAL>.</PARA>
<PARA><REPLACEABLE>dname</REPLACEABLE> specifies the X.500 Distinguished Name
to be associated with <REPLACEABLE>alias</REPLACEABLE> and is used as the
issuer and subject fields in the self-signed certificate. If no distinguished
name is provided at the command line, the user will be prompted for one.</PARA>
<PARA><REPLACEABLE>keypass</REPLACEABLE> is a password used to protect the
private key of the generated key pair. If no password is provided, the user
is prompted for it. If you press <KEYSYM>RETURN</KEYSYM> at the prompt, the
key password is set to the same password as that used for the keystore. <REPLACEABLE>
keypass</REPLACEABLE> must be at least 6 characters long. Be careful with
passwords. See <LITERAL>Warning Regarding Passwords</LITERAL>.</PARA>
<PARA><REPLACEABLE>valDays</REPLACEABLE> tells the number of days for which
the certificate should be considered valid.</PARA>
<CMDSYNOPSIS><COMMAND><OPTION>import</OPTION></COMMAND><ARG CHOICE="req"><OPTION>
alias</OPTION> <REPLACEABLE>alias</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
file</OPTION> <REPLACEABLE>cert_file</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
keypass</OPTION> <REPLACEABLE>keypass</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
noprompt</OPTION></ARG><ARG CHOICE="req"><OPTION>trustcacerts</OPTION></ARG>
<ARG CHOICE="req"><OPTION>storetype</OPTION> <REPLACEABLE>storetype</REPLACEABLE></ARG>
<ARG CHOICE="req"><OPTION>keystore</OPTION> <REPLACEABLE>keystore</REPLACEABLE></ARG>
<ARG CHOICE="opt"><OPTION>storepass</OPTION> <REPLACEABLE>storepass</REPLACEABLE></ARG>
<ARG><OPTION>provider</OPTION> <REPLACEABLE>provider_class_name</REPLACEABLE></ARG>
<ARG CHOICE="req"><OPTION>v</OPTION></ARG><ARG CHOICE="req"><OPTION>J</OPTION><REPLACEABLE>
javaoption</REPLACEABLE></ARG>
</CMDSYNOPSIS><PARA>Reads the certificate or certificate chain (where the
latter is supplied in a PKCS#7 formatted reply) from the file <REPLACEABLE>
cert_file</REPLACEABLE>, and stores it in the keystore entry identified by <REPLACEABLE>
alias</REPLACEABLE> given, the certificate or PKCS#7 reply is read from stdin. <COMMAND>
keytool</COMMAND> can import X.509 v1, v2, and v3 certificates, and PKCS#7
formatted certificate chains consisting of certificates of that type. The
data to be imported must be provided either in binary encoding format, or
in printable encoding format (also known as Base64 encoding) as defined by
the Internet RFC 1421 standard. In the latter case, the encoding must be bounded
at the beginning by a string that starts with "-----BEGIN", and bounded at
the end by a string that starts with "-----END".</PARA>
<PARA>You import a certificate for two reasons:

 <ITEMIZEDLIST><LISTITEM>To add it to the list of trusted certificates.</LISTITEM>
<LISTITEM>to import a certificate reply received from a CA as the result of submitting a Certificate Signing Request (see the -certreq command) to that CA. </LISTITEM></ITEMIZEDLIST></PARA>
<TITLE>Importing a New Trusted Certificate</TITLE>
<PARA>When importing a new trusted certificate, <REPLACEABLE>alias</REPLACEABLE>
must not yet exist in the keystore. Before adding the certificate to the keystore, <COMMAND>
keytool</COMMAND> tries to verify it by attempting to construct a chain of
trust from that certificate to a self-signed certificate (belonging to a root <ACRONYM>
CA</ACRONYM>), using trusted certificates that are already available in the
keystore.</PARA>


<PARA>If <COMMAND>keytool</COMMAND> fails to establish a trust path from the
certificate to be imported up to a self-signed certificate (either from the
keystore or the <LITERAL>cacerts</LITERAL> file), the certificate information
is printed out, and the user is prompted to verify it, for example, by comparing
the displayed certificate fingerprints with the fingerprints obtained from
some other (trusted) source of information, which might be the certificate
owner himself/herself. Be very careful to ensure the certificate is valid
prior to importing it as a "trusted" certificate. See <LITERAL>WARNING Regarding
Importing Trusted Certificates</LITERAL>. The user then has the option of
aborting the import operation. If the <OPTION>noprompt</OPTION> option is
given, however, there will be no interaction with the user.</PARA>
<PARA>When importing a certificate reply, the certificate reply is validated
using trusted certificates from the keystore, and optionally using the certificates
configured in the <LITERAL>cacerts</LITERAL> keystore file (if the <OPTION>
trustcacerts</OPTION> option was specified).</PARA>
<PARA>If the reply is a single X.509 certificate, <COMMAND>keytool</COMMAND>
attempts to establish a trust chain, starting at the certificate reply and
ending at a self-signed certificate (belonging to a root <ACRONYM>CA</ACRONYM>).
The certificate reply and the hierarchy of certificates used to authenticate
the certificate reply form the new certificate chain of <REPLACEABLE>alias
</REPLACEABLE>.</PARA>
<PARA>If the reply is a PKCS#7 formatted certificate chain, the chain is first
ordered (with the user certificate first and the self-signed root <ACRONYM>
CA</ACRONYM> certificate last), before  <COMMAND>keytool</COMMAND> attempts
to match the root <ACRONYM>CA</ACRONYM> certificate provided in the reply
with any of the trusted certificates in the keystore or the <LITERAL>cacerts
</LITERAL> keystore file (if the <OPTION>trustcacerts</OPTION> option was
specified). If no match can be found, the information of the root <ACRONYM>
CA</ACRONYM> certificate is printed out, and the user is prompted to verify
it, for example, by comparing the displayed certificate fingerprints with
the fingerprints obtained from some other (trusted) source of information,
which might be the root <ACRONYM>CA</ACRONYM> itself. The user then has the
option of aborting the import operation. If the <OPTION>noprompt</OPTION>
option is given, however, there will be no interaction with the user.</PARA>
<PARA>The new certificate chain of <REPLACEABLE>alias</REPLACEABLE> replaces
the old certificate chain associated with this entry. The old chain can only
be replaced if a valid keypass, the password used to protect the private key
of the entry, is supplied. If no password is provided, and the private key
password is different from the keystore password, the user is prompted for
it. Be careful with passwords: See <LITERAL>Warning Regarding Passwords</LITERAL>.
</PARA>

<TITLE>The cacerts Certificates File</TITLE>
<PARA>A certificates file named "cacerts" resides in the security properties directory, java.home/lib/security, where java.home is the runtime environment's directory (the jre directory in the SDK or the top-level directory of the Java 2 Runtime Environment).</PARA>
<PARA>The "cacerts" file represents a system-wide keystore with CA certificates. System administrators can configure and manage that file using keytool, specifying "jks" as the keystore type. The "cacerts" keystore file ships with several root CA certificates with the following aliases and X.500 owner distinguished names:</PARA><ITEMIZEDLIST>
<LISTITEM><PARA># Alias: thawtepersonalfreemailca</PARA><PARA>
Owner DN: EmailAddress=personal-freemail@thawte.com,
CN=Thawte Personal Freemail CA,
OU=Certification Services Division,
O=Thawte Consulting, L=Cape Town, ST=Western Cape, C=ZA</PARA>
</LISTITEM>
<LISTITEM><PARA># Alias: thawtepersonalbasicca</PARA><PARA>
Owner DN: EmailAddress=personal-basic@thawte.com,
CN=Thawte Personal Basic CA,
OU=Certification Services Division,
O=Thawte Consulting, L=Cape Town, ST=Western Cape, C=ZA
</PARA></LISTITEM>

<LISTITEM><PARA># Alias: thawtepersonalpremiumca</PARA><PARA>
Owner DN: EmailAddress=personal-premium@thawte.com,
CN=Thawte Personal Premium CA,
OU=Certification Services Division,
O=Thawte Consulting, L=Cape Town, ST=Western Cape, C=ZA
</PARA></LISTITEM>
<LISTITEM><PARA># Alias: thawteserverca</PARA>
<PARA>Owner DN: EmailAddress=server-certs@thawte.com,
CN=Thawte Server CA, OU=Certification Services Division,
O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA
</PARA></LISTITEM>
<LISTITEM><PARA># Alias: thawtepremiumserverca</PARA><PARA>
Owner DN: EmailAddress=premium-server@thawte.com,
CN=Thawte Premium Server CA,
OU=Certification Services Division,
O=Thawte Consulting cc, L=Cape Town, ST=Western Cape, C=ZA
</PARA></LISTITEM>
<LISTITEM><PARA># Alias: verisignclass1ca</PARA><PARA>
Owner DN: OU=Class 1 Public Primary Certification Authority,
O="VeriSign, Inc.", C=US
</PARA></LISTITEM>
<LISTITEM><PARA># Alias: verisignclass2ca</PARA><PARA>
Owner DN: OU=Class 2 Public Primary Certification Authority,
O="VeriSign, Inc.", C=US
</PARA></LISTITEM>
<LISTITEM><PARA># Alias: verisignclass3ca</PARA><PARA>
Owner DN: OU=Class 3 Public Primary Certification Authority,
O="VeriSign, Inc.", C=US
</PARA></LISTITEM>
<LISTITEM><PARA># Alias: verisignclass4ca
Owner DN: OU=Class 4 Public Primary Certification Authority,
O="VeriSign, Inc.", C=US
</PARA></LISTITEM>
<LISTITEM><PARA># Alias: verisignserverca</PARA><PARA>
Owner DN: OU=Secure Server Certification Authority,
O="RSA Data Security, Inc.", C=US
</PARA></LISTITEM>
<LISTITEM><PARA># Alias: baltimorecodesigningca</PARA><PARA>
Owner DN: CN=Baltimore CyberTrust Code Signing Root,
OU=CyberTrust, O=Baltimore, C=IE
</PARA></LISTITEM>
<LISTITEM><PARA># Alias: gtecybertrustglobalca</PARA><PARA>
Owner DN: CN=GTE CyberTrust Global Root,
OU="GTE CyberTrust Solutions, Inc.", O=GTE Corporation, C=US
</PARA></LISTITEM>
<LISTITEM><PARA># Alias: baltimorecybertrustca</PARA><PARA>
Owner DN: CN=Baltimore CyberTrust Root,
OU=CyberTrust, O=Baltimore, C=IE
</PARA></LISTITEM>
<LISTITEM><PARA># Alias: gtecybertrustca</PARA><PARA>
Owner DN: CN=GTE CyberTrust Root,
O=GTE Corporation, C=US
</PARA></LISTITEM>
<LISTITEM><PARA># Alias: gtecybertrust5ca</PARA><PARA>
Owner DN: CN=GTE CyberTrust Root 5,
OU="GTE CyberTrust Solutions, Inc.", O=GTE Corporation, C=US
</PARA></LISTITEM>
</ITEMIZEDLIST>
<PARA>The initial password of the "cacerts" keystore file is "changeit". System administrators should change that password and the default access permission of that file upon installing the SDK.</PARA>
<PARA>IMPORTANT: Verify Your cacerts File. Since you trust the CAs in the cacerts file as entities for signing and issuing certificates to other entities, you must manage the cacerts file carefully. The cacerts file should contain only certificates of the CAs you trust. It is your responsibility to verify the trusted root CA certificates bundled in the cacerts file and make your own trust decisions. To remove an untrusted CA certificate from the cacerts file, use the delete option of the keytool command. You can find the cacerts file in the JRE installation directory. Contact your system administrator if you do not have permission to edit this file. </PARA>
<CMDSYNOPSIS><COMMAND><OPTION>selfcert</OPTION></COMMAND><ARG CHOICE="req"><OPTION>
alias</OPTION> <REPLACEABLE>alias</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
sigalg</OPTION> <REPLACEABLE>sigalg</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
dname</OPTION> <REPLACEABLE>dname</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
validity</OPTION> <REPLACEABLE>valDays</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
keypass</OPTION> <REPLACEABLE>keypass</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
storetype</OPTION> <REPLACEABLE>storetype</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
keystore</OPTION> <REPLACEABLE>keystore</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
storepass</OPTION> <REPLACEABLE>storepass</REPLACEABLE></ARG><ARG><OPTION>
provider</OPTION> <REPLACEABLE>provider_class_name</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>v</OPTION></ARG><ARG CHOICE="req"><OPTION>J</OPTION><REPLACEABLE>
javaoption</REPLACEABLE></ARG>
</CMDSYNOPSIS><PARA>Generates an X.509 v1 self-signed certificate, using keystore
information including the private key and public key associated with <REPLACEABLE>
alias</REPLACEABLE>. If  <REPLACEABLE>dname</REPLACEABLE> is supplied at the
command line, it is used as the X.500 Distinguished Name for both the issuer
and subject of the certificate. Otherwise, the X.500 Distinguished Name associated
with <REPLACEABLE>alias</REPLACEABLE> (at the bottom of its existing certificate
chain) is used.</PARA>
<PARA>The generated certificate is stored as a single-element certificate
chain in the keystore entry identified by <REPLACEABLE>alias</REPLACEABLE>,
where it replaces the existing certificate chain.</PARA>
<PARA><REPLACEABLE>sigalg</REPLACEABLE> specifies the algorithm that should
be used to sign the certificate. See <LITERAL>Supported Algorithms and Key
Sizes</LITERAL>.</PARA>
<PARA>In order to access the private key, the appropriate password must be
provided, since private keys are protected in the keystore with a password.
If <REPLACEABLE>keypass</REPLACEABLE> is not provided at the command line,
and is different from the password used to protect the integrity of the keystore,
the user is prompted for it. Be careful with passwords: See <LITERAL>Warning
Regarding Passwords</LITERAL>. </PARA>
<PARA><REPLACEABLE>valDays</REPLACEABLE> tells the number of days for which
the certificate should be considered valid.</PARA>
<CMDSYNOPSIS><COMMAND><OPTION>identitydb</OPTION></COMMAND><ARG CHOICE="req"><OPTION>
file</OPTION> <REPLACEABLE>idb_file</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
storetype</OPTION> <REPLACEABLE>storetype</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
keystore</OPTION> <REPLACEABLE>keystore</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
storepass</OPTION> <REPLACEABLE>storepass</REPLACEABLE></ARG><ARG><OPTION>
provider</OPTION> <REPLACEABLE>provider_class_name</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>v</OPTION></ARG><ARG CHOICE="req"><OPTION>J</OPTION><REPLACEABLE>
javaoption</REPLACEABLE></ARG>
</CMDSYNOPSIS><PARA>Reads the JDK 1.1.x-style identity database from the file <REPLACEABLE>
idb_file</REPLACEABLE>, and adds its entries to the keystore. If no file is
given, the identity database is read from stdin. If a keystore does not exist,
it is created.</PARA>
<PARA>Only identity database entries ("identities") that were marked as trusted
will be imported in the keystore. All other identities will be ignored. For
each trusted identity, a keystore entry will be created. The identity's name
is used as the  <REPLACEABLE>alias</REPLACEABLE> for the keystore entry.</PARA>
<PARA>The private keys from trusted identities will all be encrypted under
the same password, <REPLACEABLE>storepass</REPLACEABLE>. This is the same
password that is used to protect the keystore's integrity. Users can later
assign individual passwords to those private keys by using the <OPTION>keypasswd
</OPTION> <COMMAND>keytool</COMMAND> command option.</PARA>
<PARA>An identity in an identity database may hold more than one certificate,
each certifying the same public key. But a keystore key entry for a private
key has that private key and a single "certificate chain" (initially just
a single certificate), where the first certificate in the chain contains the
public key corresponding to the private key. When importing the information
from an identity, only the first certificate of the identity is stored in
the keystore. This is because an identity's name in an identity database is
used as the <REPLACEABLE>alias</REPLACEABLE> for its corresponding keystore
entry, and <REPLACEABLE>alias</REPLACEABLE> names are unique within a keystore.
</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Exporting Data</TITLE>
<INDEXTERM ID="keytool-1-indx-23"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Exporting Data</SECONDARY>
</INDEXTERM>
<CMDSYNOPSIS><COMMAND><OPTION>certreq</OPTION></COMMAND><ARG CHOICE="req"><OPTION>
alias</OPTION> <REPLACEABLE>alias</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
sigalg</OPTION> <REPLACEABLE>sigalg</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
file</OPTION> <REPLACEABLE>certreq_file</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
keypass</OPTION> <REPLACEABLE>keypass</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
storetype</OPTION> <REPLACEABLE>storetype</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
keystore</OPTION> <REPLACEABLE>keystore</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
storepass</OPTION> <REPLACEABLE>storepass</REPLACEABLE></ARG><ARG><OPTION>
provider</OPTION> <REPLACEABLE>provider_class_name</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>v</OPTION></ARG><ARG CHOICE="req"><OPTION>J</OPTION><REPLACEABLE>
javaoption</REPLACEABLE></ARG>
</CMDSYNOPSIS><PARA>Generates a Certificate Signing Request (<ACRONYM>CSR
</ACRONYM>), using the PKCS#10 format.</PARA>
<PARA>A <ACRONYM>CSR</ACRONYM> is intended to be sent to a certificate authority
(<ACRONYM>CA</ACRONYM>). The <ACRONYM>CA</ACRONYM> will authenticate the certificate
requestor (usually off-line) and will return a certificate or certificate
chain, used to replace the existing certificate chain (which initially consists
of a self-signed certificate) in the keystore.</PARA>
<PARA>The private key and X.500 Distinguished Name associated with <REPLACEABLE>
alias</REPLACEABLE> are used to create the PKCS#10 certificate request. In
order to access the private key, the appropriate password must be provided,
since private keys are protected in the keystore with a password. If <REPLACEABLE>
keypass</REPLACEABLE> is not provided at the command line, and is different
from the password used to protect the integrity of the keystore, the user
is prompted for it.</PARA>
<PARA>Be careful with passwords: See <LITERAL>Warning Regarding Passwords
</LITERAL>.</PARA>
<PARA><REPLACEABLE>sigalg</REPLACEABLE> specifies the algorithm that should
be used to sign the <ACRONYM>CSR</ACRONYM>. See <LITERAL>Supported Algorithms
and Key Sizes</LITERAL>.</PARA>
<PARA>The <ACRONYM>CSR</ACRONYM> is stored in the file <REPLACEABLE>certreq_file
</REPLACEABLE>. If no file is given, the <ACRONYM>CSR</ACRONYM> is output
to stdout.</PARA>
<PARA>Use the import command to import the response from the <ACRONYM>CA</ACRONYM>.
</PARA>
<CMDSYNOPSIS><COMMAND><OPTION>export</OPTION></COMMAND><ARG CHOICE="req"><OPTION>
alias</OPTION> <REPLACEABLE>alias</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
file</OPTION> <REPLACEABLE>cert_file</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
storetype</OPTION> <REPLACEABLE>storetype</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
keystore</OPTION> <REPLACEABLE>keystore</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
storepass</OPTION> <REPLACEABLE>storepass</REPLACEABLE></ARG><ARG><OPTION>
provider</OPTION> <REPLACEABLE>provider_class_name</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>rfc</OPTION></ARG><ARG CHOICE="req"><OPTION>v</OPTION></ARG>
<ARG CHOICE="req"><OPTION>J</OPTION><REPLACEABLE>javaoption</REPLACEABLE></ARG>
</CMDSYNOPSIS><PARA>Reads (from the keystore) the certificate associated with <REPLACEABLE>
alias</REPLACEABLE>, and stores it in the file <REPLACEABLE>cert_file</REPLACEABLE>.
</PARA>
<PARA>If no file is given, the certificate is output to <LITERAL>stdout</LITERAL>.
</PARA>
<PARA>The certificate is by default output in binary encoding, but will instead
be output in the printable encoding format, as defined by the Internet RFC
1421 standard, if the <OPTION>rfc</OPTION> option is specified.</PARA>
<PARA>If <REPLACEABLE>alias</REPLACEABLE> refers to a trusted certificate,
that certificate is output. Otherwise, <REPLACEABLE>alias</REPLACEABLE> refers
to a key entry with an associated certificate chain. In that case, the first
certificate in the chain is returned. This certificate authenticates the public
key of the entity addressed by <REPLACEABLE>alias</REPLACEABLE>.</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Displaying Data</TITLE>
<INDEXTERM ID="keytool-1-indx-24"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Displaying Data</SECONDARY>
</INDEXTERM>
<CMDSYNOPSIS><COMMAND><OPTION>list</OPTION></COMMAND><ARG CHOICE="req"><OPTION>
storetype</OPTION> <REPLACEABLE>storetype</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
keystore</OPTION> <REPLACEABLE>keystore</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
storepass</OPTION> <REPLACEABLE>storepass</REPLACEABLE></ARG><ARG><OPTION>
provider</OPTION> <REPLACEABLE>provider_class_name</REPLACEABLE></ARG><GROUP CHOICE="req"><ARG CHOICE="plain"><OPTION>v</OPTION></ARG><ARG CHOICE="plain"><OPTION>
rfc</OPTION></ARG></GROUP><ARG CHOICE="req"><OPTION>J</OPTION><REPLACEABLE>
javaoption</REPLACEABLE></ARG>
</CMDSYNOPSIS><PARA>Prints (to stdout) the contents of the keystore entry
identified by <REPLACEABLE>alias</REPLACEABLE>. If no  <REPLACEABLE>alias
</REPLACEABLE> is specified, the contents of the entire keystore are printed.
</PARA>
<PARA>This subcommand by default prints the MD5 fingerprint of a certificate.
If the <OPTION>v</OPTION> option is specified, the certificate is printed
in human-readable format, with additional information such as the owner, issuer,
and serial number. If the <OPTION>rfc</OPTION> option is specified, certificate
contents are printed using the printable encoding format, as defined by the
Internet RFC 1421 standard</PARA>
<PARA>You cannot specify both the <OPTION>v</OPTION> and <OPTION>rfc</OPTION>
options.</PARA>
<CMDSYNOPSIS><COMMAND><OPTION>printcert</OPTION></COMMAND><ARG CHOICE="req"><OPTION>
file</OPTION> <REPLACEABLE>cert_file</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
v</OPTION></ARG><ARG CHOICE="req"><OPTION>J</OPTION><REPLACEABLE>javaoption
</REPLACEABLE></ARG>
</CMDSYNOPSIS><PARA>Reads the certificate from the file <REPLACEABLE>cert_file
</REPLACEABLE> and prints its contents in a human-readable format. If no file
is given, the certificate is read from stdin.</PARA>
<PARA>The certificate may be either binary encoded or in printable encoding
format, as defined by the Internet RFC 1421 standard.</PARA>
<PARA><EMPHASIS>Note:</EMPHASIS> This option can be used independently of
a keystore.</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Managing the Keystore</TITLE>
<INDEXTERM ID="keytool-1-indx-25"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Managing the Keystore
</SECONDARY></INDEXTERM>
<CMDSYNOPSIS><COMMAND><OPTION>keyclone</OPTION></COMMAND><ARG CHOICE="req"><OPTION>
alias</OPTION> <REPLACEABLE>alias</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
dest</OPTION> <REPLACEABLE>dest_alias</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
keypass</OPTION> <REPLACEABLE>keypass</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
new</OPTION> <REPLACEABLE>new_keypass</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
storetype</OPTION> <REPLACEABLE>storetype</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
keystore</OPTION> <REPLACEABLE>keystore</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
storepass</OPTION> <REPLACEABLE>storepass</REPLACEABLE></ARG><ARG><OPTION>
provider</OPTION> <REPLACEABLE>provider_class_name</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>v</OPTION></ARG><ARG CHOICE="req"><OPTION>J</OPTION><REPLACEABLE>
javaoption</REPLACEABLE></ARG>
</CMDSYNOPSIS><PARA>Creates a new keystore entry, which has the same private
key and certificate chain as the original entry.</PARA>
<PARA>The original entry is identified by <REPLACEABLE>alias</REPLACEABLE>
(which defaults to "<LITERAL>mykey</LITERAL>" if not provided). The new (destination)
entry is identified by  <REPLACEABLE>dest_alias</REPLACEABLE>. If no destination <REPLACEABLE>
alias</REPLACEABLE> is supplied at the command line, the user is prompted
for it.</PARA>
<PARA>If the private key password is different from the keystore password,
then the entry will only be cloned if a valid  <REPLACEABLE>keypass</REPLACEABLE>
is supplied. This is the password used to protect the private key associated
with <REPLACEABLE>alias</REPLACEABLE>. If no key password is supplied at the
command line, and the private key password is different from the keystore
password, the user is prompted for it. The private key in the cloned entry
may be protected with a different password, if desired. If no <OPTION>new
</OPTION> option is supplied at the command line, the user is prompted for
the new entry's password (and may choose to let it be the same as for the
cloned entry's private key).</PARA>
<PARA>Be careful with passwords: See <LITERAL>Warning Regarding Passwords
</LITERAL>.</PARA>
<PARA>This subcommand can be used to establish multiple certificate chains
corresponding to a given key pair, or for backup purposes.</PARA>
<CMDSYNOPSIS><COMMAND><OPTION>storepasswd</OPTION></COMMAND><ARG CHOICE="req"><OPTION>
new</OPTION> <REPLACEABLE>new_storepass</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
storetype</OPTION> <REPLACEABLE>storetype</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
keystore</OPTION> <REPLACEABLE>keystore</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
storepass</OPTION> <REPLACEABLE>storepass</REPLACEABLE></ARG><ARG><OPTION>
provider</OPTION> <REPLACEABLE>provider_class_name</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>v</OPTION></ARG><ARG CHOICE="req"><OPTION>J</OPTION><REPLACEABLE>
javaoption</REPLACEABLE></ARG>
</CMDSYNOPSIS><PARA>Changes the password used to protect the integrity of
the keystore contents. The new password is <REPLACEABLE>new_storepass</REPLACEABLE>,
which must be at least 6 characters long.</PARA>
<PARA>Be careful with passwords: See <LITERAL>Warning Regarding Passwords
</LITERAL>.</PARA>
<CMDSYNOPSIS><COMMAND><OPTION>keypasswd</OPTION></COMMAND><ARG CHOICE="req"><OPTION>
alias</OPTION> <REPLACEABLE>alias</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
keypass</OPTION> <REPLACEABLE>old_keypass</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
new</OPTION> <REPLACEABLE>new_keypass</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
storetype</OPTION> <REPLACEABLE>storetype</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
keystore</OPTION> <REPLACEABLE>keystore</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
storepass</OPTION> <REPLACEABLE>storepass</REPLACEABLE></ARG><ARG><OPTION>
provider</OPTION> <REPLACEABLE>provider_class_name</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>v</OPTION></ARG><ARG CHOICE="req"><OPTION>J</OPTION><REPLACEABLE>
javaoption</REPLACEABLE></ARG>
</CMDSYNOPSIS><PARA>Changes the password under which the private key identified
by <REPLACEABLE>alias</REPLACEABLE> is protected, from <REPLACEABLE>old_keypass
</REPLACEABLE> to <REPLACEABLE>new_keypass</REPLACEABLE>.</PARA>
<PARA>If the <COMMAND>keypass</COMMAND> option is not provided at the command
line, and the private key password is different from the keystore password,
the user is prompted for it.</PARA>
<PARA>If the <OPTION>new</OPTION> option is not provided at the command line,
the user is prompted for it.</PARA>
<PARA>Be careful with passwords: See <LITERAL> Warning Regarding Passwords
</LITERAL>.</PARA>
<CMDSYNOPSIS><COMMAND><OPTION>delete</OPTION></COMMAND><ARG CHOICE="opt"><OPTION>
alias</OPTION> <REPLACEABLE>alias</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
storetype</OPTION> <REPLACEABLE>storetype</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>
keystore</OPTION> <REPLACEABLE>keystore</REPLACEABLE></ARG><ARG CHOICE="opt"><OPTION>
storepass</OPTION> <REPLACEABLE>storepass</REPLACEABLE></ARG><ARG><OPTION>
provider</OPTION> <REPLACEABLE>provider_class_name</REPLACEABLE></ARG><ARG CHOICE="req"><OPTION>v</OPTION></ARG><ARG CHOICE="req"><OPTION>J</OPTION><REPLACEABLE>
javaoption</REPLACEABLE></ARG>
</CMDSYNOPSIS><PARA>Deletes from the keystore the entry identified by <REPLACEABLE>
alias</REPLACEABLE>. The user is prompted for the  <REPLACEABLE>alias</REPLACEABLE>,
if no <REPLACEABLE>alias</REPLACEABLE> is provided at the command line.</PARA>
</REFSECT2>
<REFSECT2>
<TITLE>Getting Help</TITLE>
<INDEXTERM ID="keytool-1-indx-26"><PRIMARY SORTAS="keytool">keytool &mdash;
key and certificate management tool</PRIMARY><SECONDARY>Getting Help</SECONDARY>
</INDEXTERM>
<CMDSYNOPSIS><COMMAND><OPTION>help</OPTION></COMMAND>
</CMDSYNOPSIS></REFSECT2>
</REFSECT1>
<REFSECT1><TITLE>&exam-tt;</TITLE>
<PARA>Suppose you want to create a keystore for managing your public/private
key pair and certificates from entities you trust.</PARA>
<EXAMPLE ROLE="example">
<TITLE>Generating Your Key Pair</TITLE>
<PARA>Suppose you want to create a keystore for managing your public/private
key pair and certificates from entities you trust.</PARA>
<PARA>The first thing you need to do is create a keystore and generate the
key pair. You could use a command such as the following:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;genkey &ndash;dname "cn=Mark Jones, ou=Java, o=Sun, c=US"
&ndash;alias business &ndash;keypass kpi135 &ndash;keystore /working/mykeystore
&ndash;storepass ab987c &ndash;validity 180</USERINPUT></SCREEN>
</INFORMALEXAMPLE>(<EMPHASIS>Please note:</EMPHASIS> This must be typed as
a single line. Multiple lines are used in the examples just for legibility
purposes.)</PARA>
<PARA>This command creates the keystore named <LITERAL>mykeystore</LITERAL>
in the `<LITERAL>working</LITERAL> directory (assuming it does not already
exist), and assigns it the password <LITERAL>ab987c</LITERAL>. It generates
a public/private key pair for the entity whose "distinguished name" has a
common name of <LITERAL>Mark Jones</LITERAL>, organizational unit of <LITERAL>
Java</LITERAL>, organization of `<LITERAL>Sun</LITERAL>, and two-letter country
code of <LITERAL>US</LITERAL>. It uses the default "DSA" key generation algorithm
to create the keys, both 1024 bits long.</PARA>
<PARA>It creates a self-signed certificate (using the default "SHA1withDSA"
signature algorithm) that includes the public key and the distinguished name
information. This certificate will be valid for <LITERAL>180</LITERAL> days,
and is associated with the private key in a keystore entry referred to by
the alias <LITERAL>business</LITERAL>. The private key is assigned the password
 <LITERAL>kpi135</LITERAL>.</PARA>
<PARA>The command could be significantly shorter if option defaults were accepted.
As a matter of fact, no options are required. Defaults are used for unspecified
options that have default values, and you are prompted for any required values.
Thus, you could simply have the following:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;genkey</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>In this case, a keystore entry with alias <LITERAL>mykey</LITERAL> is
created, with a newly-generated key pair and a certificate that is valid for
90 days. This entry is placed in the keystore named <LITERAL>.keystore</LITERAL>
in your home directory. (The keystore is created if it doesn't already exist.)
You will be prompted for the distinguished name information, the keystore
password, and the private key password.</PARA>
<PARA>The rest of the examples assume you executed the <OPTION>genkey</OPTION>
command without options specified, and that you responded to the prompts with
values equal to those given in the first <OPTION>genkey</OPTION> command,
above (a private key password of <LITERAL>kpi135</LITERAL>, and so forth.)
</PARA>
</EXAMPLE>
<EXAMPLE ROLE="example">
<TITLE>Requesting a Signed Certificate from a Certificate Authority</TITLE>
<PARA>So far all we've got is a self-signed certificate. A certificate is
more likely to be trusted by others if it is signed by a Certification Authority
(<ACRONYM>CA</ACRONYM>). To get such a signature, you first generate a Certificate
Signing Request (<ACRONYM>CSR</ACRONYM>), via the following:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;certreq &ndash;file MarkJ.csr</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>This creates a <ACRONYM>CSR</ACRONYM> (for the entity identified by
the default alias <LITERAL>mykey</LITERAL> and puts the request in the file
named <LITERAL>MarkJ.csr</LITERAL>. Submit this file to a <ACRONYM>CA</ACRONYM>,
such as VeriSign, Inc. The <ACRONYM>CA</ACRONYM> will authenticate you, the
requestor (usually off-line), and then will return a certificate, signed by
them, authenticating your public key. (In some cases, they will actually return
a chain of certificates, each one authenticating the public key of the signer
of the previous certificate in the chain.)</PARA>
</EXAMPLE>
<EXAMPLE ROLE="example">
<TITLE>Importing a Certificate for the CA</TITLE>
<PARA>You need to replace your self-signed certificate with a certificate
chain, where each certificate in the chain authenticates the public key of
the signer of the previous certificate in the chain, up to a "root" <ACRONYM>
CA</ACRONYM>.</PARA>
<PARA>Before you import the certificate reply from a <ACRONYM>CA</ACRONYM>,
you need one or more "trusted certificates" in your keystore or in the <LITERAL>
cacerts</LITERAL> keystore file (which is described in the <OPTION>import
</OPTION> command):</PARA>
<ITEMIZEDLIST>
<LISTITEM><PARA>If the certificate reply is a certificate chain, you just
need the top certificate of the chain (that is, the "root" <ACRONYM>CA</ACRONYM>
certificate authenticating that <ACRONYM>CA</ACRONYM>'s public key).</PARA>
</LISTITEM>
<LISTITEM><PARA>If the certificate reply is a single certificate, you need
a certificate for the issuing <ACRONYM>CA</ACRONYM> (the one that signed it),
and if that certificate is not self-signed, you need a certificate for its
signer, and so on, up to a self-signed "root" <ACRONYM>CA</ACRONYM> certificate.
</PARA></LISTITEM>
</ITEMIZEDLIST>
<PARA>The <LITERAL>cacerts</LITERAL> keystore file ships with five VeriSign
root <ACRONYM>CA</ACRONYM> certificates, so you probably won't need to import
a VeriSign certificate as a trusted certificate in your keystore. But if you
request a signed certificate from a different <ACRONYM>CA</ACRONYM>, and a
certificate authenticating that <ACRONYM>CA</ACRONYM>'s public key hasn't
been added to <LITERAL>cacerts</LITERAL>, you will need to import a certificate
from the <ACRONYM>CA</ACRONYM> as a "trusted certificate".</PARA>
<PARA>A certificate from a <ACRONYM>CA</ACRONYM> is usually either self-signed,
or signed by another <ACRONYM>CA</ACRONYM> (in which case you also need a
certificate authenticating that <ACRONYM>CA</ACRONYM>'s public key). Suppose
company ABC, Inc., is a <ACRONYM>CA</ACRONYM>, and you obtain a file named <LITERAL>
ABCCA.cer</LITERAL> that is purportedly a self-signed certificate from ABC,
authenticating that CA's public key.</PARA>
<PARA>Be very careful to ensure the certificate is valid prior to importing
it as a "trusted" certificate. View it first (using the  <OPTION>printcert
</OPTION> subcommand, or the <OPTION>import</OPTION> subcommand without the <OPTION>
noprompt</OPTION> option), and make sure that the displayed certificate fingerprint(s)
match the expected ones. You can call the person who sent the certificate,
and compare the fingerprint(s) that you see with the ones that they show (or
that a secure public key repository shows). Only if the fingerprints are equal
is it guaranteed that the certificate has not been replaced in transit with
somebody else's (for example, an attacker's) certificate. If such an attack
took place, and you did not check the certificate before you imported it,
you would end up trusting anything the attacker has signed.</PARA>
<PARA>If you trust that the certificate is valid, then you can add it to your
keystore via the following:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;import &ndash;alias abc &ndash;file ABCCA.cer
</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>This creates a "trusted certificate" entry in the keystore, with the
data from the file <LITERAL>ABCCA.cer</LITERAL>, and assigns the alias <LITERAL>
abc</LITERAL> to the entry.</PARA>
</EXAMPLE>
<EXAMPLE ROLE="example">
<TITLE>Importing the Certificate Reply from the CA</TITLE>
<PARA>Once you've imported a certificate authenticating the public key of
the <ACRONYM>CA</ACRONYM> you submitted your certificate signing request to
(or there's already such a certificate in the <LITERAL>cacerts</LITERAL> file),
you can import the certificate reply and thereby replace your self-signed
certificate with a certificate chain. This chain is the one returned by the <ACRONYM>
CA</ACRONYM> in response to your request (if the <ACRONYM>CA</ACRONYM> reply
is a chain), or one constructed (if the <ACRONYM>CA</ACRONYM> reply is a single
certificate) using the certificate reply and trusted certificates that are
already available in the keystore where you import the reply or in the  <LITERAL>
cacerts</LITERAL> keystore file.</PARA>
<PARA>For example, suppose you sent your certificate signing request to VeriSign.
You can then import the reply via the following, which assumes the returned
certificate is named  <LITERAL>VSMarkJ.cer</LITERAL>:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;import &ndash;trustcacerts &ndash;file VSMarkJ.cer
</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
</EXAMPLE>
<EXAMPLE ROLE="example">
<TITLE>Exporting a Certificate Authenticating Your Public Key</TITLE>
<PARA>Suppose you have used the <CITEREFENTRY><REFENTRYTITLE>jarsigner</REFENTRYTITLE>
<MANVOLNUM>1</MANVOLNUM></CITEREFENTRY> tool to sign a Java ARchive (<ACRONYM>
JAR</ACRONYM>) file. Clients that want to use the file will want to authenticate
your signature.</PARA>
<PARA>One way they can do this is by first importing your public key certificate
into their keystore as a "trusted" entry. You can export the certificate and
supply it to your clients. As an example, you can copy your certificate to
a file named <LITERAL>MJ.cer</LITERAL> via the following, assuming the entry
is aliased by  <LITERAL>mykey</LITERAL>:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;export &ndash;alias mykey &ndash;file MJ.cer
</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>Given that certificate, and the signed <ACRONYM>JAR</ACRONYM> file,
a client can use the <CITEREFENTRY><REFENTRYTITLE>jarsigner</REFENTRYTITLE>
<MANVOLNUM>1</MANVOLNUM></CITEREFENTRY> tool to authenticate your signature.
</PARA>
</EXAMPLE>
<EXAMPLE ROLE="example">
<TITLE>Changing Your Distinguished Name but Keeping your Key Pair</TITLE>
<PARA>Suppose your distinguished name changes, for example because you have
changed departments or moved to a different city. If desired, you may still
use the public/private key pair you've previously used, and yet update your
distinguished name. For example, suppose your name is Susan Miller, and you
created your initial key entry with the alias <LITERAL>sMiller</LITERAL> and
the distinguished name<INFORMALEXAMPLE>
<SCREEN>"cn=Susan Miller, ou=Finance Department, o=BlueSoft, c=us"</SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>Suppose you change from the Finance Department to the Accounting Department.
You can still use the previously-generated public/private key pair and yet
update your distinguished name by doing the following. First, copy (clone)
your key entry:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;keyclone &ndash;alias sMiller &ndash;dest sMillerNew
</USERINPUT></SCREEN>
</INFORMALEXAMPLE>(This prompts for the store password and for the initial
and destination private key passwords, since they aren't provided at the command
line.) Now you need to change the certificate chain associated with the copy,
so that the first certificate in the chain uses your different distinguished
name. Start by generating a self-signed certificate with the appropriate name:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;selfcert &ndash;alias sMillerNew
&ndash;dname "cn=Susan Miller, ou=Accounting Department, o=BlueSoft, c=us"
</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>Then generate a Certificate Signing Request based on the information
in this new certificate:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;certreq &ndash;alias sMillerNew
</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>When you get the <ACRONYM>CA</ACRONYM> certificate reply, import it:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;import &ndash;alias sMillerNew &ndash;file VSSMillerNew.cer
</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA>After importing the certificate reply, you may want to remove the initial
key entry that used your old distinguished name:<INFORMALEXAMPLE>
<SCREEN>example% <USERINPUT>keytool &ndash;delete &ndash;alias sMiller</USERINPUT></SCREEN>
</INFORMALEXAMPLE></PARA>
<PARA></PARA>
</EXAMPLE>
</REFSECT1>
<REFSECT1><TITLE>&attr-tt;</TITLE>
<PARA>See <CITEREFENTRY><REFENTRYTITLE>attributes</REFENTRYTITLE><MANVOLNUM>
5</MANVOLNUM></CITEREFENTRY> for a description of the following attributes:
</PARA>
<INFORMALTABLE FRAME="all" ORIENT="port">
<TGROUP COLS="2" COLSEP="1" ROWSEP="1"><COLSPEC COLNUM="1" COLNAME="col1" COLWIDTH="1*" COLSEP="1" ALIGN="left"><COLSPEC COLNUM="2" COLNAME="col2" COLWIDTH="1*" ALIGN="left">
<THEAD>
<ROW><ENTRY COLNAME="col1" ALIGN="center" VALIGN="top">ATTRIBUTE TYPE</ENTRY>
<ENTRY COLNAME="col2" ALIGN="center" VALIGN="top">ATTRIBUTE VALUE</ENTRY>
</ROW>
</THEAD>
<TBODY>
<ROW><ENTRY>Availability</ENTRY><ENTRY>SUNWj5rt, SUNWj5<?Pub Caret>dev</ENTRY>
</ROW>
</TBODY>
</COLSPEC></COLSPEC></TGROUP>
</INFORMALTABLE>
</REFSECT1>
<REFSECT1><TITLE>&also-tt;</TITLE>
<PARA><CITEREFENTRY><REFENTRYTITLE>jar</REFENTRYTITLE><MANVOLNUM>1</MANVOLNUM>
</CITEREFENTRY>, <CITEREFENTRY><REFENTRYTITLE>jarsigner</REFENTRYTITLE><MANVOLNUM>
1</MANVOLNUM></CITEREFENTRY>, <CITEREFENTRY><REFENTRYTITLE>attributes</REFENTRYTITLE>
<MANVOLNUM>5</MANVOLNUM></CITEREFENTRY> </PARA>
<PARA>See (or search <LITERAL>java.sun.com</LITERAL>) for the following:</PARA>
<VARIABLELIST TERMLENGTH="wholeline">
<VARLISTENTRY><TERM REMAP="10"><CITETITLE>Security in the Java Platform</CITETITLE>
@</TERM><LISTITEM><PARA><ULINK URL="http://java.sun.com/docs/books/tutorial/security1.2/index.html"></ULINK>http://java.sun.com/docs/books/tutorial/security1.2/index.html
</PARA>
</LISTITEM></VARLISTENTRY>
</VARIABLELIST></REFSECT1>
<!--+ 07/27/00 08:35:00
    | tagMorph:  $Id: tagMorph-engine 1.54 1998/01/19 05:44:48 $
    | tagMorph library:  $Id: libtagMorph.a 1.50 1998/01/19 22:02:51 $
    | sunman-to-solbook 1.17
    +-->

</REFENTRY><?Pub *0000092095>

